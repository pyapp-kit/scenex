{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"scenex","text":"<p>In development</p> <p>This library is a work in progress. The API will change frequently as we add new features and improve existing ones.</p> <p>Scenex is a Python API for creating and manipulating 3D scenes.</p> <p>It does not implement any rendering or graphics directly, but rather serves as a high-level interface and adaptor for existing scene-graph libraries, such as vispy and pygfx, and hopefully others (like datovis) in the future.</p> <p>The goal is to provide a clear scene graph model (backed by pydantic ), with backend adaptors that connect the model to the actual rendering engine.  The models emit events upon mutation (using psygnal), and the adaptors listen to these events and update the scene graph.</p> <p>Because the models are backed by pydantic, they can be easily serialized to JSON and other formats, making it easy to save and load scenes, and define them declaratively.</p>"},{"location":"reference/scenex/","title":"scenex","text":""},{"location":"reference/scenex/#scenex","title":"scenex","text":"<p>Declarative scene graph model.</p> <p>Modules:</p> <ul> <li> <code>adaptors</code>           \u2013            <p>Adaptors are the link between <code>scenex</code> models and graphics libraries.</p> </li> <li> <code>model</code>           \u2013            <p>Model objects for the scene graph.</p> </li> <li> <code>util</code>           \u2013            <p>Utility functions for <code>scenex</code>.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>Camera</code>           \u2013            <p>A camera that defines the view and perspective of a scene.</p> </li> <li> <code>Canvas</code>           \u2013            <p>Canvas onto which views are rendered.</p> </li> <li> <code>Image</code>           \u2013            <p>A dense array of intensity values.</p> </li> <li> <code>Node</code>           \u2013            <p>Base class for all nodes.  Also a <code>Container[Node]</code>.</p> </li> <li> <code>Points</code>           \u2013            <p>Coordinates that can be represented in a scene.</p> </li> <li> <code>Scene</code>           \u2013            <p>A root node for a scene graph.</p> </li> <li> <code>Transform</code>           \u2013            <p>A 4x4 transformation matrix placing a 3D object in 3D space.</p> </li> <li> <code>View</code>           \u2013            <p>An association of a scene and a camera.</p> </li> <li> <code>Volume</code>           \u2013            <p>A dense 3-dimensional array of intensity values.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>loop</code>             \u2013              <p>Enter the native GUI event loop.</p> </li> <li> <code>show</code>             \u2013              <p>Show a scene or view.</p> </li> </ul>"},{"location":"reference/scenex/#scenex.Camera","title":"Camera","text":"<pre><code>Camera(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <p>A camera that defines the view and perspective of a scene.</p> <p>The camera lives in, and is a child of, a scene graph.  It defines the view transformation for the scene, mapping it onto a 2D surface.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[\"Node | dict[str, Any]\"] = (),\n    **data: \"Unpack[NodeKwargs]\",\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = Node.model_validate(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/#scenex.Camera.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[\"Node\"]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: \"Node\") -&gt; tuple[list[\"Node\"], list[\"Node\"]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Camera.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: \"Node\") -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Camera.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/#scenex.Canvas","title":"Canvas","text":"<p>               Bases: <code>EventedBase</code></p> <p>Canvas onto which views are rendered.</p> <p>In desktop applications, this will be a window. In web applications, this will be a div.  The canvas has one or more views, which are rendered onto it.  For example, an orthoviewer might be a single canvas with three views, one for each axis.</p> <p>Methods:</p> <ul> <li> <code>model_post_init</code>             \u2013              <p>Post-initialization hook for the model.</p> </li> <li> <code>render</code>             \u2013              <p>Show the canvas.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>size</code>               (<code>tuple[int, int]</code>)           \u2013            <p>Return the size of the canvas.</p> </li> </ul>"},{"location":"reference/scenex/#scenex.Canvas.size","title":"size  <code>property</code> <code>writable</code>","text":"<pre><code>size: tuple[int, int]\n</code></pre> <p>Return the size of the canvas.</p>"},{"location":"reference/scenex/#scenex.Canvas.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Post-initialization hook for the model.</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Post-initialization hook for the model.\"\"\"\n    for view in self.views:\n        view._canvas = self\n</code></pre>"},{"location":"reference/scenex/#scenex.Canvas.render","title":"render","text":"<pre><code>render() -&gt; ndarray\n</code></pre> <p>Show the canvas.</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def render(self) -&gt; np.ndarray:\n    \"\"\"Show the canvas.\"\"\"\n    adaptor = cast(\"CanvasAdaptor\", self._get_adaptor())\n    return adaptor._snx_render()\n</code></pre>"},{"location":"reference/scenex/#scenex.Image","title":"Image","text":"<pre><code>Image(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <p>A dense array of intensity values.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[\"Node | dict[str, Any]\"] = (),\n    **data: \"Unpack[NodeKwargs]\",\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = Node.model_validate(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/#scenex.Image.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/#scenex.Image.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Image.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[\"Node\"]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/#scenex.Image.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Image.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: \"Node\") -&gt; tuple[list[\"Node\"], list[\"Node\"]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/#scenex.Image.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Image.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Image.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: \"Node\") -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Image.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Image.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/#scenex.Node","title":"Node","text":"<pre><code>Node(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>EventedBase</code></p> <p>Base class for all nodes.  Also a <code>Container[Node]</code>.</p> <p>Do not instantiate this class directly. Use a subclass.  GenericNode may be used in place of Node.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[\"Node | dict[str, Any]\"] = (),\n    **data: \"Unpack[NodeKwargs]\",\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = Node.model_validate(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/#scenex.Node.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/#scenex.Node.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Node.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[\"Node\"]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/#scenex.Node.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Node.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: \"Node\") -&gt; tuple[list[\"Node\"], list[\"Node\"]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/#scenex.Node.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Node.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Node.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: \"Node\") -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Node.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Node.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/#scenex.Points","title":"Points","text":"<pre><code>Points(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <p>Coordinates that can be represented in a scene.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[\"Node | dict[str, Any]\"] = (),\n    **data: \"Unpack[NodeKwargs]\",\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = Node.model_validate(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/#scenex.Points.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/#scenex.Points.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Points.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[\"Node\"]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/#scenex.Points.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Points.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: \"Node\") -&gt; tuple[list[\"Node\"], list[\"Node\"]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/#scenex.Points.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Points.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Points.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: \"Node\") -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Points.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Points.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene","title":"Scene","text":"<pre><code>Scene(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <p>A root node for a scene graph.</p> <p>This really isn't anything more than a regular Node, but it's an explicit marker that this node is the root of a scene graph.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/scene.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[\"Node | dict[str, Any]\"] = (),\n    **data: \"Unpack[NodeKwargs]\",\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/#scenex.Scene.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[\"Node\"]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: \"Node\") -&gt; tuple[list[\"Node\"], list[\"Node\"]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Scene.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: \"Node\") -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Scene.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform","title":"Transform","text":"<p>               Bases: <code>RootModel</code></p> <p>A 4x4 transformation matrix placing a 3D object in 3D space.</p> <p>Methods:</p> <ul> <li> <code>chain</code>             \u2013              <p>Chain multiple transforms together.</p> </li> <li> <code>dot</code>             \u2013              <p>Return the dot product of this transform with another.</p> </li> <li> <code>imap</code>             \u2013              <p>Inverse map coordinates.</p> </li> <li> <code>inv</code>             \u2013              <p>Return the inverse of the transform.</p> </li> <li> <code>is_null</code>             \u2013              <p>Return True if the transform is the identity matrix.</p> </li> <li> <code>map</code>             \u2013              <p>Map coordinates.</p> </li> <li> <code>rotated</code>             \u2013              <p>Return new transform, rotated some angle about a given axis.</p> </li> <li> <code>scaled</code>             \u2013              <p>Return new transform, scaled about a given origin.</p> </li> <li> <code>translated</code>             \u2013              <p>Return new transform, translated by pos.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>T</code>               (<code>Transform</code>)           \u2013            <p>Return the transpose of the transform.</p> </li> </ul>"},{"location":"reference/scenex/#scenex.Transform.T","title":"T  <code>property</code>","text":"<pre><code>T: Transform\n</code></pre> <p>Return the transpose of the transform.</p>"},{"location":"reference/scenex/#scenex.Transform.chain","title":"chain  <code>classmethod</code>","text":"<pre><code>chain(*transforms: Transform) -&gt; Transform\n</code></pre> <p>Chain multiple transforms together.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>Transform</code> )          \u2013            <p>Chained transform.</p> </li> </ul> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>@classmethod\ndef chain(cls, *transforms: Transform) -&gt; Transform:\n    \"\"\"Chain multiple transforms together.\n\n    Parameters\n    ----------\n    transforms : Transform\n        Transforms to chain.\n\n    Returns\n    -------\n    transform : Transform\n        Chained transform.\n    \"\"\"\n    return reduce(lambda a, b: a @ b, transforms, cls())\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.chain(transforms)","title":"<code>transforms</code>","text":"(<code>Transform</code>, default:                   <code>()</code> )           \u2013            <p>Transforms to chain.</p>"},{"location":"reference/scenex/#scenex.Transform.dot","title":"dot","text":"<pre><code>dot(other: Transform | ArrayLike) -&gt; Transform\n</code></pre> <p>Return the dot product of this transform with another.</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def dot(self, other: Transform | ArrayLike) -&gt; Transform:\n    \"\"\"Return the dot product of this transform with another.\"\"\"\n    if isinstance(other, Transform):\n        other = other.root\n    return Transform(np.dot(self.root, other))\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.imap","title":"imap","text":"<pre><code>imap(coords: ArrayLike) -&gt; NDArray\n</code></pre> <p>Inverse map coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>coords</code> (              <code>ndarray</code> )          \u2013            <p>Coordinates.</p> </li> </ul> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>@_arg_to_vec4\ndef imap(self, coords: ArrayLike) -&gt; NDArray:\n    \"\"\"Inverse map coordinates.\n\n    Parameters\n    ----------\n    coords : array-like\n        Coordinates to inverse map.\n\n    Returns\n    -------\n    coords : ndarray\n        Coordinates.\n    \"\"\"\n    return cast(\"NDArray\", np.dot(coords, np.linalg.inv(self.root)))\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.imap(coords)","title":"<code>coords</code>","text":"(<code>array - like</code>)           \u2013            <p>Coordinates to inverse map.</p>"},{"location":"reference/scenex/#scenex.Transform.inv","title":"inv","text":"<pre><code>inv() -&gt; Transform\n</code></pre> <p>Return the inverse of the transform.</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def inv(self) -&gt; Transform:\n    \"\"\"Return the inverse of the transform.\"\"\"\n    return Transform(np.linalg.inv(self.root))  # type: ignore\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.is_null","title":"is_null","text":"<pre><code>is_null() -&gt; bool\n</code></pre> <p>Return True if the transform is the identity matrix.</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def is_null(self) -&gt; bool:\n    \"\"\"Return True if the transform is the identity matrix.\"\"\"\n    return np.allclose(self.root, np.eye(4))\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.map","title":"map","text":"<pre><code>map(coords: ArrayLike) -&gt; NDArray\n</code></pre> <p>Map coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>coords</code> (              <code>ndarray</code> )          \u2013            <p>Coordinates.</p> </li> </ul> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>@_arg_to_vec4\ndef map(self, coords: ArrayLike) -&gt; NDArray:\n    \"\"\"Map coordinates.\n\n    Parameters\n    ----------\n    coords : array-like\n        Coordinates to map.\n\n    Returns\n    -------\n    coords : ndarray\n        Coordinates.\n    \"\"\"\n    # looks backwards, but both matrices are transposed.\n    return cast(\"NDArray\", np.dot(coords, self.root))\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.map(coords)","title":"<code>coords</code>","text":"(<code>array - like</code>)           \u2013            <p>Coordinates to map.</p>"},{"location":"reference/scenex/#scenex.Transform.rotated","title":"rotated","text":"<pre><code>rotated(\n    angle: float,\n    axis: ArrayLike = (0, 0, 1),\n    about: ArrayLike | None = None,\n) -&gt; Transform\n</code></pre> <p>Return new transform, rotated some angle about a given axis.</p> <p>The rotation is applied after the transformations already present in the matrix.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def rotated(\n    self, angle: float, axis: ArrayLike = (0, 0, 1), about: ArrayLike | None = None\n) -&gt; Transform:\n    \"\"\"Return new transform, rotated some angle about a given axis.\n\n    The rotation is applied *after* the transformations already present\n    in the matrix.\n\n    Parameters\n    ----------\n    angle : float\n        The angle of rotation, in degrees.\n    axis : array-like\n        The x, y and z coordinates of the axis vector to rotate around.\n        By default, will rotate around the z-axis: `(0, 0, 1)`.\n    about : array-like or None\n        The x, y and z coordinates to rotate around. If None, will rotate around\n        the origin (0, 0, 0).\n    \"\"\"\n    if about is not None:\n        about = as_vec4(about)[0, :3]\n        return self.translated(-about).dot(rotate(angle, axis)).translated(about)\n    return self.dot(rotate(angle, axis))\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.rotated(angle)","title":"<code>angle</code>","text":"(<code>float</code>)           \u2013            <p>The angle of rotation, in degrees.</p>"},{"location":"reference/scenex/#scenex.Transform.rotated(axis)","title":"<code>axis</code>","text":"(<code>array - like</code>, default:                   <code>(0, 0, 1)</code> )           \u2013            <p>The x, y and z coordinates of the axis vector to rotate around. By default, will rotate around the z-axis: <code>(0, 0, 1)</code>.</p>"},{"location":"reference/scenex/#scenex.Transform.rotated(about)","title":"<code>about</code>","text":"(<code>array - like or None</code>, default:                   <code>None</code> )           \u2013            <p>The x, y and z coordinates to rotate around. If None, will rotate around the origin (0, 0, 0).</p>"},{"location":"reference/scenex/#scenex.Transform.scaled","title":"scaled","text":"<pre><code>scaled(\n    scale_factor: ArrayLike, center: ArrayLike | None = None\n) -&gt; Transform\n</code></pre> <p>Return new transform, scaled about a given origin.</p> <p>The scaling is applied after the transformations already present in the matrix.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def scaled(\n    self, scale_factor: ArrayLike, center: ArrayLike | None = None\n) -&gt; Transform:\n    \"\"\"Return new transform, scaled about a given origin.\n\n    The scaling is applied *after* the transformations already present\n    in the matrix.\n\n    Parameters\n    ----------\n    scale_factor : array-like\n        Scale factors along x, y and z axes.\n    center : array-like or None\n        The x, y and z coordinates to scale around. If None,\n        (0, 0, 0) will be used.\n    \"\"\"\n    _scale = scale(as_vec4(scale_factor, default=(1, 1, 1, 1))[0, :3])\n    if center is not None:\n        center = as_vec4(center)[0, :3]\n        _scale = np.dot(np.dot(translate(-center), _scale), translate(center))\n    return self.dot(_scale)\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.scaled(scale_factor)","title":"<code>scale_factor</code>","text":"(<code>array - like</code>)           \u2013            <p>Scale factors along x, y and z axes.</p>"},{"location":"reference/scenex/#scenex.Transform.scaled(center)","title":"<code>center</code>","text":"(<code>array - like or None</code>, default:                   <code>None</code> )           \u2013            <p>The x, y and z coordinates to scale around. If None, (0, 0, 0) will be used.</p>"},{"location":"reference/scenex/#scenex.Transform.translated","title":"translated","text":"<pre><code>translated(pos: ArrayLike) -&gt; Transform\n</code></pre> <p>Return new transform, translated by pos.</p> <p>The translation is applied after the transformations already present in the matrix.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def translated(self, pos: ArrayLike) -&gt; Transform:\n    \"\"\"Return new transform, translated by pos.\n\n    The translation is applied *after* the transformations already present\n    in the matrix.\n\n    Parameters\n    ----------\n    pos : ArrayLike\n        Position (x, y, z) to translate by.\n    \"\"\"\n    pos = as_vec4(np.array(pos))\n    return self.dot(translate(pos[0, :3]))\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.translated(pos)","title":"<code>pos</code>","text":"(<code>ArrayLike</code>)           \u2013            <p>Position (x, y, z) to translate by.</p>"},{"location":"reference/scenex/#scenex.View","title":"View","text":"<p>               Bases: <code>EventedBase</code></p> <p>An association of a scene and a camera.</p> <p>A view represents a rectangular area on a canvas that displays a single scene with a single camera.</p> <p>A canvas can have one or more views. Each view has a single scene (i.e. a scene graph of nodes) and a single camera. The camera defines the view transformation.  This class just exists to associate a single scene and camera.</p> <p>Methods:</p> <ul> <li> <code>model_post_init</code>             \u2013              <p>Post-initialization hook for the model.</p> </li> <li> <code>render</code>             \u2013              <p>Show the canvas.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>canvas</code>               (<code>Canvas</code>)           \u2013            <p>The canvas that the view is on.</p> </li> </ul>"},{"location":"reference/scenex/#scenex.View.canvas","title":"canvas  <code>property</code> <code>writable</code>","text":"<pre><code>canvas: Canvas\n</code></pre> <p>The canvas that the view is on.</p> <p>If one hasn't been created/assigned, a new one is created.</p>"},{"location":"reference/scenex/#scenex.View.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Post-initialization hook for the model.</p> Source code in <code>src/scenex/model/_view.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Post-initialization hook for the model.\"\"\"\n    super().model_post_init(__context)\n    self.camera.parent = self.scene\n</code></pre>"},{"location":"reference/scenex/#scenex.View.render","title":"render","text":"<pre><code>render() -&gt; ndarray\n</code></pre> <p>Show the canvas.</p> Source code in <code>src/scenex/model/_view.py</code> <pre><code>def render(self) -&gt; np.ndarray:\n    \"\"\"Show the canvas.\"\"\"\n    adaptor = cast(\"ViewAdaptor\", self._get_adaptor())\n    return adaptor._snx_render()\n</code></pre>"},{"location":"reference/scenex/#scenex.Volume","title":"Volume","text":"<pre><code>Volume(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Image</code></p> <p>A dense 3-dimensional array of intensity values.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[\"Node | dict[str, Any]\"] = (),\n    **data: \"Unpack[NodeKwargs]\",\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = Node.model_validate(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/#scenex.Volume.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/#scenex.Volume.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Volume.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[\"Node\"]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/#scenex.Volume.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Volume.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: \"Node\") -&gt; tuple[list[\"Node\"], list[\"Node\"]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/#scenex.Volume.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Volume.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Volume.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: \"Node\") -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Volume.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Volume.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/#scenex.loop","title":"loop","text":"<pre><code>loop() -&gt; None\n</code></pre> <p>Enter the native GUI event loop.</p> Source code in <code>src/scenex/util.py</code> <pre><code>def loop() -&gt; None:\n    \"\"\"Enter the native GUI event loop.\"\"\"\n    if determine_backend() == \"vispy\":\n        from vispy.app import run\n\n        run()\n    else:\n        from rendercanvas.auto import loop\n\n        loop.run()\n</code></pre>"},{"location":"reference/scenex/#scenex.show","title":"show","text":"<pre><code>show(obj: Node | View | Canvas) -&gt; None\n</code></pre> <p>Show a scene or view.</p> <p>Parameters:</p> Source code in <code>src/scenex/util.py</code> <pre><code>def show(obj: model.Node | model.View | model.Canvas) -&gt; None:\n    \"\"\"Show a scene or view.\n\n    Parameters\n    ----------\n    obj : Node | View | Canvas\n        The scene or view to show. If a Node is provided, it will be wrapped in a Scene\n        and then in a View.\n    \"\"\"\n    from .adaptors import get_adaptor_registry\n\n    if isinstance(obj, model.Canvas):\n        canvas = obj\n    else:\n        if isinstance(obj, model.View):\n            view = obj\n        elif isinstance(obj, model.Scene):\n            view = model.View(scene=obj)\n        elif isinstance(obj, model.Node):\n            scene = model.Scene(children=[obj])\n            view = model.View(scene=scene)\n\n        canvas = model.Canvas(views=[view])  # pyright: ignore[reportArgumentType]\n\n    canvas.visible = True\n    reg = get_adaptor_registry()\n    reg.get_adaptor(canvas, create=True)\n    for view in canvas.views:\n        cam = reg.get_adaptor(view.camera)\n        cam._snx_zoom_to_fit(0.1)\n</code></pre>"},{"location":"reference/scenex/#scenex.show(obj)","title":"<code>obj</code>","text":"(<code>Node | View | Canvas</code>)           \u2013            <p>The scene or view to show. If a Node is provided, it will be wrapped in a Scene and then in a View.</p>"},{"location":"reference/scenex/adaptors/","title":"scenex.adaptors","text":""},{"location":"reference/scenex/adaptors/#scenex.adaptors","title":"scenex.adaptors","text":"<p>Adaptors are the link between <code>scenex</code> models and graphics libraries.</p> <p>For each model in <code>scenex.model</code>, there is a corresponding adaptor in <code>scenex.adaptors</code>.  \"Showing\" a model means creating an adaptor for each object in the model.</p> <p>Classes:</p> <ul> <li> <code>Adaptor</code>           \u2013            <p>ABC for backend adaptor classes.</p> </li> <li> <code>AdaptorRegistry</code>           \u2013            <p>Weak registry for Adaptor objects.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_adaptor_registry</code>             \u2013              <p>Get the backend adaptor registry.</p> </li> </ul>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.Adaptor","title":"Adaptor","text":"<pre><code>Adaptor(obj: TModel)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[TModel, TNative]</code></p> <p>ABC for backend adaptor classes.</p> <p>An adaptor converts model change events into into native calls for the given backend.</p> <p>All backend adaptor objects receive the object they are adapting.</p> <p>Methods:</p> <ul> <li> <code>handle_event</code>             \u2013              <p>Receive info from psygnal callback and convert to adaptor call.</p> </li> </ul> Source code in <code>src/scenex/adaptors/_base.py</code> <pre><code>@abstractmethod\ndef __init__(self, obj: TModel) -&gt; None:\n    \"\"\"All backend adaptor objects receive the object they are adapting.\"\"\"\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.Adaptor.handle_event","title":"handle_event","text":"<pre><code>handle_event(info: EmissionInfo) -&gt; None\n</code></pre> <p>Receive info from psygnal callback and convert to adaptor call.</p> Source code in <code>src/scenex/adaptors/_base.py</code> <pre><code>def handle_event(self, info: EmissionInfo) -&gt; None:\n    \"\"\"Receive info from psygnal callback and convert to adaptor call.\"\"\"\n    signal_name = info.signal.name\n\n    try:\n        name = self.SETTER_METHOD.format(name=signal_name)\n        setter = getattr(self, name)\n    except AttributeError as e:\n        logger.exception(e)\n        return\n\n    arg = info.args[0]\n    logger.debug(\"EVENT: %r -&gt; %s=%r  \", type(self), signal_name, arg)\n\n    try:\n        setter(arg)\n    except Exception as e:\n        logger.exception(e)\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.AdaptorRegistry","title":"AdaptorRegistry","text":"<pre><code>AdaptorRegistry()\n</code></pre> <p>Weak registry for Adaptor objects.</p> <p>Each backend should subclass this and implement the <code>get_adaptor_class</code> method. And expose an instance of the subclass as <code>adaptors</code> in the top level of the backend module.</p> <p>Methods:</p> <ul> <li> <code>all</code>             \u2013              <p>Return an iterator over all adaptors in the registry.</p> </li> <li> <code>create_adaptor</code>             \u2013              <p>Create a new adaptor for the given model object.</p> </li> <li> <code>get_adaptor</code>             \u2013              <p>Get the adaptor for the given model object, create if <code>create</code> is True.</p> </li> <li> <code>get_adaptor_class</code>             \u2013              <p>Return the adaptor class for the given model object.</p> </li> <li> <code>initialize_adaptor</code>             \u2013              <p>Initialize the adaptor for the given model object.</p> </li> <li> <code>validate_adaptor_class</code>             \u2013              <p>Validate that the given class is a valid adaptor for the given object.</p> </li> </ul> Source code in <code>src/scenex/adaptors/_registry.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._objects: dict[str, _base.Adaptor] = {}\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.AdaptorRegistry.all","title":"all","text":"<pre><code>all() -&gt; Iterator[Adaptor]\n</code></pre> <p>Return an iterator over all adaptors in the registry.</p> Source code in <code>src/scenex/adaptors/_registry.py</code> <pre><code>def all(self) -&gt; Iterator[_base.Adaptor]:\n    \"\"\"Return an iterator over all adaptors in the registry.\"\"\"\n    yield from self._objects.values()\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.AdaptorRegistry.create_adaptor","title":"create_adaptor","text":"<pre><code>create_adaptor(model: _M) -&gt; Adaptor[_M, Any]\n</code></pre> <p>Create a new adaptor for the given model object.</p> Source code in <code>src/scenex/adaptors/_registry.py</code> <pre><code>def create_adaptor(self, model: _M) -&gt; _base.Adaptor[_M, Any]:\n    \"\"\"Create a new adaptor for the given model object.\"\"\"\n    adaptor_cls: type[_base.Adaptor] = self.get_adaptor_class(model)\n    self.validate_adaptor_class(model, adaptor_cls)\n    adaptor = adaptor_cls(model)\n\n    return adaptor\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.AdaptorRegistry.get_adaptor","title":"get_adaptor","text":"<pre><code>get_adaptor(\n    obj: Points, create: bool = ...\n) -&gt; PointsAdaptor\n</code></pre><pre><code>get_adaptor(obj: Image, create: bool = ...) -&gt; ImageAdaptor\n</code></pre><pre><code>get_adaptor(\n    obj: Camera, create: bool = ...\n) -&gt; CameraAdaptor\n</code></pre><pre><code>get_adaptor(obj: Scene, create: bool = ...) -&gt; NodeAdaptor\n</code></pre><pre><code>get_adaptor(obj: View, create: bool = ...) -&gt; ViewAdaptor\n</code></pre><pre><code>get_adaptor(\n    obj: Canvas, create: bool = ...\n) -&gt; CanvasAdaptor\n</code></pre><pre><code>get_adaptor(\n    obj: EventedBase, create: bool = ...\n) -&gt; Adaptor\n</code></pre> <pre><code>get_adaptor(\n    obj: _M, create: bool = True\n) -&gt; Adaptor[_M, Any]\n</code></pre> <p>Get the adaptor for the given model object, create if <code>create</code> is True.</p> Source code in <code>src/scenex/adaptors/_registry.py</code> <pre><code>def get_adaptor(self, obj: _M, create: bool = True) -&gt; _base.Adaptor[_M, Any]:\n    \"\"\"Get the adaptor for the given model object, create if `create` is True.\"\"\"\n    if obj._model_id.hex not in self._objects:\n        if not create:\n            raise KeyError(f\"No adaptor found for {obj!r}, and create=False\")\n        logger.debug(\n            \"Creating %r Adaptor %-14r id: %s\",\n            type(self).__module__,\n            type(obj).__name__,\n            obj._model_id.hex[:8],\n        )\n        self._objects[obj._model_id.hex] = adaptor = self.create_adaptor(obj)\n        self.initialize_adaptor(obj, adaptor)\n    return self._objects[obj._model_id.hex]\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.AdaptorRegistry.get_adaptor_class","title":"get_adaptor_class","text":"<pre><code>get_adaptor_class(obj: EventedBase) -&gt; type[Adaptor]\n</code></pre> <p>Return the adaptor class for the given model object.</p> Source code in <code>src/scenex/adaptors/_registry.py</code> <pre><code>def get_adaptor_class(self, obj: model.EventedBase) -&gt; type[_base.Adaptor]:\n    \"\"\"Return the adaptor class for the given model object.\"\"\"\n    cls = type(self)\n    cls_module = sys.modules[cls.__module__]\n    cls_file = cls_module.__file__\n    raise NotImplementedError(\n        f\"{cls.__name__}.get_adaptor_class not implemented in {cls_file}\"\n    )\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.AdaptorRegistry.initialize_adaptor","title":"initialize_adaptor","text":"<pre><code>initialize_adaptor(\n    model: EventedBase, adaptor: Adaptor\n) -&gt; None\n</code></pre> <p>Initialize the adaptor for the given model object.</p> Source code in <code>src/scenex/adaptors/_registry.py</code> <pre><code>def initialize_adaptor(\n    self, model: model.EventedBase, adaptor: _base.Adaptor\n) -&gt; None:\n    \"\"\"Initialize the adaptor for the given model object.\"\"\"\n    # syncronize all model properties with the adaptor\n    sync_adaptor(adaptor, model)\n    # connect the model events to the adaptor, to keep the adaptor in sync\n\n    model.events.connect(adaptor.handle_event)\n\n    if isinstance(model, models.Canvas):\n        for view in model.views:\n            self.get_adaptor(view, create=True)\n    if isinstance(model, models.View):\n        self.get_adaptor(model.scene, create=True)\n    if isinstance(model, models.Node):\n        adaptor = cast(\"_base.NodeAdaptor\", adaptor)\n        model.child_added.connect(adaptor._snx_add_child)\n        model.child_removed.connect(adaptor._snx_remove_child)\n        for child in model.children:\n            # perhaps optional ... since _implementations of _snx_add_child\n            # will also likely need to call get_adaptor\n            self.get_adaptor(child, create=True)\n            adaptor._snx_add_child(child)\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.AdaptorRegistry.validate_adaptor_class","title":"validate_adaptor_class  <code>classmethod</code>","text":"<pre><code>validate_adaptor_class(\n    obj: EventedBase, adaptor_cls: type[Adaptor]\n) -&gt; None\n</code></pre> <p>Validate that the given class is a valid adaptor for the given object.</p> Source code in <code>src/scenex/adaptors/_registry.py</code> <pre><code>@classmethod\ndef validate_adaptor_class(\n    cls, obj: model.EventedBase, adaptor_cls: type[_base.Adaptor]\n) -&gt; None:\n    \"\"\"Validate that the given class is a valid adaptor for the given object.\"\"\"\n    return _validate_adaptor_class(type(obj), adaptor_cls)\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.get_adaptor_registry","title":"get_adaptor_registry","text":"<pre><code>get_adaptor_registry(\n    backend: str | None = None,\n) -&gt; AdaptorRegistry\n</code></pre> <p>Get the backend adaptor registry.</p> Source code in <code>src/scenex/adaptors/_auto.py</code> <pre><code>def get_adaptor_registry(backend: str | None = None) -&gt; AdaptorRegistry:\n    \"\"\"Get the backend adaptor registry.\"\"\"\n    if determine_backend(backend) == \"vispy\":\n        from ._vispy import adaptors\n\n        return adaptors\n    else:\n        from ._pygfx import adaptors  # type: ignore\n\n        return adaptors\n</code></pre>"},{"location":"reference/scenex/model/","title":"scenex.model","text":""},{"location":"reference/scenex/model/#scenex.model","title":"scenex.model","text":"<p>Model objects for the scene graph.</p> <p>The entire scene graph is built from these objects.  The scene graph is a tree of nodes, where each node is a model object.  The root of the tree is a <code>Scene</code> object, which contains all the other nodes.  Each node can have children, which are also nodes.</p> <p>To \"view\" a model means to create a backend adaptor for each node in the scene graph.  The adaptor is responsible for rendering the node and interacting with the backend.  Adaptors live in <code>scenex.adaptors</code>.</p> <p>Classes:</p> <ul> <li> <code>Camera</code>           \u2013            <p>A camera that defines the view and perspective of a scene.</p> </li> <li> <code>Canvas</code>           \u2013            <p>Canvas onto which views are rendered.</p> </li> <li> <code>EventedBase</code>           \u2013            <p>Base class for all evented pydantic-style models.</p> </li> <li> <code>Image</code>           \u2013            <p>A dense array of intensity values.</p> </li> <li> <code>Layout</code>           \u2013            <p>Rectangular layout model.</p> </li> <li> <code>Node</code>           \u2013            <p>Base class for all nodes.  Also a <code>Container[Node]</code>.</p> </li> <li> <code>Points</code>           \u2013            <p>Coordinates that can be represented in a scene.</p> </li> <li> <code>Scene</code>           \u2013            <p>A root node for a scene graph.</p> </li> <li> <code>Transform</code>           \u2013            <p>A 4x4 transformation matrix placing a 3D object in 3D space.</p> </li> <li> <code>View</code>           \u2013            <p>An association of a scene and a camera.</p> </li> <li> <code>Volume</code>           \u2013            <p>A dense 3-dimensional array of intensity values.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.Camera","title":"Camera","text":"<pre><code>Camera(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <p>A camera that defines the view and perspective of a scene.</p> <p>The camera lives in, and is a child of, a scene graph.  It defines the view transformation for the scene, mapping it onto a 2D surface.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[\"Node | dict[str, Any]\"] = (),\n    **data: \"Unpack[NodeKwargs]\",\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = Node.model_validate(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/model/#scenex.model.Camera.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[\"Node\"]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: \"Node\") -&gt; tuple[list[\"Node\"], list[\"Node\"]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Camera.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: \"Node\") -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Camera.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Canvas","title":"Canvas","text":"<p>               Bases: <code>EventedBase</code></p> <p>Canvas onto which views are rendered.</p> <p>In desktop applications, this will be a window. In web applications, this will be a div.  The canvas has one or more views, which are rendered onto it.  For example, an orthoviewer might be a single canvas with three views, one for each axis.</p> <p>Methods:</p> <ul> <li> <code>model_post_init</code>             \u2013              <p>Post-initialization hook for the model.</p> </li> <li> <code>render</code>             \u2013              <p>Show the canvas.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>size</code>               (<code>tuple[int, int]</code>)           \u2013            <p>Return the size of the canvas.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.Canvas.size","title":"size  <code>property</code> <code>writable</code>","text":"<pre><code>size: tuple[int, int]\n</code></pre> <p>Return the size of the canvas.</p>"},{"location":"reference/scenex/model/#scenex.model.Canvas.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Post-initialization hook for the model.</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Post-initialization hook for the model.\"\"\"\n    for view in self.views:\n        view._canvas = self\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Canvas.render","title":"render","text":"<pre><code>render() -&gt; ndarray\n</code></pre> <p>Show the canvas.</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def render(self) -&gt; np.ndarray:\n    \"\"\"Show the canvas.\"\"\"\n    adaptor = cast(\"CanvasAdaptor\", self._get_adaptor())\n    return adaptor._snx_render()\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.EventedBase","title":"EventedBase","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all evented pydantic-style models.</p> <p>Methods:</p> <ul> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.EventedBase.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image","title":"Image","text":"<pre><code>Image(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <p>A dense array of intensity values.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[\"Node | dict[str, Any]\"] = (),\n    **data: \"Unpack[NodeKwargs]\",\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = Node.model_validate(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/model/#scenex.model.Image.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[\"Node\"]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: \"Node\") -&gt; tuple[list[\"Node\"], list[\"Node\"]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Image.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: \"Node\") -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Image.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Layout","title":"Layout","text":"<p>               Bases: <code>EventedBase</code></p> <p>Rectangular layout model.</p> <pre><code>y\n|\nv\n</code></pre> <p>x-&gt; +--------------------------------+  ^     |            margin              |  |     |  +--------------------------+  |  |     |  |         border           |  |  |     |  |  +--------------------+  |  |  |     |  |  |      padding       |  |  |  |     |  |  |  +--------------+  |  |  |   height     |  |  |  |   content    |  |  |  |  |     |  |  |  |              |  |  |  |  |     |  |  |  +--------------+  |  |  |  |     |  |  +--------------------+  |  |  |     |  +--------------------------+  |  |     +--------------------------------+  v</p> <pre><code>&lt;------------ width -------------&gt;\n</code></pre> <p>Methods:</p> <ul> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>position</code>               (<code>tuple[float, float]</code>)           \u2013            <p>Return the x, y position of the layout as a tuple.</p> </li> <li> <code>size</code>               (<code>tuple[float, float]</code>)           \u2013            <p>Return the width, height of the layout as a tuple.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.Layout.position","title":"position  <code>property</code>","text":"<pre><code>position: tuple[float, float]\n</code></pre> <p>Return the x, y position of the layout as a tuple.</p>"},{"location":"reference/scenex/model/#scenex.model.Layout.size","title":"size  <code>property</code>","text":"<pre><code>size: tuple[float, float]\n</code></pre> <p>Return the width, height of the layout as a tuple.</p>"},{"location":"reference/scenex/model/#scenex.model.Layout.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node","title":"Node","text":"<pre><code>Node(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>EventedBase</code></p> <p>Base class for all nodes.  Also a <code>Container[Node]</code>.</p> <p>Do not instantiate this class directly. Use a subclass.  GenericNode may be used in place of Node.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[\"Node | dict[str, Any]\"] = (),\n    **data: \"Unpack[NodeKwargs]\",\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = Node.model_validate(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/model/#scenex.model.Node.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[\"Node\"]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: \"Node\") -&gt; tuple[list[\"Node\"], list[\"Node\"]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Node.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: \"Node\") -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Node.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points","title":"Points","text":"<pre><code>Points(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <p>Coordinates that can be represented in a scene.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[\"Node | dict[str, Any]\"] = (),\n    **data: \"Unpack[NodeKwargs]\",\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = Node.model_validate(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/model/#scenex.model.Points.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[\"Node\"]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: \"Node\") -&gt; tuple[list[\"Node\"], list[\"Node\"]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Points.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: \"Node\") -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Points.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene","title":"Scene","text":"<pre><code>Scene(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <p>A root node for a scene graph.</p> <p>This really isn't anything more than a regular Node, but it's an explicit marker that this node is the root of a scene graph.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/scene.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[\"Node | dict[str, Any]\"] = (),\n    **data: \"Unpack[NodeKwargs]\",\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/model/#scenex.model.Scene.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[\"Node\"]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: \"Node\") -&gt; tuple[list[\"Node\"], list[\"Node\"]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Scene.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: \"Node\") -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Scene.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform","title":"Transform","text":"<p>               Bases: <code>RootModel</code></p> <p>A 4x4 transformation matrix placing a 3D object in 3D space.</p> <p>Methods:</p> <ul> <li> <code>chain</code>             \u2013              <p>Chain multiple transforms together.</p> </li> <li> <code>dot</code>             \u2013              <p>Return the dot product of this transform with another.</p> </li> <li> <code>imap</code>             \u2013              <p>Inverse map coordinates.</p> </li> <li> <code>inv</code>             \u2013              <p>Return the inverse of the transform.</p> </li> <li> <code>is_null</code>             \u2013              <p>Return True if the transform is the identity matrix.</p> </li> <li> <code>map</code>             \u2013              <p>Map coordinates.</p> </li> <li> <code>rotated</code>             \u2013              <p>Return new transform, rotated some angle about a given axis.</p> </li> <li> <code>scaled</code>             \u2013              <p>Return new transform, scaled about a given origin.</p> </li> <li> <code>translated</code>             \u2013              <p>Return new transform, translated by pos.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>T</code>               (<code>Transform</code>)           \u2013            <p>Return the transpose of the transform.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.Transform.T","title":"T  <code>property</code>","text":"<pre><code>T: Transform\n</code></pre> <p>Return the transpose of the transform.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.chain","title":"chain  <code>classmethod</code>","text":"<pre><code>chain(*transforms: Transform) -&gt; Transform\n</code></pre> <p>Chain multiple transforms together.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>Transform</code> )          \u2013            <p>Chained transform.</p> </li> </ul> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>@classmethod\ndef chain(cls, *transforms: Transform) -&gt; Transform:\n    \"\"\"Chain multiple transforms together.\n\n    Parameters\n    ----------\n    transforms : Transform\n        Transforms to chain.\n\n    Returns\n    -------\n    transform : Transform\n        Chained transform.\n    \"\"\"\n    return reduce(lambda a, b: a @ b, transforms, cls())\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.chain(transforms)","title":"<code>transforms</code>","text":"(<code>Transform</code>, default:                   <code>()</code> )           \u2013            <p>Transforms to chain.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.dot","title":"dot","text":"<pre><code>dot(other: Transform | ArrayLike) -&gt; Transform\n</code></pre> <p>Return the dot product of this transform with another.</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def dot(self, other: Transform | ArrayLike) -&gt; Transform:\n    \"\"\"Return the dot product of this transform with another.\"\"\"\n    if isinstance(other, Transform):\n        other = other.root\n    return Transform(np.dot(self.root, other))\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.imap","title":"imap","text":"<pre><code>imap(coords: ArrayLike) -&gt; NDArray\n</code></pre> <p>Inverse map coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>coords</code> (              <code>ndarray</code> )          \u2013            <p>Coordinates.</p> </li> </ul> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>@_arg_to_vec4\ndef imap(self, coords: ArrayLike) -&gt; NDArray:\n    \"\"\"Inverse map coordinates.\n\n    Parameters\n    ----------\n    coords : array-like\n        Coordinates to inverse map.\n\n    Returns\n    -------\n    coords : ndarray\n        Coordinates.\n    \"\"\"\n    return cast(\"NDArray\", np.dot(coords, np.linalg.inv(self.root)))\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.imap(coords)","title":"<code>coords</code>","text":"(<code>array - like</code>)           \u2013            <p>Coordinates to inverse map.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.inv","title":"inv","text":"<pre><code>inv() -&gt; Transform\n</code></pre> <p>Return the inverse of the transform.</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def inv(self) -&gt; Transform:\n    \"\"\"Return the inverse of the transform.\"\"\"\n    return Transform(np.linalg.inv(self.root))  # type: ignore\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.is_null","title":"is_null","text":"<pre><code>is_null() -&gt; bool\n</code></pre> <p>Return True if the transform is the identity matrix.</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def is_null(self) -&gt; bool:\n    \"\"\"Return True if the transform is the identity matrix.\"\"\"\n    return np.allclose(self.root, np.eye(4))\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.map","title":"map","text":"<pre><code>map(coords: ArrayLike) -&gt; NDArray\n</code></pre> <p>Map coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>coords</code> (              <code>ndarray</code> )          \u2013            <p>Coordinates.</p> </li> </ul> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>@_arg_to_vec4\ndef map(self, coords: ArrayLike) -&gt; NDArray:\n    \"\"\"Map coordinates.\n\n    Parameters\n    ----------\n    coords : array-like\n        Coordinates to map.\n\n    Returns\n    -------\n    coords : ndarray\n        Coordinates.\n    \"\"\"\n    # looks backwards, but both matrices are transposed.\n    return cast(\"NDArray\", np.dot(coords, self.root))\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.map(coords)","title":"<code>coords</code>","text":"(<code>array - like</code>)           \u2013            <p>Coordinates to map.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.rotated","title":"rotated","text":"<pre><code>rotated(\n    angle: float,\n    axis: ArrayLike = (0, 0, 1),\n    about: ArrayLike | None = None,\n) -&gt; Transform\n</code></pre> <p>Return new transform, rotated some angle about a given axis.</p> <p>The rotation is applied after the transformations already present in the matrix.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def rotated(\n    self, angle: float, axis: ArrayLike = (0, 0, 1), about: ArrayLike | None = None\n) -&gt; Transform:\n    \"\"\"Return new transform, rotated some angle about a given axis.\n\n    The rotation is applied *after* the transformations already present\n    in the matrix.\n\n    Parameters\n    ----------\n    angle : float\n        The angle of rotation, in degrees.\n    axis : array-like\n        The x, y and z coordinates of the axis vector to rotate around.\n        By default, will rotate around the z-axis: `(0, 0, 1)`.\n    about : array-like or None\n        The x, y and z coordinates to rotate around. If None, will rotate around\n        the origin (0, 0, 0).\n    \"\"\"\n    if about is not None:\n        about = as_vec4(about)[0, :3]\n        return self.translated(-about).dot(rotate(angle, axis)).translated(about)\n    return self.dot(rotate(angle, axis))\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.rotated(angle)","title":"<code>angle</code>","text":"(<code>float</code>)           \u2013            <p>The angle of rotation, in degrees.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.rotated(axis)","title":"<code>axis</code>","text":"(<code>array - like</code>, default:                   <code>(0, 0, 1)</code> )           \u2013            <p>The x, y and z coordinates of the axis vector to rotate around. By default, will rotate around the z-axis: <code>(0, 0, 1)</code>.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.rotated(about)","title":"<code>about</code>","text":"(<code>array - like or None</code>, default:                   <code>None</code> )           \u2013            <p>The x, y and z coordinates to rotate around. If None, will rotate around the origin (0, 0, 0).</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.scaled","title":"scaled","text":"<pre><code>scaled(\n    scale_factor: ArrayLike, center: ArrayLike | None = None\n) -&gt; Transform\n</code></pre> <p>Return new transform, scaled about a given origin.</p> <p>The scaling is applied after the transformations already present in the matrix.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def scaled(\n    self, scale_factor: ArrayLike, center: ArrayLike | None = None\n) -&gt; Transform:\n    \"\"\"Return new transform, scaled about a given origin.\n\n    The scaling is applied *after* the transformations already present\n    in the matrix.\n\n    Parameters\n    ----------\n    scale_factor : array-like\n        Scale factors along x, y and z axes.\n    center : array-like or None\n        The x, y and z coordinates to scale around. If None,\n        (0, 0, 0) will be used.\n    \"\"\"\n    _scale = scale(as_vec4(scale_factor, default=(1, 1, 1, 1))[0, :3])\n    if center is not None:\n        center = as_vec4(center)[0, :3]\n        _scale = np.dot(np.dot(translate(-center), _scale), translate(center))\n    return self.dot(_scale)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.scaled(scale_factor)","title":"<code>scale_factor</code>","text":"(<code>array - like</code>)           \u2013            <p>Scale factors along x, y and z axes.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.scaled(center)","title":"<code>center</code>","text":"(<code>array - like or None</code>, default:                   <code>None</code> )           \u2013            <p>The x, y and z coordinates to scale around. If None, (0, 0, 0) will be used.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.translated","title":"translated","text":"<pre><code>translated(pos: ArrayLike) -&gt; Transform\n</code></pre> <p>Return new transform, translated by pos.</p> <p>The translation is applied after the transformations already present in the matrix.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def translated(self, pos: ArrayLike) -&gt; Transform:\n    \"\"\"Return new transform, translated by pos.\n\n    The translation is applied *after* the transformations already present\n    in the matrix.\n\n    Parameters\n    ----------\n    pos : ArrayLike\n        Position (x, y, z) to translate by.\n    \"\"\"\n    pos = as_vec4(np.array(pos))\n    return self.dot(translate(pos[0, :3]))\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.translated(pos)","title":"<code>pos</code>","text":"(<code>ArrayLike</code>)           \u2013            <p>Position (x, y, z) to translate by.</p>"},{"location":"reference/scenex/model/#scenex.model.View","title":"View","text":"<p>               Bases: <code>EventedBase</code></p> <p>An association of a scene and a camera.</p> <p>A view represents a rectangular area on a canvas that displays a single scene with a single camera.</p> <p>A canvas can have one or more views. Each view has a single scene (i.e. a scene graph of nodes) and a single camera. The camera defines the view transformation.  This class just exists to associate a single scene and camera.</p> <p>Methods:</p> <ul> <li> <code>model_post_init</code>             \u2013              <p>Post-initialization hook for the model.</p> </li> <li> <code>render</code>             \u2013              <p>Show the canvas.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>canvas</code>               (<code>Canvas</code>)           \u2013            <p>The canvas that the view is on.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.View.canvas","title":"canvas  <code>property</code> <code>writable</code>","text":"<pre><code>canvas: Canvas\n</code></pre> <p>The canvas that the view is on.</p> <p>If one hasn't been created/assigned, a new one is created.</p>"},{"location":"reference/scenex/model/#scenex.model.View.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Post-initialization hook for the model.</p> Source code in <code>src/scenex/model/_view.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Post-initialization hook for the model.\"\"\"\n    super().model_post_init(__context)\n    self.camera.parent = self.scene\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.View.render","title":"render","text":"<pre><code>render() -&gt; ndarray\n</code></pre> <p>Show the canvas.</p> Source code in <code>src/scenex/model/_view.py</code> <pre><code>def render(self) -&gt; np.ndarray:\n    \"\"\"Show the canvas.\"\"\"\n    adaptor = cast(\"ViewAdaptor\", self._get_adaptor())\n    return adaptor._snx_render()\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Volume","title":"Volume","text":"<pre><code>Volume(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Image</code></p> <p>A dense 3-dimensional array of intensity values.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[\"Node | dict[str, Any]\"] = (),\n    **data: \"Unpack[NodeKwargs]\",\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = Node.model_validate(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Volume.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/model/#scenex.model.Volume.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Volume.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[\"Node\"]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Volume.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Volume.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: \"Node\") -&gt; tuple[list[\"Node\"], list[\"Node\"]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Volume.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Volume.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: \"AnyNode\") -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Volume.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: \"Node\") -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Volume.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Volume.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/util/","title":"scenex.util","text":""},{"location":"reference/scenex/util/#scenex.util","title":"scenex.util","text":"<p>Utility functions for <code>scenex</code>.</p> <p>Functions:</p> <ul> <li> <code>show</code>             \u2013              <p>Show a scene or view.</p> </li> <li> <code>tree_dict</code>             \u2013              <p>Build an intermediate representation of the tree rooted at <code>node</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of <code>node</code> and its descendants.</p> </li> </ul>"},{"location":"reference/scenex/util/#scenex.util.SupportsChildren","title":"SupportsChildren","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for node-like objects that have children.</p> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>Iterable[SupportsChildren]</code>)           \u2013            <p>Return the children of the node.</p> </li> </ul>"},{"location":"reference/scenex/util/#scenex.util.SupportsChildren.children","title":"children  <code>property</code>","text":"<pre><code>children: Iterable[SupportsChildren]\n</code></pre> <p>Return the children of the node.</p>"},{"location":"reference/scenex/util/#scenex.util.loop","title":"loop","text":"<pre><code>loop() -&gt; None\n</code></pre> <p>Enter the native GUI event loop.</p> Source code in <code>src/scenex/util.py</code> <pre><code>def loop() -&gt; None:\n    \"\"\"Enter the native GUI event loop.\"\"\"\n    if determine_backend() == \"vispy\":\n        from vispy.app import run\n\n        run()\n    else:\n        from rendercanvas.auto import loop\n\n        loop.run()\n</code></pre>"},{"location":"reference/scenex/util/#scenex.util.show","title":"show","text":"<pre><code>show(obj: Node | View | Canvas) -&gt; None\n</code></pre> <p>Show a scene or view.</p> <p>Parameters:</p> Source code in <code>src/scenex/util.py</code> <pre><code>def show(obj: model.Node | model.View | model.Canvas) -&gt; None:\n    \"\"\"Show a scene or view.\n\n    Parameters\n    ----------\n    obj : Node | View | Canvas\n        The scene or view to show. If a Node is provided, it will be wrapped in a Scene\n        and then in a View.\n    \"\"\"\n    from .adaptors import get_adaptor_registry\n\n    if isinstance(obj, model.Canvas):\n        canvas = obj\n    else:\n        if isinstance(obj, model.View):\n            view = obj\n        elif isinstance(obj, model.Scene):\n            view = model.View(scene=obj)\n        elif isinstance(obj, model.Node):\n            scene = model.Scene(children=[obj])\n            view = model.View(scene=scene)\n\n        canvas = model.Canvas(views=[view])  # pyright: ignore[reportArgumentType]\n\n    canvas.visible = True\n    reg = get_adaptor_registry()\n    reg.get_adaptor(canvas, create=True)\n    for view in canvas.views:\n        cam = reg.get_adaptor(view.camera)\n        cam._snx_zoom_to_fit(0.1)\n</code></pre>"},{"location":"reference/scenex/util/#scenex.util.show(obj)","title":"<code>obj</code>","text":"(<code>Node | View | Canvas</code>)           \u2013            <p>The scene or view to show. If a Node is provided, it will be wrapped in a Scene and then in a View.</p>"},{"location":"reference/scenex/util/#scenex.util.tree_dict","title":"tree_dict","text":"<pre><code>tree_dict(\n    node: SupportsChildren,\n    *,\n    obj_name: Callable[[Any], str] = _cls_name_with_id,\n) -&gt; Tree\n</code></pre> <p>Build an intermediate representation of the tree rooted at <code>node</code>.</p> <p>Leaves are represented as strings, and non-leaf nodes are represented as dictionaries with the node name as the key and a list of child nodes as the value. This is useful for debugging and visualization purposes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str | dict[str, list[dict | str]]</code>           \u2013            <p>A string, if the node is a leaf, or a dictionary representing the tree, if the node has children, like <code>{\"node_name\": [\"child1\", \"child2\", ...]}</code>.</p> </li> </ul> Source code in <code>src/scenex/util.py</code> <pre><code>def tree_dict(\n    node: SupportsChildren,\n    *,\n    obj_name: Callable[[Any], str] = _cls_name_with_id,\n) -&gt; Tree:\n    \"\"\"Build an intermediate representation of the tree rooted at `node`.\n\n    Leaves are represented as strings, and non-leaf nodes are represented as\n    dictionaries with the node name as the key and a list of child nodes as the value.\n    This is useful for debugging and visualization purposes.\n\n    Parameters\n    ----------\n    node : SupportsChildren\n        The root node of the tree to be represented.\n    obj_name : Callable[[Any], str], optional\n        A function to convert the node to a string. Defaults to a lambda function that\n        returns the class name and ID\n\n    Returns\n    -------\n    str | dict[str, list[dict | str]]\n        A string, if the node is a leaf, or a dictionary representing the tree,\n        if the node has children, like `{\"node_name\": [\"child1\", \"child2\", ...]}`.\n    \"\"\"\n    node_name = obj_name(node)\n    if not (children := _get_children(node)):\n        return node_name\n\n    result: list[dict | str] = []\n    for child in children:\n        result.append(tree_dict(child, obj_name=obj_name))\n    return {obj_name(node): result}\n</code></pre>"},{"location":"reference/scenex/util/#scenex.util.tree_dict(node)","title":"<code>node</code>","text":"(<code>SupportsChildren</code>)           \u2013            <p>The root node of the tree to be represented.</p>"},{"location":"reference/scenex/util/#scenex.util.tree_dict(obj_name)","title":"<code>obj_name</code>","text":"(<code>Callable[[Any], str]</code>, default:                   <code>_cls_name_with_id</code> )           \u2013            <p>A function to convert the node to a string. Defaults to a lambda function that returns the class name and ID</p>"},{"location":"reference/scenex/util/#scenex.util.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr(\n    node: SupportsChildren,\n    *,\n    node_repr: Callable[[Any], str] = __repr__,\n    _prefix: str = \"\",\n    _is_last: bool = True,\n) -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of <code>node</code> and its descendants.</p> <p>This assumes that <code>node</code> is a tree-like object with a <code>children</code> attribute that is either a property or a callable that returns an iterable of child nodes.</p> <p>Parameters:</p> Source code in <code>src/scenex/util.py</code> <pre><code>def tree_repr(\n    node: SupportsChildren,\n    *,\n    node_repr: Callable[[Any], str] = object.__repr__,\n    _prefix: str = \"\",\n    _is_last: bool = True,\n) -&gt; str:\n    \"\"\"\n    Return an ASCII/Unicode tree representation of `node` and its descendants.\n\n    This assumes that `node` is a tree-like object with a `children` attribute that is\n    either a property or a callable that returns an iterable of child nodes.\n\n    Parameters\n    ----------\n    node : SupportsChildren\n        Any object that has a `children` attribute or method that returns an iterable\n        of child nodes.\n    node_repr : Callable[[Any], str], optional\n        Function to convert the node to a string. Defaults to `object.__repr__` (which\n        avoids complex repr functions on objects, but use `repr` if you want to see\n        the full representation).\n    _prefix : str, optional\n        Prefix to use for each line of the tree. Defaults to an empty string.\n    _is_last : bool, optional\n        Whether this node is the last child of its parent. Defaults to `True`.\n        This is used to determine the branch character to use in the tree\n        representation.\n    \"\"\"\n    if _prefix:\n        branch = \"\u2514\u2500\u2500 \" if _is_last else \"\u251c\u2500\u2500 \"\n    else:\n        branch = \"\"\n\n    lines: list[str] = [f\"{_prefix}{branch}{node_repr(node)}\"]\n    if children := list(_get_children(node)):\n        prefix_child = _prefix + (\"    \" if _is_last else \"\u2502   \")\n        for idx, child in enumerate(children):\n            lines.append(\n                tree_repr(\n                    child,\n                    node_repr=node_repr,\n                    _prefix=prefix_child,\n                    _is_last=idx == len(children) - 1,\n                )\n            )\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/scenex/util/#scenex.util.tree_repr(node)","title":"<code>node</code>","text":"(<code>SupportsChildren</code>)           \u2013            <p>Any object that has a <code>children</code> attribute or method that returns an iterable of child nodes.</p>"},{"location":"reference/scenex/util/#scenex.util.tree_repr(node_repr)","title":"<code>node_repr</code>","text":"(<code>Callable[[Any], str]</code>, default:                   <code>__repr__</code> )           \u2013            <p>Function to convert the node to a string. Defaults to <code>object.__repr__</code> (which avoids complex repr functions on objects, but use <code>repr</code> if you want to see the full representation).</p>"},{"location":"reference/scenex/util/#scenex.util.tree_repr(_prefix)","title":"<code>_prefix</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Prefix to use for each line of the tree. Defaults to an empty string.</p>"},{"location":"reference/scenex/util/#scenex.util.tree_repr(_is_last)","title":"<code>_is_last</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether this node is the last child of its parent. Defaults to <code>True</code>. This is used to determine the branch character to use in the tree representation.</p>"}]}