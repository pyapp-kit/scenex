{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"scenex","text":"<p>In development</p> <p>This library is a work in progress. The API will change frequently as we add new features and improve existing ones.</p> <p>Scenex is a Python API for creating and manipulating 3D scenes.</p> <p>It does not implement any rendering or graphics directly, but rather serves as a high-level interface and adaptor for existing scene-graph libraries, such as vispy and pygfx, and hopefully others (like datovis) in the future.</p> <p>The goal is to provide a clear scene graph model (backed by pydantic ), with backend adaptors that connect the model to the actual rendering engine.  The models emit events upon mutation (using psygnal), and the adaptors listen to these events and update the scene graph.</p> <p>Because the models are backed by pydantic, they can be easily serialized to JSON and other formats, making it easy to save and load scenes, and define them declaratively.</p>"},{"location":"reference/scenex/","title":"scenex","text":""},{"location":"reference/scenex/#scenex","title":"scenex","text":"<p>Declarative scene graph library for scientific visualization.</p> <p>scenex is a Python library for creating interactive 3D visualizations using a declarative scene graph model. It provides a backend-agnostic API that works with multiple rendering engines (pygfx, vispy) while maintaining a consistent, intuitive interface.</p> Key Features <ul> <li>Declarative API: Describe how the scene should look rather than how to render it.</li> <li>Evented models: Events enable painless reaction to changes in the scene graph</li> <li>Multiple backends: Render with pygfx (WebGPU) or vispy (OpenGL)</li> </ul> Quick Start <p>Create and display a simple visualization::</p> <pre><code>import numpy as np\nimport scenex as snx\n\n# Create a random image\ndata = np.random.rand(100, 100)\nimg = snx.Image(data=data)\n\n# Show it\nsnx.show(img)\nsnx.run()\n</code></pre> See Also <ul> <li>scenex.model: Core declarative model classes</li> <li>scenex.adaptors: Backend adaptor implementations</li> <li>scenex.app: Application and event handling</li> </ul> <p>Modules:</p> <ul> <li> <code>adaptors</code>           \u2013            <p>Backend adaptors that translate scenex models into graphics library calls.</p> </li> <li> <code>app</code>           \u2013            <p>Application and GUI framework abstraction layer.</p> </li> <li> <code>conftest</code>           \u2013            <p>Pytest setup for doctests.</p> </li> <li> <code>imgui</code>           \u2013            <p>ImGui controls for interactive scenex visualization.</p> </li> <li> <code>model</code>           \u2013            <p>Declarative model classes for building scene graphs.</p> </li> <li> <code>util</code>           \u2013            <p>Utility functions for displaying and debugging scenex visualizations.</p> </li> <li> <code>utils</code>           \u2013            <p>Utilities for working with scenex structures.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>Camera</code>           \u2013            <p>A camera that defines the viewing perspective and projection for a scene.</p> </li> <li> <code>CameraController</code>           \u2013            <p>Base class defining how a camera responds to user interaction events.</p> </li> <li> <code>Canvas</code>           \u2013            <p>A rendering surface that displays one or more views.</p> </li> <li> <code>ColorModel</code>           \u2013            <p>Base class for color models used in scene nodes.</p> </li> <li> <code>FaceColors</code>           \u2013            <p>Per-face coloring strategy for mesh-like nodes.</p> </li> <li> <code>Image</code>           \u2013            <p>A 2D image rendered as a textured rectangle.</p> </li> <li> <code>Letterbox</code>           \u2013            <p>Maintain content aspect ratio on resize via letterboxing/pillarboxing.</p> </li> <li> <code>Line</code>           \u2013            <p>A polyline defined by connected vertices.</p> </li> <li> <code>Mesh</code>           \u2013            <p>A 3D surface mesh composed of triangular faces.</p> </li> <li> <code>Node</code>           \u2013            <p>Base class for all nodes in the scene graph.</p> </li> <li> <code>Orbit</code>           \u2013            <p>3D orbit controller for rotating around a focal point.</p> </li> <li> <code>PanZoom</code>           \u2013            <p>2D pan and zoom controller for orthographic views.</p> </li> <li> <code>Points</code>           \u2013            <p>A collection of point markers rendered at specified coordinates.</p> </li> <li> <code>ResizePolicy</code>           \u2013            <p>Base class defining how a view adapts to changes in its layout dimensions.</p> </li> <li> <code>Scene</code>           \u2013            <p>The root container node for a scene graph.</p> </li> <li> <code>Text</code>           \u2013            <p>A text label positioned in 3D world space.</p> </li> <li> <code>Transform</code>           \u2013            <p>A 4x4 homogeneous transformation matrix for 3D affine transformations.</p> </li> <li> <code>UniformColor</code>           \u2013            <p>Uniform coloring strategy for scene nodes.</p> </li> <li> <code>VertexColors</code>           \u2013            <p>Per-vertex coloring strategy for mesh, line, or points nodes.</p> </li> <li> <code>View</code>           \u2013            <p>A rectangular viewport that displays a scene through a camera.</p> </li> <li> <code>Volume</code>           \u2013            <p>A 3D volumetric dataset rendered with volume rendering techniques.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>run</code>             \u2013              <p>Start the GUI event loop to display interactive visualizations.</p> </li> <li> <code>show</code>             \u2013              <p>Display a visualization by creating a canvas and making it visible.</p> </li> <li> <code>use</code>             \u2013              <p>Set the graphics backend for rendering scenex visualizations.</p> </li> </ul>"},{"location":"reference/scenex/#scenex.Camera","title":"Camera","text":"<pre><code>Camera(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <pre><code>\n              flowchart TD\n              scenex.Camera[Camera]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.node.Node --&gt; scenex.Camera\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n              click scenex.Camera href \"\" \"scenex.Camera\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A camera that defines the viewing perspective and projection for a scene.</p> <p>The Camera is a node in the scene graph that determines how 3D world space is projected onto a 2D canvas. It combines a view transformation (positioning the camera in the scene) with a projection transformation (defining the viewing volume and perspective).</p> <p>Cameras use two transforms: - <code>transform</code> (inherited from Node): Maps local 3D space to world 3D space,   positioning and orienting the camera in the scene. - <code>projection</code>: Maps normalized device coordinates [-1, 1] x [-1, 1] to rays in   local 3D space, defining the viewing volume and projection type.</p> <p>The camera uses a right-handed coordinate system following OpenGL conventions: the positive x-axis points right, the positive y-axis points up, and the positive z-axis points out of the screen toward the viewer.</p> <p>Examples:</p> <p>Create a camera with pan-zoom controller:     &gt;&gt;&gt; camera = Camera(controller=PanZoom(), interactive=True)</p> <p>Create a camera with orbit controller:     &gt;&gt;&gt; camera = Camera(controller=Orbit(center=(0, 0, 0)), interactive=True)</p> <p>Position a camera and point it at a target:     &gt;&gt;&gt; camera = Camera()     &gt;&gt;&gt; camera.transform = Transform().translated((10, 0, 0))     &gt;&gt;&gt; camera.look_at((0, 0, 0), up=(0, 0, 1))</p> <p>Create a perspective camera:     &gt;&gt;&gt; from scenex.utils.projections import perspective     &gt;&gt;&gt; camera = Camera(projection=perspective(fov=70, near=0.1, far=100))</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>look_at</code>             \u2013              <p>Adjusts the camera to look at a target point in the world.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>passes_through</code>             \u2013              <p>Returns the depth t at which the provided ray intersects this node.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> <li> <code>forward</code>               (<code>Vector3D</code>)           \u2013            <p>The forward direction of the camera in world space, as a unit vector.</p> </li> <li> <code>up</code>               (<code>Vector3D</code>)           \u2013            <p>The up direction of the camera in world space, as a unit vector.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/#scenex.Camera.forward","title":"forward  <code>property</code> <code>writable</code>","text":"<pre><code>forward: Vector3D\n</code></pre> <p>The forward direction of the camera in world space, as a unit vector.</p>"},{"location":"reference/scenex/#scenex.Camera.up","title":"up  <code>property</code> <code>writable</code>","text":"<pre><code>up: Vector3D\n</code></pre> <p>The up direction of the camera in world space, as a unit vector.</p>"},{"location":"reference/scenex/#scenex.Camera.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.look_at","title":"look_at","text":"<pre><code>look_at(\n    target: Position3D, /, *, up: Vector3D | None = None\n) -&gt; None\n</code></pre> <p>Adjusts the camera to look at a target point in the world.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_nodes/camera.py</code> <pre><code>def look_at(self, target: Position3D, /, *, up: Vector3D | None = None) -&gt; None:\n    \"\"\"Adjusts the camera to look at a target point in the world.\n\n    Parameters\n    ----------\n    target: Position3D\n        The position in 3D space that the camera should look at.\n    up: Vector3D, optional\n        The up direction for the camera. If provided, this vector must be\n        perpendicular to the forward vector that results from looking at target.\n    \"\"\"\n    position = self.transform.map((0, 0, 0))[:3]\n    self.forward = tuple(target - position)\n    if up is not None:\n        if np.linalg.norm(up) == 0:\n            raise ValueError(\"Up vector must be non-zero.\")\n        if np.abs(np.dot(self.forward, up)) &gt; 1e-6:\n            raise ValueError(\"Up vector must be perpendicular to forward vector.\")\n        self.up = up\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.look_at(target)","title":"<code>target</code>","text":"(<code>Position3D</code>)           \u2013            <p>The position in 3D space that the camera should look at.</p>"},{"location":"reference/scenex/#scenex.Camera.look_at(up)","title":"<code>up</code>","text":"(<code>Vector3D | None</code>, default:                   <code>None</code> )           \u2013            <p>The up direction for the camera. If provided, this vector must be perpendicular to the forward vector that results from looking at target.</p>"},{"location":"reference/scenex/#scenex.Camera.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.passes_through","title":"passes_through","text":"<pre><code>passes_through(ray: Ray) -&gt; float | None\n</code></pre> <p>Returns the depth t at which the provided ray intersects this node.</p> <p>The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t, where t&gt;=0</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>t</code> (              <code>float | None</code> )          \u2013            <p>The depth t at which the ray intersects the node, or None if it never intersects.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def passes_through(self, ray: Ray) -&gt; float | None:\n    \"\"\"Returns the depth t at which the provided ray intersects this node.\n\n    The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t,\n    where t&gt;=0\n\n    Parameters\n    ----------\n    ray : Ray\n        The ray passing through the scene\n\n    Returns\n    -------\n    t: float | None\n        The depth t at which the ray intersects the node, or None if it never\n        intersects.\n    \"\"\"\n    # Nodes that want to support ray intersection should override this method.\n    return None\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.passes_through(ray)","title":"<code>ray</code>","text":"(<code>Ray</code>)           \u2013            <p>The ray passing through the scene</p>"},{"location":"reference/scenex/#scenex.Camera.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Camera.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Camera.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Camera.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/#scenex.CameraController","title":"CameraController","text":"<p>               Bases: <code>EventedBase</code></p> <pre><code>\n              flowchart TD\n              scenex.CameraController[CameraController]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._base.EventedBase --&gt; scenex.CameraController\n                \n\n\n              click scenex.CameraController href \"\" \"scenex.CameraController\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>Base class defining how a camera responds to user interaction events.</p> <p>A CameraController handles user input (mouse, keyboard, wheel) to manipulate camera transforms and projections, enabling interactive behaviors like panning, zooming, orbiting, or custom camera controls. Controllers are attached to Camera instances via the <code>controller</code> field and automatically receive events when the camera is marked as <code>interactive=True</code>.</p> <p>Event handlers should return True if they fully handled the event (stopping further propagation) or False if other handlers should continue processing the event.</p> <p>Examples:</p> <p>Create a camera with pan/zoom controller:     &gt;&gt;&gt; camera = Camera(controller=PanZoom(), interactive=True)</p> <p>Create a camera with orbit controller:     &gt;&gt;&gt; camera = Camera(controller=Orbit(center=(0, 0, 0)), interactive=True)</p> See Also <p>PanZoom : 2D pan and zoom controller Orbit : 3D orbit controller Camera : Camera class that uses controllers</p> <p>Methods:</p> <ul> <li> <code>handle_event</code>             \u2013              <p>Handle a user interaction event to control the camera.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> </ul>"},{"location":"reference/scenex/#scenex.CameraController.handle_event","title":"handle_event  <code>abstractmethod</code>","text":"<pre><code>handle_event(event: Event, camera: Camera) -&gt; bool\n</code></pre> <p>Handle a user interaction event to control the camera.</p> <p>This method is called automatically on all events on the camera's view that were not handled by previous handlers during scenex event processing.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the event was fully handled and should not propagate to other handlers, False if not handled or other handlers should process it.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/camera.py</code> <pre><code>@abstractmethod\ndef handle_event(self, event: Event, camera: Camera) -&gt; bool:\n    \"\"\"\n    Handle a user interaction event to control the camera.\n\n    This method is called automatically on all events on the camera's view that were\n    not handled by previous handlers during scenex event processing.\n\n    Parameters\n    ----------\n    event : Event\n        The input event to handle (MouseMoveEvent, MousePressEvent, WheelEvent,\n        KeyPressEvent, etc.)\n    camera : Camera\n        The camera node to manipulate.\n\n    Returns\n    -------\n    bool\n        True if the event was fully handled and should not propagate to other\n        handlers, False if not handled or other handlers should process it.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/scenex/#scenex.CameraController.handle_event(event)","title":"<code>event</code>","text":"(<code>Event</code>)           \u2013            <p>The input event to handle (MouseMoveEvent, MousePressEvent, WheelEvent, KeyPressEvent, etc.)</p>"},{"location":"reference/scenex/#scenex.CameraController.handle_event(camera)","title":"<code>camera</code>","text":"(<code>Camera</code>)           \u2013            <p>The camera node to manipulate.</p>"},{"location":"reference/scenex/#scenex.CameraController.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Canvas","title":"Canvas","text":"<pre><code>Canvas(\n    *,\n    views: Iterable[View] = (),\n    **data: Unpack[CanvasKwargs],\n)\n</code></pre> <p>               Bases: <code>EventedBase</code></p> <pre><code>\n              flowchart TD\n              scenex.Canvas[Canvas]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._base.EventedBase --&gt; scenex.Canvas\n                \n\n\n              click scenex.Canvas href \"\" \"scenex.Canvas\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A rendering surface that displays one or more views.</p> <p>The Canvas represents the top-level rendering context where views are displayed. In desktop applications, a canvas corresponds to a window. In web applications, it corresponds to a DOM element. Multiple views can be laid out horizontally on a single canvas; more complex layouts are planned in the near future.</p> <p>Examples:</p> <p>Create a simple canvas with default settings:     &gt;&gt;&gt; canvas = Canvas()</p> <p>Create a canvas with custom size and title:     &gt;&gt;&gt; canvas = Canvas(width=800, height=600, title=\"My Visualization\")</p> <p>Create a canvas with multiple views side-by-side:     &gt;&gt;&gt; canvas = Canvas(width=800, height=400, views=[View(), View()])</p> <p>Methods:</p> <ul> <li> <code>close</code>             \u2013              <p>Close the canvas and release resources.</p> </li> <li> <code>handle</code>             \u2013              <p>Handle the passed event.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Post-initialization hook for the model.</p> </li> <li> <code>render</code>             \u2013              <p>Show the canvas.</p> </li> <li> <code>to_ndc</code>             \u2013              <p>Map XY canvas position (pixels) to normalized device coordinates (NDC).</p> </li> <li> <code>to_world</code>             \u2013              <p>Map XY canvas position (pixels) to a Ray traveling through world space.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>size</code>               (<code>tuple[int, int]</code>)           \u2013            <p>Return the size of the canvas.</p> </li> </ul> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def __init__(\n    self,\n    *,\n    views: Iterable[View] = (),\n    **data: Unpack[CanvasKwargs],\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/scenex/#scenex.Canvas.size","title":"size  <code>property</code> <code>writable</code>","text":"<pre><code>size: tuple[int, int]\n</code></pre> <p>Return the size of the canvas.</p>"},{"location":"reference/scenex/#scenex.Canvas.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the canvas and release resources.</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the canvas and release resources.\"\"\"\n    for adaptor in self._get_adaptors():\n        cast(\"CanvasAdaptor\", adaptor)._snx_close()\n</code></pre>"},{"location":"reference/scenex/#scenex.Canvas.handle","title":"handle","text":"<pre><code>handle(event: Event) -&gt; bool\n</code></pre> <p>Handle the passed event.</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def handle(self, event: Event) -&gt; bool:\n    \"\"\"Handle the passed event.\"\"\"\n    handled = False\n    if isinstance(event, MouseEvent):\n        current_view = self._containing_view(event.canvas_pos)\n\n        # Check if we've moved between views and handle transitions\n        # BEGIN UNTESTED CODE!\n        # TODO: Add a test for this once multiple views are better supported\n        if self._last_mouse_view != current_view:\n            # Send leave event to the previous view\n            if self._last_mouse_view is not None:\n                leave_event = MouseLeaveEvent()\n                self._last_mouse_view.filter_event(leave_event)\n\n                # Send enter event to the new view (if any)\n                if current_view is not None:\n                    enter_event = MouseEnterEvent(\n                        canvas_pos=event.canvas_pos,\n                        world_ray=event.world_ray,\n                        buttons=event.buttons,\n                    )\n                    current_view.filter_event(enter_event)\n\n        self._last_mouse_view = current_view\n        # END UNTESTED CODE!\n\n        # Handle the original mouse event in the current view\n        if current_view is not None:\n            # Give the view a chance to observe the result\n            if current_view.filter_event(event):\n                return True\n\n            # No nodes in the view handled the event - pass it to the camera\n            if current_view.camera.interactive:\n                if on_mouse := current_view.camera.controller:\n                    handled |= on_mouse.handle_event(event, current_view.camera)\n    elif isinstance(event, MouseLeaveEvent):\n        # Mouse left the entire canvas\n        if self._last_mouse_view is not None:\n            handled = self._last_mouse_view.filter_event(event)\n            self._last_mouse_view = None\n    elif isinstance(event, ResizeEvent):\n        # TODO: How might some event filter tap into the resize?\n        self.size = (event.width, event.height)\n    return handled\n</code></pre>"},{"location":"reference/scenex/#scenex.Canvas.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Post-initialization hook for the model.</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Post-initialization hook for the model.\"\"\"\n    # Update all current views\n    for view in self.views:\n        view._canvas = self\n\n    self.events.width.connect(self._compute_layout)\n    self.events.height.connect(self._compute_layout)\n\n    self._compute_layout()\n</code></pre>"},{"location":"reference/scenex/#scenex.Canvas.render","title":"render","text":"<pre><code>render() -&gt; ndarray\n</code></pre> <p>Show the canvas.</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def render(self) -&gt; np.ndarray:\n    \"\"\"Show the canvas.\"\"\"\n    if adaptors := self._get_adaptors():\n        return cast(\"CanvasAdaptor\", adaptors[0])._snx_render()\n    raise RuntimeError(\"No adaptor found for Canvas.\")\n</code></pre>"},{"location":"reference/scenex/#scenex.Canvas.to_ndc","title":"to_ndc","text":"<pre><code>to_ndc(\n    canvas_pos: tuple[float, float],\n) -&gt; tuple[float, float] | None\n</code></pre> <p>Map XY canvas position (pixels) to normalized device coordinates (NDC).</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def to_ndc(self, canvas_pos: tuple[float, float]) -&gt; tuple[float, float] | None:\n    \"\"\"Map XY canvas position (pixels) to normalized device coordinates (NDC).\"\"\"\n    view = self._containing_view(canvas_pos)\n    if view is None:\n        return None\n\n    # Get position relative to viewport\n    pos_rel = (\n        canvas_pos[0] - view.layout.x,\n        canvas_pos[1] - view.layout.y,\n    )\n\n    width, height = view.layout.size\n\n    # Convert position to Normalized Device Coordinates (NDC) - i.e., within [-1, 1]\n    x = pos_rel[0] / width * 2 - 1\n    y = -(pos_rel[1] / height * 2 - 1)\n    return (x, y)\n</code></pre>"},{"location":"reference/scenex/#scenex.Canvas.to_world","title":"to_world","text":"<pre><code>to_world(canvas_pos: tuple[float, float]) -&gt; Ray | None\n</code></pre> <p>Map XY canvas position (pixels) to a Ray traveling through world space.</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def to_world(self, canvas_pos: tuple[float, float]) -&gt; Ray | None:\n    \"\"\"Map XY canvas position (pixels) to a Ray traveling through world space.\"\"\"\n    # Code adapted from:\n    # https://github.com/pygfx/pygfx/pull/753/files#diff-173d643434d575e67f8c0a5bf2d7ea9791e6e03a4e7a64aa5fa2cf4172af05cdR395\n    view = self._containing_view(canvas_pos)\n    if view is None:\n        return None\n\n    # Convert position to Normalized Device Coordinates (NDC) - i.e., within [-1, 1]\n    pos_ndc = self.to_ndc(canvas_pos)\n\n    # Note that the camera matrix is the matrix multiplication of:\n    # * The projection matrix, which projects local space (the rectangular\n    #   bounds of the perspective camera) into NDC.\n    # * The view matrix, i.e. the transform positioning the camera in the world.\n    # The result is a matrix mapping world coordinates\n    camera_matrix = view.camera.projection @ view.camera.transform.inv().T\n    # Unproject the canvas NDC coordinates into world space.\n    pos_world = la.vec_unproject(pos_ndc, camera_matrix)\n\n    # To find the direction of the ray, we find a unprojected point farther away\n    # and subtract the closer point.\n    pos_world_farther = la.vec_unproject(pos_ndc, camera_matrix, depth=1)\n    direction = pos_world_farther - pos_world\n    direction = direction / np.linalg.norm(direction)\n\n    ray = Ray(\n        origin=tuple(pos_world),\n        direction=tuple(direction),\n        source=view,\n    )\n    return ray\n</code></pre>"},{"location":"reference/scenex/#scenex.ColorModel","title":"ColorModel","text":"<pre><code>ColorModel(**data: Any)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              scenex.ColorModel[ColorModel]\n\n              \n\n              click scenex.ColorModel href \"\" \"scenex.ColorModel\"\n            </code></pre> <p>Base class for color models used in scene nodes.</p> <p>This class should not be instantiated directly. Instead, use one of its subclasses: - UniformColor: for a single color applied to the entire geometry - FaceColors: for per-face coloring (one color per face) - VertexColors: for per-vertex coloring (one color per vertex)</p> <p>The <code>color</code> field is typed as <code>Any</code> to allow flexibility in subclasses.</p> Source code in <code>src/scenex/model/_color.py</code> <pre><code>def __init__(self, **data: Any) -&gt; None:\n    if type(self) is ColorModel:\n        raise TypeError(\"ColorModel cannot be instantiated directly\")\n    super().__init__(**data)\n</code></pre>"},{"location":"reference/scenex/#scenex.FaceColors","title":"FaceColors","text":"<pre><code>FaceColors(**data: Any)\n</code></pre> <p>               Bases: <code>ColorModel</code></p> <pre><code>\n              flowchart TD\n              scenex.FaceColors[FaceColors]\n              scenex.model._color.ColorModel[ColorModel]\n\n                              scenex.model._color.ColorModel --&gt; scenex.FaceColors\n                \n\n\n              click scenex.FaceColors href \"\" \"scenex.FaceColors\"\n              click scenex.model._color.ColorModel href \"\" \"scenex.model._color.ColorModel\"\n            </code></pre> <p>Per-face coloring strategy for mesh-like nodes.</p> <p>This model applies a different color to each face of a mesh. The <code>color</code> field is a sequence of <code>Color</code> instances, one for each face.</p> <p>Examples:</p> <p>Per-face coloring:     &gt;&gt;&gt; from cmap import Color     &gt;&gt;&gt; from scenex import FaceColors     &gt;&gt;&gt; model = FaceColors(color=[Color(\"red\"), Color(\"blue\"), Color(\"green\")])</p> Source code in <code>src/scenex/model/_color.py</code> <pre><code>def __init__(self, **data: Any) -&gt; None:\n    if type(self) is ColorModel:\n        raise TypeError(\"ColorModel cannot be instantiated directly\")\n    super().__init__(**data)\n</code></pre>"},{"location":"reference/scenex/#scenex.Image","title":"Image","text":"<pre><code>Image(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <pre><code>\n              flowchart TD\n              scenex.Image[Image]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.node.Node --&gt; scenex.Image\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n              click scenex.Image href \"\" \"scenex.Image\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A 2D image rendered as a textured rectangle.</p> <p>Image displays a 2D array of intensity values, mapping them to colors using a colormap. The image is rendered as a rectangle in 3D space, with pixels centered at integer coordinates starting from (0, 0). The image supports various rendering options including colormapping, intensity normalization, gamma correction, and interpolation.</p> <p>The image's geometry spans from (-0.5, -0.5) to (width-0.5, height-0.5), meaning that pixel centers are at integer coordinates. This convention aligns with standard image processing practices.</p> <p>Examples:</p> <p>Create a simple grayscale image:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; data = np.random.rand(100, 100)     &gt;&gt;&gt; img = Image(data=data)</p> <p>Create an image with custom colormap and intensity range:     &gt;&gt;&gt; img = Image(data=data, cmap=Colormap(\"viridis\"), clims=(0, 255))</p> <p>Create a transformed and semi-transparent image:     &gt;&gt;&gt; img = Image(     ...     data=data,     ...     transform=Transform().translated((10, 20)).scaled((2, 2)),     ...     opacity=0.7,     ... )</p> <p>Apply gamma correction to brighten dark images:     &gt;&gt;&gt; img = Image(data=data, gamma=0.5)</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/#scenex.Image.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/#scenex.Image.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Image.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/#scenex.Image.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Image.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/#scenex.Image.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Image.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Image.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Image.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Image.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/#scenex.Letterbox","title":"Letterbox","text":"<p>               Bases: <code>ResizePolicy</code></p> <pre><code>\n              flowchart TD\n              scenex.Letterbox[Letterbox]\n              scenex.model._view.ResizePolicy[ResizePolicy]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._view.ResizePolicy --&gt; scenex.Letterbox\n                                scenex.model._base.EventedBase --&gt; scenex.model._view.ResizePolicy\n                \n\n\n\n              click scenex.Letterbox href \"\" \"scenex.Letterbox\"\n              click scenex.model._view.ResizePolicy href \"\" \"scenex.model._view.ResizePolicy\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>Maintain content aspect ratio on resize via letterboxing/pillarboxing.</p> <p>The Letterbox strategy preserves the original aspect ratio of the camera's projection when the view is resized. When the view's aspect ratio differs from the content's aspect ratio, the projection is expanded in the narrower dimension to ensure all original content remains visible with black bars (letterboxing for wide views, pillarboxing for tall views).</p> <p>The strategy tracks resize sequences (e.g., dragging a window corner) by storing the camera's projection as a reference at the start of that sequence. At any point during the sequence, the projection matrix is expanded in either width or height to retain the rectangle of that reference projection. A new sequence is defined by a change in the projection matrix, either programmatically made or through user input, signalled by a camera projection matrix different from that set during the last resize operation.</p> <p>Examples:</p> <p>Create a view with letterbox resizing:     &gt;&gt;&gt; from scenex.utils.projections import orthographic     &gt;&gt;&gt; view = View(     ...     camera=Camera(projection=orthographic(100, 100, 100)),     ...     on_resize=Letterbox(),     ... )</p> <p>When view is resized to 200x100 pixels, the projection expands horizontally to maintain the 1:1 aspect ratio, showing more content on the sides rather than stretching the image.</p> Notes <p>This approach follows the conventions of vispy's PanZoomCamera and pygfx's PerspectiveCamera. The projection matrix scales are inversely proportional to the displayed region: smaller scale values show more content.</p> See Also <p>ResizePolicy : Base class for resize policies View : View class that uses resize strategies Camera : Camera class with projection property</p> <p>Methods:</p> <ul> <li> <code>handle_resize</code>             \u2013              <p>Handle view resize by adjusting projection to maintain aspect ratio.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> </ul>"},{"location":"reference/scenex/#scenex.Letterbox.handle_resize","title":"handle_resize","text":"<pre><code>handle_resize(view: View) -&gt; None\n</code></pre> <p>Handle view resize by adjusting projection to maintain aspect ratio.</p> Source code in <code>src/scenex/model/_view.py</code> <pre><code>def handle_resize(self, view: View) -&gt; None:\n    \"\"\"Handle view resize by adjusting projection to maintain aspect ratio.\"\"\"\n    # If the current projection differs from the last adjustment, or if there is no\n    # reference to begin with, this is a new resize sequence.\n    if view.camera.projection != self._last_adjustment or self._reference is None:\n        self._reference = view.camera.projection\n\n    view_width = int(view.layout.width)\n    view_height = int(view.layout.height)\n    if view_height == 0 or self._reference is None:\n        return\n\n    # Extract projection scales that define the content aspect ratio\n    ref_mat = self._reference.root\n    ref_x_scale = ref_mat[0, 0]\n    ref_y_scale = ref_mat[1, 1]\n    if ref_y_scale == 0:\n        return\n\n    # Compute aspect ratios\n    # NOTE: projection scales are inversely proportional to the displayed region,\n    # so content_aspect = y_scale / x_scale\n    view_aspect = view_width / view_height\n    content_aspect = abs(ref_y_scale / ref_x_scale)\n\n    # Expand the narrower dimension to match the view aspect\n    if content_aspect &lt; view_aspect:\n        # View is wider: expand horizontal frustum (reduce x scale)\n        adjusted_proj = self._reference.scaled(\n            (content_aspect / view_aspect, 1.0, 1.0)\n        )\n    else:\n        # View is taller: expand vertical frustum (reduce y scale)\n        adjusted_proj = self._reference.scaled(\n            (1.0, view_aspect / content_aspect, 1.0)\n        )\n\n    # Store the adjustment before applying it\n    view.camera.projection = self._last_adjustment = adjusted_proj\n</code></pre>"},{"location":"reference/scenex/#scenex.Letterbox.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Line","title":"Line","text":"<pre><code>Line(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <pre><code>\n              flowchart TD\n              scenex.Line[Line]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.node.Node --&gt; scenex.Line\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n              click scenex.Line href \"\" \"scenex.Line\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A polyline defined by connected vertices.</p> <p>Line renders a sequence of connected line segments by drawing from each vertex to the next. The line can be colored uniformly or with per-vertex colors that smoothly interpolate along the path. Lines support width control and anti-aliasing for smooth rendering.</p> <p>Vertices can be 2D or 3D coordinates. For 2D vertices, the z-coordinate is assumed to be 0, placing the line in the xy-plane.</p> <p>Examples:</p> <p>Create a simple line connecting several points:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; vertices = np.array([[0, 0], [10, 5], [20, 0]])     &gt;&gt;&gt; line = Line(     ...     vertices=vertices,     ...     color=UniformColor(color=Color(\"red\")),     ... )</p> <p>Create a line with per-vertex colors:     &gt;&gt;&gt; vertices = np.array([[0, 0], [10, 10], [20, 0]])     &gt;&gt;&gt; colors = [Color(\"red\"), Color(\"green\"), Color(\"blue\")]     &gt;&gt;&gt; line = Line(     ...     vertices=vertices,     ...     color=VertexColors(color=colors),     ...     width=2.0,     ... )</p> <p>Create a 3D line:     &gt;&gt;&gt; vertices = np.array([[0, 0, 0], [10, 5, 3], [20, 0, 6]])     &gt;&gt;&gt; line = Line(vertices=vertices, width=3.0)</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>passes_through</code>             \u2013              <p>Check if the ray passes through this line.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/#scenex.Line.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/#scenex.Line.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Line.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/#scenex.Line.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Line.passes_through","title":"passes_through","text":"<pre><code>passes_through(ray: Ray) -&gt; float | None\n</code></pre> <p>Check if the ray passes through this line.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float | None</code>           \u2013            <p>The distance to the closest intersection, or None if no intersection.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/line.py</code> <pre><code>def passes_through(self, ray: Ray) -&gt; float | None:\n    \"\"\"\n    Check if the ray passes through this line.\n\n    Parameters\n    ----------\n    ray : Ray\n        The ray to test for intersection.\n\n    Returns\n    -------\n    float | None\n        The distance to the closest intersection, or None if no intersection.\n    \"\"\"\n    verts = np.asarray(self.vertices)\n    # Convert vertices to canvas space\n    canvas_vertices = self._node_to_canvas(ray.source)\n    # Convert ray to canvas space\n    canvas_ray = Line._world_to_canvas(ray, np.array([ray.origin]))[0]\n\n    starts = canvas_vertices[:-1]\n    ends = canvas_vertices[1:]\n\n    # Compute the distance from the ray ON THE CANVAS to the closest point the line\n    # associated with each line segment.\n    #\n    # Equation loaned from https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points\n    num = np.abs(\n        (ends[:, 1] - starts[:, 1]) * canvas_ray[0]\n        - (ends[:, 0] - starts[:, 0]) * canvas_ray[1]\n        + ends[:, 0] * starts[:, 1]\n        - ends[:, 1] * starts[:, 0]\n    )\n    den = np.sqrt(\n        (ends[:, 1] - starts[:, 1]) ** 2 + (ends[:, 0] - starts[:, 0]) ** 2\n    )\n    den[den == 0] = float(\"inf\")  # Avoid division by zero\n    distance = num / den\n\n    # Determine the corresponding point in world space corresponding to that closest\n    # point. Note that this point is only on the line segment if 0 &lt;= t &lt;= 1.\n    # (We check this at the end.)\n    a = np.subtract(canvas_ray, starts)\n    b = np.subtract(ends, starts)\n    # Vectorized version of dot product\n    t = np.sum(a * b, axis=1) / np.sum(b * b, axis=1)\n    intersect_world = verts[1:] + t[:, np.newaxis] * (verts[:-1] - verts[1:])\n\n    # Calculate the distance along the ray to the intersection point\n    # The ray is defined as: ray.origin + d * ray.direction\n    # We need to find d such that ray.origin + d * ray.direction = intersect_world\n    # This gives us: d * ray.direction = intersect_world - ray.origin\n    # Solving for d: d = dot(intersect_world - ray.origin, ray.direction) /\n    #                     dot(ray.direction, ray.direction)\n    ray_to_intersect = np.subtract(intersect_world, ray.origin)\n    ray_dir_squared = np.dot(ray.direction, ray.direction)\n\n    if ray_dir_squared == 0:\n        return None  # Degenerate ray\n\n    d = np.dot(ray_to_intersect, ray.direction) / ray_dir_squared\n\n    # Our ray intersects the line if:\n    # 1. The distance from the ray to the line is less than the line width\n    # 2. The intersection point is within the line segment (0 &lt;= t &lt;= 1)\n    # 3. The intersection point is in front of the ray origin (d &gt;= 0)\n    condition = (distance &lt;= self.width) &amp; (t &gt;= 0) &amp; (t &lt;= 1) &amp; (d &gt;= 0)\n    valid_intersections = d[condition]\n    if len(valid_intersections):\n        return float(np.min(valid_intersections))\n    else:\n        return None\n</code></pre>"},{"location":"reference/scenex/#scenex.Line.passes_through(ray)","title":"<code>ray</code>","text":"(<code>Ray</code>)           \u2013            <p>The ray to test for intersection.</p>"},{"location":"reference/scenex/#scenex.Line.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/#scenex.Line.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Line.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Line.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Line.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Line.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/#scenex.Mesh","title":"Mesh","text":"<pre><code>Mesh(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <pre><code>\n              flowchart TD\n              scenex.Mesh[Mesh]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.node.Node --&gt; scenex.Mesh\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n              click scenex.Mesh href \"\" \"scenex.Mesh\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A 3D surface mesh composed of triangular faces.</p> <p>Mesh represents a 3D surface defined by vertices and triangular faces. Each face is specified by three indices into the vertex array, forming a triangle. The mesh uses counter-clockwise winding order: for a face (v1, v2, v3), the normal vector points in the direction of (v2 - v1) x (v3 - v1).</p> <p>Meshes support ray-triangle intersection testing using the M\u00f6ller-Trumbore algorithm, enabling efficient picking and interaction.</p> <p>Examples:</p> <p>Create a simple triangle mesh:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; vertices = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0]])     &gt;&gt;&gt; faces = np.array([[0, 1, 2]])     &gt;&gt;&gt; mesh = Mesh(     ...     vertices=vertices,     ...     faces=faces,     ...     color=UniformColor(color=Color(\"blue\")),     ... )</p> <p>Create a square made of two triangles:     &gt;&gt;&gt; vertices = np.array(     ...     [     ...         [0, 0, 0],  # bottom-left     ...         [1, 0, 0],  # bottom-right     ...         [1, 1, 0],  # top-right     ...         [0, 1, 0],  # top-left     ...     ]     ... )     &gt;&gt;&gt; faces = np.array(     ...     [     ...         [0, 1, 2],  # first triangle     ...         [0, 2, 3],  # second triangle     ...     ]     ... )     &gt;&gt;&gt; mesh = Mesh(vertices=vertices, faces=faces)</p> Notes <p>Face winding order (counter-clockwise) determines which side of the triangle is considered the \"front\" face. The normal vector for face (v1, v2, v3) points in the direction of (v2 - v1) x (v3 - v1).</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>intersecting_faces</code>             \u2013              <p>Find all faces that intersect with the given ray.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>passes_through</code>             \u2013              <p>Check if the ray passes through this mesh and return the closest distance.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/#scenex.Mesh.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/#scenex.Mesh.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Mesh.intersecting_faces","title":"intersecting_faces","text":"<pre><code>intersecting_faces(ray: Ray) -&gt; list[tuple[int, float]]\n</code></pre> <p>Find all faces that intersect with the given ray.</p> <p>Uses the M\u00f6ller-Trumbore intersection algorithm, vectorized over all triangles. Adapted from https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm#C++_implementation</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[tuple[int, float]]</code>           \u2013            <p>A list of tuples containing (face_index, distance) for each intersecting face. Sorted by distance (closest first).</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/mesh.py</code> <pre><code>def intersecting_faces(self, ray: Ray) -&gt; list[tuple[int, float]]:\n    \"\"\"\n    Find all faces that intersect with the given ray.\n\n    Uses the M\u00f6ller-Trumbore intersection algorithm, vectorized over all triangles.\n    Adapted from https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm#C++_implementation\n\n    Parameters\n    ----------\n    ray : Ray\n        The ray to test for intersections.\n\n    Returns\n    -------\n    list[tuple[int, float]]\n        A list of tuples containing (face_index, distance) for each\n        intersecting face. Sorted by distance (closest first).\n    \"\"\"\n    tracked_faces = np.arange(len(self.faces))\n\n    # Suppose the triangle is defined by vertices v1, v2, v3\n    # Barycentric coordinates are given by\n    # P = (1 - u - v)*v1 + u*v2 + v*v3,\n    #   = v1 + u(v2 - v1) + v(v3 - v1)\n    #   = v1 + u*e1 + v*e2\n    # But the intersection point is also given by our ray equation:\n    # P = ray.origin + t*ray.direction\n    # So we need to solve the equation\n    # ray.origin + t*ray.direction = v1 + u*e1 + v*e2\n    # Rearranging:\n    # ray.origin - v1 = -t*ray.direction + u*e1 + v*e2\n    e1 = self.vertices[self.faces[:, 1]] - self.vertices[self.faces[:, 0]]\n    e2 = self.vertices[self.faces[:, 2]] - self.vertices[self.faces[:, 0]]\n\n    # First, cull all triangles parallel to the ray\n    # We compute the determinant (scalar triple product) for this\n    ray_cross_e2 = np.cross(ray.direction, e2)\n    # NOTE: Vectorized version of row-wise dot product of ray_cross_e2 and e1\n    det = np.sum(ray_cross_e2 * e1, axis=1)\n    parallel_triangles = np.isclose(det, 0)\n\n    # Remove parallel triangles from consideration\n    e1 = e1[~parallel_triangles]\n    e2 = e2[~parallel_triangles]\n    ray_cross_e2 = ray_cross_e2[~parallel_triangles]\n    det = det[~parallel_triangles]\n    v1 = self.vertices[self.faces[:, 0]][~parallel_triangles]\n    tracked_faces = tracked_faces[~parallel_triangles]\n\n    # We can use Cramer's Rule to solve for t, u, v\n    # (We solve for u, v first to check if the intersection is within the triangle)\n    #\n    # u = (1/det) * scalar_triple_product(ray.direction, s, e2)\n    inv_det = 1 / det\n    s = ray.origin - v1\n    u = inv_det * np.sum(s * ray_cross_e2, axis=1)\n    # v = (1/det) * scalar_triple_product(ray.direction, e1, s)\n    s_cross_e1 = np.cross(s, e1)\n    v = inv_det * np.sum(ray.direction * s_cross_e1, axis=1)\n\n    # Cull triangles where the intersection is outside the triangle\n    intersecting = (u &gt;= 0) &amp; (v &gt;= 0) &amp; (u + v &lt; 1)\n\n    if not np.any(intersecting):\n        return []\n\n    # Get the indices and data for intersecting triangles\n    tracked_faces = tracked_faces[intersecting]\n    inv_det = inv_det[intersecting]\n    e2 = e2[intersecting]\n    s_cross_e1 = s_cross_e1[intersecting]\n\n    # t = (1/det) * scalar_triple_product(s, e1, e2)\n    t = inv_det * np.sum(e2 * s_cross_e1, axis=1)\n\n    # Create list of (face_index, distance) tuples and sort by distance\n    intersections = list(zip(tracked_faces, t, strict=True))\n    intersections.sort(key=lambda x: x[1])  # Sort by distance\n\n    return intersections\n</code></pre>"},{"location":"reference/scenex/#scenex.Mesh.intersecting_faces(ray)","title":"<code>ray</code>","text":"(<code>Ray</code>)           \u2013            <p>The ray to test for intersections.</p>"},{"location":"reference/scenex/#scenex.Mesh.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/#scenex.Mesh.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Mesh.passes_through","title":"passes_through","text":"<pre><code>passes_through(ray: Ray) -&gt; float | None\n</code></pre> <p>Check if the ray passes through this mesh and return the closest distance.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float | None</code>           \u2013            <p>The distance to the closest intersection, or None if no intersection.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/mesh.py</code> <pre><code>def passes_through(self, ray: Ray) -&gt; float | None:\n    \"\"\"\n    Check if the ray passes through this mesh and return the closest distance.\n\n    Parameters\n    ----------\n    ray : Ray\n        The ray to test for intersection.\n\n    Returns\n    -------\n    float | None\n        The distance to the closest intersection, or None if no intersection.\n    \"\"\"\n    intersections = self.intersecting_faces(ray)\n    if not intersections:\n        return None\n\n    # Return the closest intersection distance\n    return float(intersections[0][1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Mesh.passes_through(ray)","title":"<code>ray</code>","text":"(<code>Ray</code>)           \u2013            <p>The ray to test for intersection.</p>"},{"location":"reference/scenex/#scenex.Mesh.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/#scenex.Mesh.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Mesh.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Mesh.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Mesh.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Mesh.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/#scenex.Node","title":"Node","text":"<pre><code>Node(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>EventedBase</code></p> <pre><code>\n              flowchart TD\n              scenex.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._base.EventedBase --&gt; scenex.Node\n                \n\n\n              click scenex.Node href \"\" \"scenex.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>Base class for all nodes in the scene graph.</p> <p>Node is the fundamental building block of scenex's scene graph architecture. Nodes form a hierarchical tree structure where each node can have a parent and children, creating a parent-child relationship that propagates transformations, visibility, and other properties through the graph.</p> <p>Nodes are abstract and should not be instantiated directly. Use concrete subclasses like Image, Points, Line, Mesh, Scene, or Camera instead.</p> <p>The scene graph hierarchy allows: - Hierarchical transformations: A node's transform is relative to its parent - Property inheritance: Visibility and opacity affect all descendants - Spatial relationships: Nodes can find paths to other nodes in the graph - Event handling: Interactive nodes can respond to user input</p> Notes <p>Do not instantiate Node directly. Use concrete subclasses instead.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>passes_through</code>             \u2013              <p>Returns the depth t at which the provided ray intersects this node.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/#scenex.Node.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/#scenex.Node.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Node.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/#scenex.Node.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Node.passes_through","title":"passes_through","text":"<pre><code>passes_through(ray: Ray) -&gt; float | None\n</code></pre> <p>Returns the depth t at which the provided ray intersects this node.</p> <p>The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t, where t&gt;=0</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>t</code> (              <code>float | None</code> )          \u2013            <p>The depth t at which the ray intersects the node, or None if it never intersects.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def passes_through(self, ray: Ray) -&gt; float | None:\n    \"\"\"Returns the depth t at which the provided ray intersects this node.\n\n    The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t,\n    where t&gt;=0\n\n    Parameters\n    ----------\n    ray : Ray\n        The ray passing through the scene\n\n    Returns\n    -------\n    t: float | None\n        The depth t at which the ray intersects the node, or None if it never\n        intersects.\n    \"\"\"\n    # Nodes that want to support ray intersection should override this method.\n    return None\n</code></pre>"},{"location":"reference/scenex/#scenex.Node.passes_through(ray)","title":"<code>ray</code>","text":"(<code>Ray</code>)           \u2013            <p>The ray passing through the scene</p>"},{"location":"reference/scenex/#scenex.Node.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/#scenex.Node.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Node.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Node.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Node.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Node.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/#scenex.Orbit","title":"Orbit","text":"<p>               Bases: <code>CameraController</code></p> <pre><code>\n              flowchart TD\n              scenex.Orbit[Orbit]\n              scenex.model._nodes.camera.CameraController[CameraController]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.camera.CameraController --&gt; scenex.Orbit\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.camera.CameraController\n                \n\n\n\n              click scenex.Orbit href \"\" \"scenex.Orbit\"\n              click scenex.model._nodes.camera.CameraController href \"\" \"scenex.model._nodes.camera.CameraController\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>3D orbit controller for rotating around a focal point.</p> <p>Orbit provides intuitive 3D navigation for perspective views by allowing the camera to rotate around a fixed center point while maintaining its distance.</p> <p>The strategy uses spherical coordinates to control camera position: - Azimuth: Rotation around the polar axis (typically Z), controlling left/right   movement around the scene - Elevation: Angle from the polar axis, controlling up/down viewing angle - Distance: Radius from the center point, controlled by zooming</p> <p>During rotation, foreground objects (between the camera and the center) move in the direction of mouse movement, providing intuitive control where the visible scene appears to rotate under the mouse.</p> <p>The right mouse button allows panning the orbit center itself, enabling exploration of large scenes by moving the focal point while maintaining the camera's viewing angle and distance.</p> <p>Attributes:</p> <ul> <li> <code>center</code>               (<code>tuple[float, float, float]</code>)           \u2013            <p>The point in 3D space around which the camera orbits. This is the focal point that remains stationary during rotation. Default is (0, 0, 0).</p> </li> <li> <code>polar_axis</code>               (<code>tuple[float, float, float]</code>)           \u2013            <p>The axis defining the \"up\" direction for orbit calculations. Azimuth rotations occur around this axis. Default is (0, 0, 1) for Z-up orientation.</p> </li> </ul> <p>Examples:</p> <p>Orbit around the origin:     &gt;&gt;&gt; from scenex.utils import projections     &gt;&gt;&gt; # Create a perspective camera...     &gt;&gt;&gt; camera = Camera(     ...     interactive=True,     ...     projection=projections.perspective(fov=70, near=1, far=1000),     ... )     &gt;&gt;&gt; # ...positioned along the X axis...     &gt;&gt;&gt; camera.transform = Transform().translated((100, 0, 0))     &gt;&gt;&gt; # ...looking at the origin...     &gt;&gt;&gt; camera.look_at((0, 0, 0), up=(0, 0, 1))     &gt;&gt;&gt; # ...that orbits around the origin     &gt;&gt;&gt; camera.controller = Orbit(center=(0, 0, 0))</p> <p>Orbit around a data volume's center:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; my_data = np.random.rand(100, 100, 100).astype(np.float32)     &gt;&gt;&gt; volume = Volume(data=my_data)     &gt;&gt;&gt; center = np.mean(volume.bounding_box, axis=0)     &gt;&gt;&gt; # Create a perspective camera...     &gt;&gt;&gt; camera = Camera(     ...     interactive=True,     ...     projection=projections.perspective(fov=70, near=1, far=1000),     ... )     &gt;&gt;&gt; # ...positioned along the X axis from the volume center...     &gt;&gt;&gt; camera.transform = Transform().translated(center).translated((100, 0, 0))     &gt;&gt;&gt; # ...looking at the center...     &gt;&gt;&gt; camera.look_at(center, up=(0, 0, 1))     &gt;&gt;&gt; # ...that orbits around the center     &gt;&gt;&gt; camera.controller = Orbit(center=center)</p> <p>Custom polar axis for Y-up scenes:     &gt;&gt;&gt; camera = Camera(     ...     controller=Orbit(center=(0, 0, 0), polar_axis=(0, 1, 0)),     ...     interactive=True,     ... )</p> Interactions <ul> <li>Left mouse drag: Orbit/rotate the camera around the center point</li> <li>Right mouse drag: Pan the orbit center (translates the focal point)</li> <li>Mouse wheel: Zoom toward/away from center (change radius)</li> </ul> Notes <p>Elevation is automatically clamped to [0\u00b0, 180\u00b0] to prevent the camera from going upside down. Without this clamping, the camera could rotate past the polar axis, causing horizontal mouse movement to make the foreground rotate in the opposite direction to the actual mouse movement.</p> See Also <p>PanZoom : 2D pan and zoom controller for orthographic views CameraController : Base class for camera controllers Camera : Camera class with controller field Camera.look_at : Method to orient camera toward a point</p> <p>Methods:</p> <ul> <li> <code>handle_event</code>             \u2013              <p>Handle mouse and wheel events to orbit the camera.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> </ul>"},{"location":"reference/scenex/#scenex.Orbit.handle_event","title":"handle_event","text":"<pre><code>handle_event(event: Event, camera: Camera) -&gt; bool\n</code></pre> <p>Handle mouse and wheel events to orbit the camera.</p> Source code in <code>src/scenex/model/_nodes/camera.py</code> <pre><code>def handle_event(self, event: Event, camera: Camera) -&gt; bool:\n    \"\"\"Handle mouse and wheel events to orbit the camera.\"\"\"\n    if not camera.interactive:\n        return False\n\n    handled = False\n    center_array = np.asarray(self.center)\n\n    # Orbit on mouse move with left button held\n    if (\n        isinstance(event, MouseMoveEvent)\n        and event.buttons == MouseButton.LEFT\n        and self._last_canvas_pos is not None\n    ):\n        # The process of orbiting is as follows:\n        # 1. Compute the azimuth and elevation changes based on mouse movement.\n        #   - Azimuth describes the angle between the the positive X axis and\n        #       the projection of the camera's position onto the XY plane.\n        #   - Elevation describes the angle between the camera's position and\n        #       the positive Z axis.\n        # 2. Ensure these changes are clamped to valid ranges (only really\n        #   applies to elevation).\n        # 3. Adjust the current transform by:\n        #   a. Translating by the negative of the centerpoint, to take it out of\n        #       the computation.\n        #   b. Rotating to adjust the elevation. The axis of rotation is defined\n        #       by the camera's right vector. Note that this is done before the\n        #       azimuth adjustment because that adjustment will alter the\n        #       camera's right vector.\n        #   c. Rotating to adjust the azimuth. The axis of rotation is always\n        #       the positive Z axis.\n        #   d. Translating by the centerpoint, to reorient the camera around\n        #           that centerpoint.\n\n        # Step 0: Gather transform components, relative to camera center\n        orbit_mat = camera.transform.translated(-center_array)\n        position, _rotation, _scale = la.mat_decompose(orbit_mat.T)\n        camera_right = np.cross(camera.forward, camera.up)\n\n        # Step 1\n        d_azimuth = self._last_canvas_pos[0] - event.canvas_pos[0]\n        d_elevation = self._last_canvas_pos[1] - event.canvas_pos[1]\n\n        # Step 2\n        e_bound = float(la.vec_angle(position, (0, 0, 1)) * 180 / math.pi)\n        if e_bound + d_elevation &lt; 0:\n            d_elevation = -e_bound\n        if e_bound + d_elevation &gt; 180:\n            d_elevation = 180 - e_bound\n\n        # Step 3\n        camera.transform = (\n            camera.transform.translated(-center_array)  # 3a\n            .rotated(d_elevation, camera_right)  # 3b\n            .rotated(d_azimuth, self.polar_axis)  # 3c\n            .translated(center_array)  # 3d\n        )\n\n        handled = True\n\n    # Pan on mouse press with right button\n    elif isinstance(event, MousePressEvent) and event.buttons == MouseButton.RIGHT:\n        self._pan_ray = event.world_ray\n\n    # Pan on mouse move with right button held\n    elif (\n        isinstance(event, MouseMoveEvent)\n        and event.buttons == MouseButton.RIGHT\n        and self._pan_ray is not None\n    ):\n        dr = np.linalg.norm(camera.transform.map((0, 0, 0))[:3] - center_array)\n        old_center = self._pan_ray.origin[:3] + np.multiply(\n            dr, self._pan_ray.direction\n        )\n        new_center = event.world_ray.origin[:3] + np.multiply(\n            dr, event.world_ray.direction\n        )\n        diff = np.subtract(old_center, new_center)\n        camera.transform = camera.transform.translated(diff)\n        # Update the center\n        new_center_array = center_array + diff\n        new_center_tuple = (\n            float(new_center_array[0]),\n            float(new_center_array[1]),\n            float(new_center_array[2]),\n        )\n        self.center = new_center_tuple\n        handled = True\n\n    elif isinstance(event, WheelEvent):\n        _dx, dy = event.angle_delta\n        if dy:\n            dr = camera.transform.map((0, 0, 0))[:3] - center_array\n            zoom = self._zoom_factor(dy)\n            camera.transform = camera.transform.translated(dr * (zoom - 1))\n        handled = True\n\n    if isinstance(event, MouseEvent):\n        self._last_canvas_pos = event.canvas_pos\n    return handled\n</code></pre>"},{"location":"reference/scenex/#scenex.Orbit.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.PanZoom","title":"PanZoom","text":"<p>               Bases: <code>CameraController</code></p> <pre><code>\n              flowchart TD\n              scenex.PanZoom[PanZoom]\n              scenex.model._nodes.camera.CameraController[CameraController]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.camera.CameraController --&gt; scenex.PanZoom\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.camera.CameraController\n                \n\n\n\n              click scenex.PanZoom href \"\" \"scenex.PanZoom\"\n              click scenex.model._nodes.camera.CameraController href \"\" \"scenex.model._nodes.camera.CameraController\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>2D pan and zoom controller for orthographic views.</p> <p>PanZoom provides intuitive mouse-based navigation for 2D scenes and orthographic projections.</p> <p>The strategy operates in two complementary ways: - Panning (left mouse drag): Modifies camera.transform to translate the camera   position, maintaining the scene coordinates under the cursor. - Zooming (mouse wheel): Modifies camera.projection to scale the view, then   adjusts camera.transform to keep the zoom centered on the cursor position.</p> <p>Optional axis locking allows constraining interaction to horizontal or vertical movement only</p> <p>Attributes:</p> <ul> <li> <code>lock_x</code>               (<code>bool</code>)           \u2013            <p>If True, prevent horizontal panning and zooming. Movement is constrained to the vertical axis only. Default is False.</p> </li> <li> <code>lock_y</code>               (<code>bool</code>)           \u2013            <p>If True, prevent vertical panning and zooming. Movement is constrained to the horizontal axis only. Default is False.</p> </li> </ul> <p>Examples:</p> <p>Standard 2D pan and zoom:     &gt;&gt;&gt; camera = Camera(controller=PanZoom(), interactive=True)</p> <p>Lock horizontal movement for vertical scrolling only:     &gt;&gt;&gt; camera = Camera(controller=PanZoom(lock_x=True), interactive=True)</p> <p>Create an image viewer with pan/zoom:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; from scenex.utils import projections     &gt;&gt;&gt; my_data = np.random.rand(512, 512).astype(np.float32)     &gt;&gt;&gt; view = View(     ...     scene=Scene(children=[Image(data=my_data)]),     ...     camera=Camera(     ...         controller=PanZoom(),     ...         interactive=True,     ...     ),     ... )     &gt;&gt;&gt; projections.zoom_to_fit(view=view, type=\"orthographic\")</p> See Also <p>Orbit : 3D orbit controller for perspective views CameraController : Base class for camera controllers Camera : Camera class with controller field</p> <p>Methods:</p> <ul> <li> <code>handle_event</code>             \u2013              <p>Handle mouse and wheel events to pan/zoom the camera.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> </ul>"},{"location":"reference/scenex/#scenex.PanZoom.handle_event","title":"handle_event","text":"<pre><code>handle_event(event: Event, camera: Camera) -&gt; bool\n</code></pre> <p>Handle mouse and wheel events to pan/zoom the camera.</p> Source code in <code>src/scenex/model/_nodes/camera.py</code> <pre><code>def handle_event(self, event: Event, camera: Camera) -&gt; bool:\n    \"\"\"Handle mouse and wheel events to pan/zoom the camera.\"\"\"\n    from scenex.app.events import (\n        MouseButton,\n        MouseMoveEvent,\n        MousePressEvent,\n        WheelEvent,\n    )\n\n    if not camera.interactive:\n        return False\n\n    handled = False\n\n    # Panning involves keeping a particular position underneath the cursor.\n    # That position is recorded on a left mouse button press.\n    if isinstance(event, MousePressEvent) and MouseButton.LEFT in event.buttons:\n        self._drag_pos = event.world_ray.origin[:2]\n    # Every time the cursor is moved, until the left mouse button is released,\n    # We translate the camera such that the position is back under the cursor\n    # (i.e. under the world ray origin)\n    elif (\n        isinstance(event, MouseMoveEvent)\n        and MouseButton.LEFT in event.buttons\n        and self._drag_pos\n    ):\n        new_pos = event.world_ray.origin[:2]\n        dx = self._drag_pos[0] - new_pos[0]\n        if not self.lock_x:\n            camera.transform = camera.transform.translated((dx, 0))\n        dy = self._drag_pos[1] - new_pos[1]\n        if not self.lock_y:\n            camera.transform = camera.transform.translated((0, dy))\n        handled = True\n\n    # Note that while panning adjusts the camera's transform matrix, zooming\n    # adjusts the projection matrix.\n    elif isinstance(event, WheelEvent):\n        # Zoom while keeping the position under the cursor fixed.\n        _dx, dy = event.angle_delta\n        if dy:\n            # Step 1: Adjust the projection matrix to zoom in or out.\n            zoom = self._zoom_factor(dy)\n            camera.projection = camera.projection.scaled(\n                (1 if self.lock_x else zoom, 1 if self.lock_y else zoom, 1.0)\n            )\n\n            # Step 2: Adjust the transform matrix to maintain the position\n            # under the cursor. The math is largely borrowed from\n            # https://github.com/pygfx/pygfx/blob/520af2d5bb2038ec309ef645e4a60d502f00d181/pygfx/controllers/_panzoom.py#L164\n\n            # Find the distance between the world ray and the camera\n            zoom_center = np.asarray(event.world_ray.origin)[:2]\n            camera_center = np.asarray(camera.transform.map((0, 0)))[:2]\n            # Compute the world distance before the zoom\n            delta_screen1 = zoom_center - camera_center\n            # Compute the world distance after the zoom\n            delta_screen2 = delta_screen1 * zoom\n            # The pan is the difference between the two\n            pan = (delta_screen2 - delta_screen1) / zoom\n            camera.transform = camera.transform.translated(\n                (\n                    pan[0] if not self.lock_x else 0,\n                    pan[1] if not self.lock_y else 0,\n                )\n            )\n            handled = True\n\n    return handled\n</code></pre>"},{"location":"reference/scenex/#scenex.PanZoom.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Points","title":"Points","text":"<pre><code>Points(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <pre><code>\n              flowchart TD\n              scenex.Points[Points]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.node.Node --&gt; scenex.Points\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n              click scenex.Points href \"\" \"scenex.Points\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A collection of point markers rendered at specified coordinates.</p> <p>Points displays symbols (markers) at 2D or 3D coordinates in the scene. Each point is rendered using a specified symbol shape (disc, square, star, etc.) with customizable size, face color, and edge styling. Points support different scaling modes to control whether they maintain constant screen size or scale with the scene.</p> <p>Examples:</p> <p>Create simple point markers:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; vertices = np.random.rand(100, 2) * 100     &gt;&gt;&gt; points = Points(     ...     vertices=vertices,     ...     size=5,     ...     face_color=UniformColor(color=Color(\"red\")),     ... )</p> <p>Create points with custom symbols and styling:     &gt;&gt;&gt; points = Points(     ...     vertices=vertices,     ...     symbol=\"star\",     ...     size=20,     ...     face_color=UniformColor(color=Color(\"yellow\")),     ...     edge_color=UniformColor(color=Color(\"orange\")),     ...     edge_width=2,     ... )</p> <p>Create fixed-size points that don't scale with zoom:     &gt;&gt;&gt; points = Points(     ...     vertices=vertices,     ...     size=10,     ...     scaling=\"fixed\",     ...     face_color=UniformColor(color=Color(\"blue\")),     ... )</p> <p>Create 3D points:     &gt;&gt;&gt; vertices_3d = np.random.rand(50, 3) * 100     &gt;&gt;&gt; points = Points(vertices=vertices_3d, symbol=\"diamond\", size=15)</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/#scenex.Points.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/#scenex.Points.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Points.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/#scenex.Points.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Points.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/#scenex.Points.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Points.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Points.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Points.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Points.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/#scenex.ResizePolicy","title":"ResizePolicy","text":"<p>               Bases: <code>EventedBase</code></p> <pre><code>\n              flowchart TD\n              scenex.ResizePolicy[ResizePolicy]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._base.EventedBase --&gt; scenex.ResizePolicy\n                \n\n\n              click scenex.ResizePolicy href \"\" \"scenex.ResizePolicy\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>Base class defining how a view adapts to changes in its layout dimensions.</p> <p>A ResizePolicy is invoked automatically when a view's layout dimensions change, providing a hook to adjust any aspect of the view in response. While the most common use case is adjusting the camera's projection matrix to maintain aspect ratio or fit content, strategies have full access to the view and can modify the camera, scene, layout, or any other properties as needed.</p> <p>Strategies are attached to View instances and called whenever the layout width or height changes, whether from user interaction (window resize, splitter drag) or programmatic updates.</p> <p>Examples:</p> <p>Maintain aspect ratio when view resizes:     &gt;&gt;&gt; view = View(camera=Camera(), on_resize=Letterbox())</p> <p>No resize behavior (omit the on_resize parameter):     &gt;&gt;&gt; view = View(camera=Camera())</p> See Also <p>Letterbox : Resize strategy that maintains aspect ratio View : View class that uses resize strategies Camera : Camera class with projection property</p> <p>Methods:</p> <ul> <li> <code>handle_resize</code>             \u2013              <p>Respond to view layout dimension changes.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> </ul>"},{"location":"reference/scenex/#scenex.ResizePolicy.handle_resize","title":"handle_resize  <code>abstractmethod</code>","text":"<pre><code>handle_resize(view: View) -&gt; None\n</code></pre> <p>Respond to view layout dimension changes.</p> <p>This method is called automatically when the view's layout dimensions change. Implementations have full access to the view and can modify any of its properties.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_view.py</code> <pre><code>@abstractmethod\ndef handle_resize(self, view: View) -&gt; None:\n    \"\"\"\n    Respond to view layout dimension changes.\n\n    This method is called automatically when the view's layout dimensions change.\n    Implementations have full access to the view and can modify any of its\n    properties.\n\n    Parameters\n    ----------\n    view : View\n        The view being resized.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/scenex/#scenex.ResizePolicy.handle_resize(view)","title":"<code>view</code>","text":"(<code>View</code>)           \u2013            <p>The view being resized.</p>"},{"location":"reference/scenex/#scenex.ResizePolicy.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene","title":"Scene","text":"<pre><code>Scene(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <pre><code>\n              flowchart TD\n              scenex.Scene[Scene]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.node.Node --&gt; scenex.Scene\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n              click scenex.Scene href \"\" \"scenex.Scene\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>The root container node for a scene graph.</p> <p>Scene is a specialized Node that serves as the root of a scene graph hierarchy. It contains all the visual elements (Images, Points, Lines, Meshes, etc.) and cameras that make up a complete 3D scene. While functionally identical to a Node, Scene provides semantic clarity that this is the top-level container.</p> <p>A Scene is typically associated with a View, which pairs it with a Camera to define what is rendered and how. Multiple views can display the same scene from different camera perspectives.</p> <p>Examples:</p> <p>Create a scene with visual elements:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; my_image = np.random.rand(100, 100).astype(np.float32)     &gt;&gt;&gt; my_points = np.random.rand(100, 3).astype(np.float32)     &gt;&gt;&gt; scene = Scene(     ...     children=[     ...         Image(data=my_image),     ...         Points(     ...             vertices=my_points,     ...             face_color=UniformColor(color=Color(\"red\")),     ...         ),     ...     ]     ... )</p> <p>Create an empty scene and later add children:     &gt;&gt;&gt; scene = Scene()     &gt;&gt;&gt; scene.add_child(Image(data=my_image))     &gt;&gt;&gt; scene.add_child(Points(vertices=my_points))</p> <p>Create a hierarchical scene with nested nodes:     &gt;&gt;&gt; grandchild = Image(data=my_image)     &gt;&gt;&gt; parent = Points(vertices=my_points)     &gt;&gt;&gt; scene = Scene(children=[parent])</p> <p>Use a scene with a view:     &gt;&gt;&gt; view = View(scene=scene, camera=Camera())     &gt;&gt;&gt; canvas = Canvas(views=[view])</p> Notes <p>Scene inherits all Node attributes and methods including transform, visible, opacity, and children management. The scene itself does not have visual representation; it only serves as a container for renderable nodes.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>passes_through</code>             \u2013              <p>Returns the depth t at which the provided ray intersects this node.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/scene.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[\"Node | dict[str, Any]\"] = (),\n    **data: \"Unpack[NodeKwargs]\",\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/#scenex.Scene.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene.passes_through","title":"passes_through","text":"<pre><code>passes_through(ray: Ray) -&gt; float | None\n</code></pre> <p>Returns the depth t at which the provided ray intersects this node.</p> <p>The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t, where t&gt;=0</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>t</code> (              <code>float | None</code> )          \u2013            <p>The depth t at which the ray intersects the node, or None if it never intersects.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def passes_through(self, ray: Ray) -&gt; float | None:\n    \"\"\"Returns the depth t at which the provided ray intersects this node.\n\n    The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t,\n    where t&gt;=0\n\n    Parameters\n    ----------\n    ray : Ray\n        The ray passing through the scene\n\n    Returns\n    -------\n    t: float | None\n        The depth t at which the ray intersects the node, or None if it never\n        intersects.\n    \"\"\"\n    # Nodes that want to support ray intersection should override this method.\n    return None\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene.passes_through(ray)","title":"<code>ray</code>","text":"(<code>Ray</code>)           \u2013            <p>The ray passing through the scene</p>"},{"location":"reference/scenex/#scenex.Scene.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Scene.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Scene.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Scene.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/#scenex.Text","title":"Text","text":"<pre><code>Text(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <pre><code>\n              flowchart TD\n              scenex.Text[Text]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.node.Node --&gt; scenex.Text\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n              click scenex.Text href \"\" \"scenex.Text\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A text label positioned in 3D world space.</p> <p>The text maintains a constant screen size regardless of camera zoom or distance, making it useful for labels, annotations, and markers. The text is positioned at the node's transformed origin point.</p> <p>Examples:</p> <p>Create a simple text label:     &gt;&gt;&gt; text = Text(text=\"Hello World\", color=Color(\"white\"), size=14)</p> Notes <p>Text maintains constant screen size, not world size. The font size is specified in pixels and does not scale with camera zoom or distance from the viewer.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>passes_through</code>             \u2013              <p>Returns the depth t at which the provided ray intersects this node.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/#scenex.Text.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/#scenex.Text.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Text.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/#scenex.Text.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Text.passes_through","title":"passes_through","text":"<pre><code>passes_through(ray: Ray) -&gt; float | None\n</code></pre> <p>Returns the depth t at which the provided ray intersects this node.</p> <p>The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t, where t&gt;=0</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>t</code> (              <code>float | None</code> )          \u2013            <p>The depth t at which the ray intersects the node, or None if it never intersects.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def passes_through(self, ray: Ray) -&gt; float | None:\n    \"\"\"Returns the depth t at which the provided ray intersects this node.\n\n    The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t,\n    where t&gt;=0\n\n    Parameters\n    ----------\n    ray : Ray\n        The ray passing through the scene\n\n    Returns\n    -------\n    t: float | None\n        The depth t at which the ray intersects the node, or None if it never\n        intersects.\n    \"\"\"\n    # Nodes that want to support ray intersection should override this method.\n    return None\n</code></pre>"},{"location":"reference/scenex/#scenex.Text.passes_through(ray)","title":"<code>ray</code>","text":"(<code>Ray</code>)           \u2013            <p>The ray passing through the scene</p>"},{"location":"reference/scenex/#scenex.Text.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/#scenex.Text.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Text.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Text.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Text.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Text.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform","title":"Transform","text":"<p>               Bases: <code>RootModel</code></p> <pre><code>\n              flowchart TD\n              scenex.Transform[Transform]\n\n              \n\n              click scenex.Transform href \"\" \"scenex.Transform\"\n            </code></pre> <p>A 4x4 homogeneous transformation matrix for 3D affine transformations.</p> <p>Transformations use homogeneous coordinates, where 3D points (x, y, z) are represented as 4-vectors (x, y, z, 1). This enables affine transformations (translation, rotation, scaling) to be represented as matrix multiplication.</p> <p>The Transform class is immutable (frozen). Operations like translated(), rotated(), and scaled() return new Transform instances rather than modifying the original.</p> <p>Examples:</p> <p>Create an identity transform:     &gt;&gt;&gt; transform = Transform()</p> <p>Translate an object:     &gt;&gt;&gt; transform = Transform().translated((10, 20, 30))</p> <p>Rotate 45 degrees around the z-axis:     &gt;&gt;&gt; transform = Transform().rotated(45, axis=(0, 0, 1))</p> <p>Scale uniformly by 2x:     &gt;&gt;&gt; transform = Transform().scaled((2, 2, 2))</p> <p>Chain multiple transformations:     &gt;&gt;&gt; transform = (     ...     Transform()     ...     .translated((10, 0, 0))     ...     .rotated(45, (0, 0, 1))     ...     .scaled((2, 2, 2))     ... )</p> <p>Rotate around a specific point:     &gt;&gt;&gt; transform = Transform().rotated(90, axis=(0, 0, 1), about=(10, 10, 0))</p> <p>Transform coordinates:     &gt;&gt;&gt; points = np.array([[0, 0, 0], [1, 1, 1]])     &gt;&gt;&gt; transformed = transform.map(points)</p> <p>Combine two transforms:     &gt;&gt;&gt; transform1 = Transform().translated((5, 0, 0))     &gt;&gt;&gt; transform2 = Transform().scaled((2, 2, 2))     &gt;&gt;&gt; combined = transform1 @ transform2</p> <p>Invert a transform:     &gt;&gt;&gt; inverse = transform.inv()</p> Notes <ul> <li>Transformations are applied in the order they are chained</li> <li>The transform is immutable; all operations return new instances</li> <li>Uses right-multiplication convention: point @ matrix</li> <li>Default rotation axis is (0, 0, 1) - the z-axis</li> </ul> <p>Methods:</p> <ul> <li> <code>chain</code>             \u2013              <p>Chain multiple transforms together.</p> </li> <li> <code>dot</code>             \u2013              <p>Return the dot product of this transform with another.</p> </li> <li> <code>imap</code>             \u2013              <p>Inverse map coordinates.</p> </li> <li> <code>inv</code>             \u2013              <p>Return the inverse of the transform.</p> </li> <li> <code>is_null</code>             \u2013              <p>Return True if the transform is the identity matrix.</p> </li> <li> <code>map</code>             \u2013              <p>Map coordinates.</p> </li> <li> <code>rotated</code>             \u2013              <p>Return new transform, rotated some angle about a given axis.</p> </li> <li> <code>scaled</code>             \u2013              <p>Return new transform, scaled about a given origin.</p> </li> <li> <code>translated</code>             \u2013              <p>Return new transform, translated by pos.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>T</code>               (<code>Transform</code>)           \u2013            <p>Return the transpose of the transform.</p> </li> </ul>"},{"location":"reference/scenex/#scenex.Transform.T","title":"T  <code>property</code>","text":"<pre><code>T: Transform\n</code></pre> <p>Return the transpose of the transform.</p>"},{"location":"reference/scenex/#scenex.Transform.chain","title":"chain  <code>classmethod</code>","text":"<pre><code>chain(*transforms: Transform) -&gt; Transform\n</code></pre> <p>Chain multiple transforms together.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>Transform</code> )          \u2013            <p>Chained transform.</p> </li> </ul> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>@classmethod\ndef chain(cls, *transforms: Transform) -&gt; Transform:\n    \"\"\"Chain multiple transforms together.\n\n    Parameters\n    ----------\n    transforms : Transform\n        Transforms to chain.\n\n    Returns\n    -------\n    transform : Transform\n        Chained transform.\n    \"\"\"\n    return reduce(lambda a, b: a @ b, transforms, cls())\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.chain(transforms)","title":"<code>transforms</code>","text":"(<code>Transform</code>, default:                   <code>()</code> )           \u2013            <p>Transforms to chain.</p>"},{"location":"reference/scenex/#scenex.Transform.dot","title":"dot","text":"<pre><code>dot(other: Transform | ArrayLike) -&gt; Transform\n</code></pre> <p>Return the dot product of this transform with another.</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def dot(self, other: Transform | ArrayLike) -&gt; Transform:\n    \"\"\"Return the dot product of this transform with another.\"\"\"\n    if isinstance(other, Transform):\n        other = other.root\n    return Transform(np.dot(self.root, other))\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.imap","title":"imap","text":"<pre><code>imap(coords: ArrayLike) -&gt; NDArray\n</code></pre> <p>Inverse map coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>coords</code> (              <code>ndarray</code> )          \u2013            <p>Coordinates.</p> </li> </ul> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>@_arg_to_vec4\ndef imap(self, coords: ArrayLike) -&gt; NDArray:\n    \"\"\"Inverse map coordinates.\n\n    Parameters\n    ----------\n    coords : array-like\n        Coordinates to inverse map.\n\n    Returns\n    -------\n    coords : ndarray\n        Coordinates.\n    \"\"\"\n    return cast(\"NDArray\", np.dot(coords, np.linalg.inv(self.root)))\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.imap(coords)","title":"<code>coords</code>","text":"(<code>array - like</code>)           \u2013            <p>Coordinates to inverse map.</p>"},{"location":"reference/scenex/#scenex.Transform.inv","title":"inv","text":"<pre><code>inv() -&gt; Transform\n</code></pre> <p>Return the inverse of the transform.</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def inv(self) -&gt; Transform:\n    \"\"\"Return the inverse of the transform.\"\"\"\n    return Transform(np.linalg.inv(self.root))\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.is_null","title":"is_null","text":"<pre><code>is_null() -&gt; bool\n</code></pre> <p>Return True if the transform is the identity matrix.</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def is_null(self) -&gt; bool:\n    \"\"\"Return True if the transform is the identity matrix.\"\"\"\n    return np.allclose(self.root, np.eye(4))\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.map","title":"map","text":"<pre><code>map(coords: ArrayLike) -&gt; NDArray\n</code></pre> <p>Map coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>coords</code> (              <code>ndarray</code> )          \u2013            <p>Coordinates.</p> </li> </ul> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>@_arg_to_vec4\ndef map(self, coords: ArrayLike) -&gt; NDArray:\n    \"\"\"Map coordinates.\n\n    Parameters\n    ----------\n    coords : array-like\n        Coordinates to map.\n\n    Returns\n    -------\n    coords : ndarray\n        Coordinates.\n    \"\"\"\n    # looks backwards, but both matrices are transposed.\n    return cast(\"NDArray\", np.dot(coords, self.root))\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.map(coords)","title":"<code>coords</code>","text":"(<code>array - like</code>)           \u2013            <p>Coordinates to map.</p>"},{"location":"reference/scenex/#scenex.Transform.rotated","title":"rotated","text":"<pre><code>rotated(\n    angle: float,\n    axis: ArrayLike = (0, 0, 1),\n    about: ArrayLike | None = None,\n) -&gt; Transform\n</code></pre> <p>Return new transform, rotated some angle about a given axis.</p> <p>The rotation is applied after the transformations already present in the matrix.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def rotated(\n    self, angle: float, axis: ArrayLike = (0, 0, 1), about: ArrayLike | None = None\n) -&gt; Transform:\n    \"\"\"Return new transform, rotated some angle about a given axis.\n\n    The rotation is applied *after* the transformations already present\n    in the matrix.\n\n    Parameters\n    ----------\n    angle : float\n        The angle of rotation, in degrees.\n    axis : array-like\n        The x, y and z coordinates of the axis vector to rotate around.\n        By default, will rotate around the z-axis: `(0, 0, 1)`.\n    about : array-like or None\n        The x, y and z coordinates to rotate around. If None, will rotate around\n        the origin (0, 0, 0).\n    \"\"\"\n    if about is not None:\n        about = as_vec4(about)[0, :3]\n        return self.translated(-about).dot(rotate(angle, axis)).translated(about)\n    return self.dot(rotate(angle, axis))\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.rotated(angle)","title":"<code>angle</code>","text":"(<code>float</code>)           \u2013            <p>The angle of rotation, in degrees.</p>"},{"location":"reference/scenex/#scenex.Transform.rotated(axis)","title":"<code>axis</code>","text":"(<code>array - like</code>, default:                   <code>(0, 0, 1)</code> )           \u2013            <p>The x, y and z coordinates of the axis vector to rotate around. By default, will rotate around the z-axis: <code>(0, 0, 1)</code>.</p>"},{"location":"reference/scenex/#scenex.Transform.rotated(about)","title":"<code>about</code>","text":"(<code>array - like or None</code>, default:                   <code>None</code> )           \u2013            <p>The x, y and z coordinates to rotate around. If None, will rotate around the origin (0, 0, 0).</p>"},{"location":"reference/scenex/#scenex.Transform.scaled","title":"scaled","text":"<pre><code>scaled(\n    scale_factor: ArrayLike, center: ArrayLike | None = None\n) -&gt; Transform\n</code></pre> <p>Return new transform, scaled about a given origin.</p> <p>The scaling is applied after the transformations already present in the matrix.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def scaled(\n    self, scale_factor: ArrayLike, center: ArrayLike | None = None\n) -&gt; Transform:\n    \"\"\"Return new transform, scaled about a given origin.\n\n    The scaling is applied *after* the transformations already present\n    in the matrix.\n\n    Parameters\n    ----------\n    scale_factor : array-like\n        Scale factors along x, y and z axes.\n    center : array-like or None\n        The x, y and z coordinates to scale around. If None,\n        (0, 0, 0) will be used.\n    \"\"\"\n    _scale = scale(as_vec4(scale_factor, default=(1, 1, 1, 1))[0, :3])\n    if center is not None:\n        center = as_vec4(center)[0, :3]\n        _scale = np.dot(np.dot(translate(-center), _scale), translate(center))\n    return self.dot(_scale)\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.scaled(scale_factor)","title":"<code>scale_factor</code>","text":"(<code>array - like</code>)           \u2013            <p>Scale factors along x, y and z axes.</p>"},{"location":"reference/scenex/#scenex.Transform.scaled(center)","title":"<code>center</code>","text":"(<code>array - like or None</code>, default:                   <code>None</code> )           \u2013            <p>The x, y and z coordinates to scale around. If None, (0, 0, 0) will be used.</p>"},{"location":"reference/scenex/#scenex.Transform.translated","title":"translated","text":"<pre><code>translated(pos: ArrayLike) -&gt; Transform\n</code></pre> <p>Return new transform, translated by pos.</p> <p>The translation is applied after the transformations already present in the matrix.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def translated(self, pos: ArrayLike) -&gt; Transform:\n    \"\"\"Return new transform, translated by pos.\n\n    The translation is applied *after* the transformations already present\n    in the matrix.\n\n    Parameters\n    ----------\n    pos : ArrayLike\n        Position (x, y, z) to translate by.\n    \"\"\"\n    pos = as_vec4(np.array(pos))\n    return self.dot(translate(pos[0, :3]))\n</code></pre>"},{"location":"reference/scenex/#scenex.Transform.translated(pos)","title":"<code>pos</code>","text":"(<code>ArrayLike</code>)           \u2013            <p>Position (x, y, z) to translate by.</p>"},{"location":"reference/scenex/#scenex.UniformColor","title":"UniformColor","text":"<pre><code>UniformColor(**data: Any)\n</code></pre> <p>               Bases: <code>ColorModel</code></p> <pre><code>\n              flowchart TD\n              scenex.UniformColor[UniformColor]\n              scenex.model._color.ColorModel[ColorModel]\n\n                              scenex.model._color.ColorModel --&gt; scenex.UniformColor\n                \n\n\n              click scenex.UniformColor href \"\" \"scenex.UniformColor\"\n              click scenex.model._color.ColorModel href \"\" \"scenex.model._color.ColorModel\"\n            </code></pre> <p>Uniform coloring strategy for scene nodes.</p> <p>This model applies a single color to the entire geometry (mesh, line, points, etc). The <code>color</code> field is a single <code>Color</code> instance (e.g. Color(\"red\")).</p> <p>Examples:</p> <p>Uniform coloring:     &gt;&gt;&gt; from cmap import Color     &gt;&gt;&gt; from scenex import UniformColor     &gt;&gt;&gt; model = UniformColor(color=Color(\"red\"))</p> Source code in <code>src/scenex/model/_color.py</code> <pre><code>def __init__(self, **data: Any) -&gt; None:\n    if type(self) is ColorModel:\n        raise TypeError(\"ColorModel cannot be instantiated directly\")\n    super().__init__(**data)\n</code></pre>"},{"location":"reference/scenex/#scenex.VertexColors","title":"VertexColors","text":"<pre><code>VertexColors(**data: Any)\n</code></pre> <p>               Bases: <code>ColorModel</code></p> <pre><code>\n              flowchart TD\n              scenex.VertexColors[VertexColors]\n              scenex.model._color.ColorModel[ColorModel]\n\n                              scenex.model._color.ColorModel --&gt; scenex.VertexColors\n                \n\n\n              click scenex.VertexColors href \"\" \"scenex.VertexColors\"\n              click scenex.model._color.ColorModel href \"\" \"scenex.model._color.ColorModel\"\n            </code></pre> <p>Per-vertex coloring strategy for mesh, line, or points nodes.</p> <p>This model applies a different color to each vertex. The <code>color</code> field is a sequence of <code>Color</code> instances, one for each vertex.</p> <p>Examples:</p> <p>Per-vertex coloring:     &gt;&gt;&gt; from cmap import Color     &gt;&gt;&gt; from scenex import VertexColors     &gt;&gt;&gt; model = VertexColors(     ...     color=[Color(\"yellow\"), Color(\"purple\"), Color(\"cyan\")]     ... )</p> Source code in <code>src/scenex/model/_color.py</code> <pre><code>def __init__(self, **data: Any) -&gt; None:\n    if type(self) is ColorModel:\n        raise TypeError(\"ColorModel cannot be instantiated directly\")\n    super().__init__(**data)\n</code></pre>"},{"location":"reference/scenex/#scenex.View","title":"View","text":"<p>               Bases: <code>EventedBase</code></p> <pre><code>\n              flowchart TD\n              scenex.View[View]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._base.EventedBase --&gt; scenex.View\n                \n\n\n              click scenex.View href \"\" \"scenex.View\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A rectangular viewport that displays a scene through a camera.</p> <p>A View represents a rectangular area on a canvas that renders a scene graph through a specific camera perspective. Each view associates exactly one scene with one camera, defining what is displayed and how it is viewed. Multiple views can exist on a single canvas, each potentially showing different scenes or the same scene from different camera angles.</p> <p>Examples:</p> <p>Create a view with a scene containing an image:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; my_array = np.random.rand(100, 100).astype(np.float32)     &gt;&gt;&gt; scene = Scene(children=[Image(data=my_array)])     &gt;&gt;&gt; view = View(scene=scene, camera=Camera())</p> <p>Create a view with interactive camera and letterbox resizing:     &gt;&gt;&gt; view = View(     ...     scene=scene,     ...     camera=Camera(controller=PanZoom(), interactive=True),     ...     on_resize=Letterbox(),     ... )</p> <p>Add a view to a canvas:     &gt;&gt;&gt; canvas = Canvas()     &gt;&gt;&gt; canvas.views.append(view)</p> <p>Methods:</p> <ul> <li> <code>filter_event</code>             \u2013              <p>Filters the event.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Post-initialization hook for the model.</p> </li> <li> <code>render</code>             \u2013              <p>Render the view to an array.</p> </li> <li> <code>set_event_filter</code>             \u2013              <p>Registers a callable to filter events.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>canvas</code>               (<code>Canvas</code>)           \u2013            <p>The canvas that the view is on.</p> </li> </ul>"},{"location":"reference/scenex/#scenex.View.canvas","title":"canvas  <code>property</code> <code>writable</code>","text":"<pre><code>canvas: Canvas\n</code></pre> <p>The canvas that the view is on.</p> <p>If one hasn't been created/assigned, a new one is created.</p>"},{"location":"reference/scenex/#scenex.View.filter_event","title":"filter_event","text":"<pre><code>filter_event(event: Event) -&gt; bool\n</code></pre> <p>Filters the event.</p> <p>This method allows the larger view to react to events that: 1. Require summarization of multiple smaller event responses. 2. Could not be picked up by a node (e.g. mouse leaving an image).</p> <p>Note the name has parity with Node.filter_event, but there's not much filtering going on.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event should not be propagated to other handlers.</p> </li> </ul> Source code in <code>src/scenex/model/_view.py</code> <pre><code>def filter_event(self, event: Event) -&gt; bool:\n    \"\"\"\n    Filters the event.\n\n    This method allows the larger view to react to events that:\n    1. Require summarization of multiple smaller event responses.\n    2. Could not be picked up by a node (e.g. mouse leaving an image).\n\n    Note the name has parity with Node.filter_event, but there's not much filtering\n    going on.\n\n    Parameters\n    ----------\n    event : Event\n        An event occurring in the view.\n\n    Returns\n    -------\n    bool\n        True iff the event should not be propagated to other handlers.\n    \"\"\"\n    if self._filter:\n        handled = self._filter(event)\n        if not isinstance(handled, bool):\n            # Some widget frameworks (i.e. Qt) get upset when non-booleans are\n            # returned. If the event-filter does not return a boolean, rather than\n            # letting that propagate upwards, we log a warning and return False.\n            logger.warning(\n                f\"Event filter {self._filter} did not return a boolean. \"\n                \"Returning False.\"\n            )\n            # Return False. We assume that if the user wanted to block future\n            # processing, they'd be less likely to forget a boolean return.\n            # Further, allowing downstream processing is a clear sign to they author\n            # that they forgot to block propagation.\n            handled = False\n        return handled\n    return False\n</code></pre>"},{"location":"reference/scenex/#scenex.View.filter_event(event)","title":"<code>event</code>","text":"(<code>Event</code>)           \u2013            <p>An event occurring in the view.</p>"},{"location":"reference/scenex/#scenex.View.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Post-initialization hook for the model.</p> Source code in <code>src/scenex/model/_view.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Post-initialization hook for the model.\"\"\"\n    super().model_post_init(__context)\n    self.camera.parent = self.scene\n\n    # FIXME: Reconnect this when the layout is changed\n    self.layout.events.width.connect(self._on_layout_change)\n    self.layout.events.height.connect(self._on_layout_change)\n</code></pre>"},{"location":"reference/scenex/#scenex.View.render","title":"render","text":"<pre><code>render() -&gt; ndarray\n</code></pre> <p>Render the view to an array.</p> Source code in <code>src/scenex/model/_view.py</code> <pre><code>def render(self) -&gt; np.ndarray:\n    \"\"\"Render the view to an array.\"\"\"\n    if adaptors := self._get_adaptors():\n        return cast(\"ViewAdaptor\", adaptors[0])._snx_render()\n    raise RuntimeError(\"No adaptor found for View.\")\n</code></pre>"},{"location":"reference/scenex/#scenex.View.set_event_filter","title":"set_event_filter","text":"<pre><code>set_event_filter(\n    callable: Callable[[Event], bool] | None,\n) -&gt; Callable[[Event], bool] | None\n</code></pre> <p>Registers a callable to filter events.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Callable[[Event], bool] | None</code>           \u2013            <p>The previous event filter, or None if there was no filter.</p> </li> <li> <code>Note the name has parity with Node.filter_event, but there's not much filtering</code>           \u2013            </li> <li> <code>going on.</code>           \u2013            </li> </ul> Source code in <code>src/scenex/model/_view.py</code> <pre><code>def set_event_filter(\n    self, callable: Callable[[Event], bool] | None\n) -&gt; Callable[[Event], bool] | None:\n    \"\"\"\n    Registers a callable to filter events.\n\n    Parameters\n    ----------\n    callable : Callable[[Event], bool] | None\n        A callable that takes an Event and returns True if the event was handled,\n        False otherwise. Passing None is equivalent to removing any existing filter.\n        By returning True, the callable indicates that the event has been handled\n        and should not be propagated to subsequent handlers.\n\n    Returns\n    -------\n    Callable[[Event], bool] | None\n        The previous event filter, or None if there was no filter.\n\n    Note the name has parity with Node.filter_event, but there's not much filtering\n    going on.\n    \"\"\"\n    old, self._filter = self._filter, callable\n    return old\n</code></pre>"},{"location":"reference/scenex/#scenex.View.set_event_filter(callable)","title":"<code>callable</code>","text":"(<code>Callable[[Event], bool] | None</code>)           \u2013            <p>A callable that takes an Event and returns True if the event was handled, False otherwise. Passing None is equivalent to removing any existing filter. By returning True, the callable indicates that the event has been handled and should not be propagated to subsequent handlers.</p>"},{"location":"reference/scenex/#scenex.Volume","title":"Volume","text":"<pre><code>Volume(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Image</code></p> <pre><code>\n              flowchart TD\n              scenex.Volume[Volume]\n              scenex.model._nodes.image.Image[Image]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.image.Image --&gt; scenex.Volume\n                                scenex.model._nodes.node.Node --&gt; scenex.model._nodes.image.Image\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n\n              click scenex.Volume href \"\" \"scenex.Volume\"\n              click scenex.model._nodes.image.Image href \"\" \"scenex.model._nodes.image.Image\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A 3D volumetric dataset rendered with volume rendering techniques.</p> <p>Volume extends Image to support 3D volumetric data. Unlike images which are 2D arrays, volumes are 3D arrays of intensity values that are rendered using volume rendering techniques like maximum intensity projection (MIP) or isosurface rendering.</p> <p>The volume uses ZYX dimension ordering, meaning data.shape = (depth, height, width). Like Image, the volume supports colormapping, intensity normalization, and gamma correction. The rendering mode determines how the 3D data is projected onto the 2D viewing plane.</p> <p>Examples:</p> <p>Create a volume with MIP rendering:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; data = np.random.rand(50, 100, 100)  # ZYX dimensions     &gt;&gt;&gt; volume = Volume(data=data, render_mode=\"mip\")</p> <p>Create a volume with custom colormap and intensity range:     &gt;&gt;&gt; volume = Volume(     ...     data=data,     ...     cmap=Colormap(\"viridis\"),     ...     clims=(0, 1),     ...     render_mode=\"iso\",     ... )</p> Notes <p>Volume inherits all Image attributes including data, cmap, clims, gamma, and interpolation. The data should be a 3D array with shape (depth, height, width) following ZYX convention.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/#scenex.Volume.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/#scenex.Volume.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Volume.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/#scenex.Volume.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/#scenex.Volume.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/#scenex.Volume.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Volume.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/#scenex.Volume.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/#scenex.Volume.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/#scenex.Volume.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/#scenex.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Start the GUI event loop to display interactive visualizations.</p> <p>This function enters the native event loop of the graphics backend, allowing interactive visualizations to respond to user input (mouse, keyboard) and remain visible. The function blocks until the visualization window is closed.</p> <p>Call this function after creating and showing your visualizations with <code>show()</code>. It is only needed for desktop applications; in Jupyter notebooks, visualizations are displayed automatically without calling <code>run()</code>.</p> <p>Examples:</p> <p>Basic usage with a scene:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; import scenex as snx     &gt;&gt;&gt; scene = snx.Scene(     ...     children=[snx.Image(data=np.random.rand(100, 100).astype(np.float32))]     ... )     &gt;&gt;&gt; snx.show(scene)     Canvas(...)     &gt;&gt;&gt; snx.run()  # Blocks until window is closed</p> <p>Create multiple views and run:     &gt;&gt;&gt; canvas = snx.Canvas(views=[snx.View(), snx.View()])     &gt;&gt;&gt; canvas.visible = True     &gt;&gt;&gt; snx.run()</p> Notes <ul> <li>This function blocks execution until all visualization windows are closed</li> <li>Not needed in Jupyter notebooks or other interactive environments</li> <li>Must be called after <code>show()</code> has been used to create visualizations</li> <li>The event loop handles user interactions like pan, zoom, and picking</li> </ul> Source code in <code>src/scenex/adaptors/_auto.py</code> <pre><code>def run() -&gt; None:\n    \"\"\"Start the GUI event loop to display interactive visualizations.\n\n    This function enters the native event loop of the graphics backend, allowing\n    interactive visualizations to respond to user input (mouse, keyboard) and remain\n    visible. The function blocks until the visualization window is closed.\n\n    Call this function after creating and showing your visualizations with `show()`.\n    It is only needed for desktop applications; in Jupyter notebooks, visualizations\n    are displayed automatically without calling `run()`.\n\n    Examples\n    --------\n    Basic usage with a scene:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import scenex as snx\n        &gt;&gt;&gt; scene = snx.Scene(\n        ...     children=[snx.Image(data=np.random.rand(100, 100).astype(np.float32))]\n        ... )\n        &gt;&gt;&gt; snx.show(scene)\n        Canvas(...)\n        &gt;&gt;&gt; snx.run()  # Blocks until window is closed\n\n    Create multiple views and run:\n        &gt;&gt;&gt; canvas = snx.Canvas(views=[snx.View(), snx.View()])\n        &gt;&gt;&gt; canvas.visible = True\n        &gt;&gt;&gt; snx.run()\n\n    Notes\n    -----\n    - This function blocks execution until all visualization windows are closed\n    - Not needed in Jupyter notebooks or other interactive environments\n    - Must be called after `show()` has been used to create visualizations\n    - The event loop handles user interactions like pan, zoom, and picking\n    \"\"\"\n    app().run()\n</code></pre>"},{"location":"reference/scenex/#scenex.show","title":"show","text":"<pre><code>show(\n    obj: Node | View | Canvas, *, backend: str | None = None\n) -&gt; Canvas\n</code></pre> <p>Display a visualization by creating a canvas and making it visible.</p> <p>This is the primary function for creating and displaying scenex visualizations. It accepts nodes, views, or canvases, automatically wrapping them in the necessary container objects and creating the appropriate backend adaptors.</p> <p>The function automatically fits the camera view to show all visible content and makes the canvas window visible. After calling <code>show()</code>, use <code>run()</code> to enter the event loop (in desktop applications) or continue working (in notebooks).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Canvas</code>           \u2013            <p>The canvas containing the visualization. Can be used to further manipulate the display or access the created views.</p> </li> </ul> <p>Examples:</p> <p>Show a simple image:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; import scenex as snx     &gt;&gt;&gt; data = np.random.rand(100, 100).astype(np.float32)     &gt;&gt;&gt; img = snx.Image(data=data)     &gt;&gt;&gt; canvas = snx.show(img)     &gt;&gt;&gt; snx.run()</p> <p>Edit the returned canvas:     &gt;&gt;&gt; from cmap import Color     &gt;&gt;&gt; canvas.background_color = Color(\"white\")     &gt;&gt;&gt; canvas.width = 800     &gt;&gt;&gt; snx.run()</p> Notes <ul> <li>The camera is automatically zoomed to fit all visible content with 90% coverage</li> <li>Canvas size defaults to the view's layout dimensions</li> <li>Call <code>run()</code> after <code>show()</code> to enter the event loop in desktop applications</li> <li>In Jupyter notebooks, visualizations appear automatically without <code>run()</code></li> </ul> Source code in <code>src/scenex/util.py</code> <pre><code>def show(\n    obj: model.Node | model.View | model.Canvas, *, backend: str | None = None\n) -&gt; model.Canvas:\n    \"\"\"Display a visualization by creating a canvas and making it visible.\n\n    This is the primary function for creating and displaying scenex visualizations.\n    It accepts nodes, views, or canvases, automatically wrapping them in the necessary\n    container objects and creating the appropriate backend adaptors.\n\n    The function automatically fits the camera view to show all visible content and\n    makes the canvas window visible. After calling `show()`, use `run()` to enter\n    the event loop (in desktop applications) or continue working (in notebooks).\n\n    Parameters\n    ----------\n    obj : Node | View | Canvas\n        The object to visualize:\n        - Node (Image, Points, Line, etc.): Wrapped in Scene and View automatically\n        - Scene: Wrapped in a View with a default Camera\n        - View: Placed on a new Canvas\n        - Canvas: Displayed directly (already contains Views)\n    backend : str | None, optional\n        Graphics backend to use (\"pygfx\" or \"vispy\"). If None, uses the backend\n        specified by `use()`, `SCENEX_CANVAS_BACKEND` environment variable, or\n        auto-detection. Default is `None`.\n\n    Returns\n    -------\n    Canvas\n        The canvas containing the visualization. Can be used to further manipulate\n        the display or access the created views.\n\n    Examples\n    --------\n    Show a simple image:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import scenex as snx\n        &gt;&gt;&gt; data = np.random.rand(100, 100).astype(np.float32)\n        &gt;&gt;&gt; img = snx.Image(data=data)\n        &gt;&gt;&gt; canvas = snx.show(img)\n        &gt;&gt;&gt; snx.run()\n\n    Edit the returned canvas:\n        &gt;&gt;&gt; from cmap import Color\n        &gt;&gt;&gt; canvas.background_color = Color(\"white\")\n        &gt;&gt;&gt; canvas.width = 800\n        &gt;&gt;&gt; snx.run()\n\n    Notes\n    -----\n    - The camera is automatically zoomed to fit all visible content with 90% coverage\n    - Canvas size defaults to the view's layout dimensions\n    - Call `run()` after `show()` to enter the event loop in desktop applications\n    - In Jupyter notebooks, visualizations appear automatically without `run()`\n    \"\"\"\n    from .adaptors import get_adaptor_registry\n\n    view = None\n    if isinstance(obj, model.Canvas):\n        canvas = obj\n    else:\n        if isinstance(obj, model.View):\n            view = obj\n        elif isinstance(obj, model.Scene):\n            view = model.View(scene=obj)\n        elif isinstance(obj, model.Node):\n            scene = model.Scene(children=[obj])\n            view = model.View(scene=scene)\n\n        canvas = model.Canvas(\n            # Respect the view size if provided\n            width=int(view.layout.width),\n            height=int(view.layout.height),\n            views=[view],\n        )\n\n    canvas.visible = True\n    reg = get_adaptor_registry(backend=backend)\n    reg.get_adaptor(canvas, create=True)\n    app().create_app()\n    for view in canvas.views:\n        projections.zoom_to_fit(view, zoom_factor=0.9, preserve_aspect_ratio=True)\n\n        # logger.debug(\"SHOW MODEL  %s\", tree_repr(view.scene))\n        # native_scene = view.scene._get_native()\n        # logger.debug(\"SHOW NATIVE %s\", tree_repr(native_scene))\n    return canvas\n</code></pre>"},{"location":"reference/scenex/#scenex.show(obj)","title":"<code>obj</code>","text":"(<code>Node | View | Canvas</code>)           \u2013            <p>The object to visualize: - Node (Image, Points, Line, etc.): Wrapped in Scene and View automatically - Scene: Wrapped in a View with a default Camera - View: Placed on a new Canvas - Canvas: Displayed directly (already contains Views)</p>"},{"location":"reference/scenex/#scenex.show(backend)","title":"<code>backend</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Graphics backend to use (\"pygfx\" or \"vispy\"). If None, uses the backend specified by <code>use()</code>, <code>SCENEX_CANVAS_BACKEND</code> environment variable, or auto-detection. Default is <code>None</code>.</p>"},{"location":"reference/scenex/#scenex.use","title":"use","text":"<pre><code>use(backend: KnownBackend | None = None) -&gt; None\n</code></pre> <p>Set the graphics backend for rendering scenex visualizations.</p> <p>This function allows you to explicitly select which graphics library (backend) scenex should use for rendering. It is the goal of scenex to support the full range of model API for each backend.</p> <p>If not called, scenex will automatically select an arbitrary available backend. You can also set the backend via the SCENEX_CANVAS_BACKEND environment variable.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the specified backend is not one of the known backends.</p> </li> </ul> <p>Examples:</p> <p>Use pygfx backend explicitly:     &gt;&gt;&gt; import scenex as snx     &gt;&gt;&gt; snx.use(\"pygfx\")  # doctest: +SKIP     &gt;&gt;&gt; canvas = snx.show(snx.View())</p> <p>Use vispy backend:     &gt;&gt;&gt; snx.use(\"vispy\")  # doctest: +SKIP     &gt;&gt;&gt; canvas = snx.show(snx.Scene())</p> <p>Reset to auto-detection:     &gt;&gt;&gt; snx.use(None)</p> Notes <p>The backend selection follows this priority order: 1. Backend specified by this function 2. SCENEX_CANVAS_BACKEND environment variable 3. Auto-detection (pygfx preferred, then vispy)</p> <p>This function should be called before creating any visualizations.</p> Source code in <code>src/scenex/adaptors/_auto.py</code> <pre><code>def use(backend: KnownBackend | None = None) -&gt; None:\n    \"\"\"Set the graphics backend for rendering scenex visualizations.\n\n    This function allows you to explicitly select which graphics library (backend)\n    scenex should use for rendering. It is the goal of scenex to support the full range\n    of model API for each backend.\n\n    If not called, scenex will automatically select an arbitrary available backend. You\n    can also set the backend via the SCENEX_CANVAS_BACKEND environment variable.\n\n    Parameters\n    ----------\n    backend : Literal[\"pygfx\", \"vispy\"] | None\n        The graphics backend to use:\n        - \"pygfx\": Modern WebGPU-based renderer with advanced features\n        - \"vispy\": OpenGL-based renderer with broad compatibility\n        - None: Reset to auto-detection\n\n    Raises\n    ------\n    ValueError\n        If the specified backend is not one of the known backends.\n\n    Examples\n    --------\n    Use pygfx backend explicitly:\n        &gt;&gt;&gt; import scenex as snx\n        &gt;&gt;&gt; snx.use(\"pygfx\")  # doctest: +SKIP\n        &gt;&gt;&gt; canvas = snx.show(snx.View())\n\n    Use vispy backend:\n        &gt;&gt;&gt; snx.use(\"vispy\")  # doctest: +SKIP\n        &gt;&gt;&gt; canvas = snx.show(snx.Scene())\n\n    Reset to auto-detection:\n        &gt;&gt;&gt; snx.use(None)\n\n    Notes\n    -----\n    The backend selection follows this priority order:\n    1. Backend specified by this function\n    2. SCENEX_CANVAS_BACKEND environment variable\n    3. Auto-detection (pygfx preferred, then vispy)\n\n    This function should be called before creating any visualizations.\n    \"\"\"\n    global _USE\n    if backend is None or _ensure_valid_backend(backend):\n        _USE = backend\n</code></pre>"},{"location":"reference/scenex/#scenex.use(backend)","title":"<code>backend</code>","text":"(<code>Literal['pygfx', 'vispy'] | None</code>, default:                   <code>None</code> )           \u2013            <p>The graphics backend to use: - \"pygfx\": Modern WebGPU-based renderer with advanced features - \"vispy\": OpenGL-based renderer with broad compatibility - None: Reset to auto-detection</p>"},{"location":"reference/scenex/adaptors/","title":"adaptors","text":""},{"location":"reference/scenex/adaptors/#scenex.adaptors","title":"scenex.adaptors","text":"<p>Backend adaptors that translate scenex models into graphics library calls.</p> <p>Adaptors bridge the gap between scenex's declarative models and rendering backends (e.g. pygfx). For each model class in <code>scenex.model</code>, there should be a corresponding adaptor class for each backend that handles the actual GPU rendering.</p> <p>When you call <code>scenex.show()</code>, adaptors are automatically created for each object in your scene graph. The adaptors translate model properties (colors, transforms, data) into backend-specific commands. As you modify the models, events trigger updates in the adaptors to keep the rendered scene synced.</p> Architecture <p>The adaptor system uses a registry pattern::</p> <pre><code>Model (declarative) \u2192 Adaptor (imperative) \u2192 Backend (GPU library)\n\nImage model         \u2192 ImageAdaptor         \u2192 pygfx.Mesh + texture\n                    or\n                    \u2192 ImageAdaptor         \u2192 vispy.scene.Image\n</code></pre> <p>Each backend (pygfx, vispy) has its own set of adaptors implementing the same model-to-native translation logic tailored to that backend's API.</p> Main Components <ul> <li>AdaptorRegistry: Maps model classes to adaptor classes</li> <li>Adaptor: Base class for all adaptors, handles event subscription</li> <li>Backend-specific adaptors: In _pygfx and _vispy subpackages</li> </ul> Supported Backends <p>pygfx (WebGPU-based):     - Modern GPU API with advanced rendering features vispy (OpenGL-based):     - Mature, widely-supported OpenGL renderer</p> Usage <p>Adaptors are NOT intended for manual instantiation; they are instead created automatically by <code>scenex.show()</code>::</p> <pre><code>&gt;&gt;&gt; import scenex as snx\n&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; # Create model\n&gt;&gt;&gt; my_array = np.random.rand(100, 100).astype(np.float32)\n&gt;&gt;&gt; scene = snx.Scene(children=[snx.Image(data=my_array)])\n\n&gt;&gt;&gt; # This creates adaptors automatically\n&gt;&gt;&gt; snx.show(scene)\nCanvas(...)\n&gt;&gt;&gt; snx.run()\n</code></pre> <p>To select a particular backend, use <code>scenex.use()</code>::</p> <pre><code>&gt;&gt;&gt; snx.use(\"pygfx\")  # doctest: +SKIP\n&gt;&gt;&gt; snx.show(scene)\nCanvas(...)\n</code></pre> See Also <p>scenex.model : Declarative model classes scenex.use : Function to select rendering backend scenex.show : Function that creates adaptors</p> <p>Classes:</p> <ul> <li> <code>Adaptor</code>           \u2013            <p>ABC for backend adaptor classes.</p> </li> <li> <code>AdaptorRegistry</code>           \u2013            <p>Weak registry for Adaptor objects.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_adaptor_registry</code>             \u2013              <p>Get the backend adaptor registry.</p> </li> <li> <code>get_all_adaptors</code>             \u2013              <p>Get all loaded adaptors for the given object.</p> </li> <li> <code>run</code>             \u2013              <p>Start the GUI event loop to display interactive visualizations.</p> </li> <li> <code>use</code>             \u2013              <p>Set the graphics backend for rendering scenex visualizations.</p> </li> </ul>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.Adaptor","title":"Adaptor","text":"<pre><code>Adaptor(obj: TModel)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[TModel, TNative]</code></p> <pre><code>\n              flowchart TD\n              scenex.adaptors.Adaptor[Adaptor]\n\n              \n\n              click scenex.adaptors.Adaptor href \"\" \"scenex.adaptors.Adaptor\"\n            </code></pre> <p>ABC for backend adaptor classes.</p> <p>An adaptor converts model change events into into native calls for the given backend.</p> <p>All backend adaptor objects receive the object they are adapting.</p> <p>Methods:</p> <ul> <li> <code>handle_event</code>             \u2013              <p>Receive info from psygnal callback and convert to adaptor call.</p> </li> </ul> Source code in <code>src/scenex/adaptors/_base.py</code> <pre><code>@abstractmethod\ndef __init__(self, obj: TModel) -&gt; None:\n    \"\"\"All backend adaptor objects receive the object they are adapting.\"\"\"\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.Adaptor.handle_event","title":"handle_event","text":"<pre><code>handle_event(info: EmissionInfo) -&gt; None\n</code></pre> <p>Receive info from psygnal callback and convert to adaptor call.</p> Source code in <code>src/scenex/adaptors/_base.py</code> <pre><code>def handle_event(self, info: EmissionInfo) -&gt; None:\n    \"\"\"Receive info from psygnal callback and convert to adaptor call.\"\"\"\n    signal_name = info.signal.name\n    if signal_name == \"parent\":\n        # Parent change events are handled by the parent adaptor.\n        return\n\n    try:\n        name = self.SETTER_METHOD.format(name=signal_name)\n        setter = getattr(self, name)\n    except AttributeError as e:\n        logger.exception(e)\n        return\n\n    arg = info.args[0]\n    logger.debug(\"EVENT: %r -&gt; %s=%r  \", type(self), signal_name, arg)\n\n    try:\n        setter(arg)\n    except Exception as e:\n        logger.exception(e)\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.AdaptorRegistry","title":"AdaptorRegistry","text":"<pre><code>AdaptorRegistry()\n</code></pre> <p>Weak registry for Adaptor objects.</p> <p>Each backend should subclass this and implement the <code>get_adaptor_class</code> method. And expose an instance of the subclass as <code>adaptors</code> in the top level of the backend module.</p> <p>Methods:</p> <ul> <li> <code>all</code>             \u2013              <p>Return an iterator over all adaptors in the registry.</p> </li> <li> <code>create_adaptor</code>             \u2013              <p>Create a new adaptor for the given model object.</p> </li> <li> <code>get_adaptor</code>             \u2013              <p>Get the adaptor for the given model object, create if <code>create</code> is True.</p> </li> <li> <code>get_adaptor_class</code>             \u2013              <p>Return the adaptor class for the given model object.</p> </li> <li> <code>initialize_adaptor</code>             \u2013              <p>Initialize the adaptor for the given model object.</p> </li> <li> <code>validate_adaptor_class</code>             \u2013              <p>Validate that the given class is a valid adaptor for the given object.</p> </li> </ul> Source code in <code>src/scenex/adaptors/_registry.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._objects: dict[str, _base.Adaptor] = {}\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.AdaptorRegistry.all","title":"all","text":"<pre><code>all() -&gt; Iterator[Adaptor]\n</code></pre> <p>Return an iterator over all adaptors in the registry.</p> Source code in <code>src/scenex/adaptors/_registry.py</code> <pre><code>def all(self) -&gt; Iterator[_base.Adaptor]:\n    \"\"\"Return an iterator over all adaptors in the registry.\"\"\"\n    yield from self._objects.values()\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.AdaptorRegistry.create_adaptor","title":"create_adaptor","text":"<pre><code>create_adaptor(model: _M) -&gt; Adaptor[_M, Any]\n</code></pre> <p>Create a new adaptor for the given model object.</p> Source code in <code>src/scenex/adaptors/_registry.py</code> <pre><code>def create_adaptor(self, model: _M) -&gt; _base.Adaptor[_M, Any]:\n    \"\"\"Create a new adaptor for the given model object.\"\"\"\n    adaptor_cls: type[_base.Adaptor] = self.get_adaptor_class(model)\n    self.validate_adaptor_class(model, adaptor_cls)\n    adaptor = adaptor_cls(model)\n\n    return adaptor\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.AdaptorRegistry.get_adaptor","title":"get_adaptor","text":"<pre><code>get_adaptor(\n    obj: Points, create: bool = ...\n) -&gt; PointsAdaptor\n</code></pre><pre><code>get_adaptor(obj: Image, create: bool = ...) -&gt; ImageAdaptor\n</code></pre><pre><code>get_adaptor(\n    obj: Camera, create: bool = ...\n) -&gt; CameraAdaptor\n</code></pre><pre><code>get_adaptor(obj: Scene, create: bool = ...) -&gt; NodeAdaptor\n</code></pre><pre><code>get_adaptor(obj: View, create: bool = ...) -&gt; ViewAdaptor\n</code></pre><pre><code>get_adaptor(\n    obj: Canvas, create: bool = ...\n) -&gt; CanvasAdaptor\n</code></pre><pre><code>get_adaptor(\n    obj: EventedBase, create: bool = ...\n) -&gt; Adaptor\n</code></pre> <pre><code>get_adaptor(\n    obj: _M, create: bool = True\n) -&gt; Adaptor[_M, Any]\n</code></pre> <p>Get the adaptor for the given model object, create if <code>create</code> is True.</p> Source code in <code>src/scenex/adaptors/_registry.py</code> <pre><code>def get_adaptor(self, obj: _M, create: bool = True) -&gt; _base.Adaptor[_M, Any]:\n    \"\"\"Get the adaptor for the given model object, create if `create` is True.\"\"\"\n    if obj._model_id.hex not in self._objects:\n        if not create:\n            raise KeyError(\n                f\"{type(self).__name__!r} has no adaptor for {type(obj)} @ \"\n                f\"{id(obj):x}, and create=False\"\n            )\n        logger.debug(\n            \"Creating %r Adaptor %-14r id: %s\",\n            type(self).__module__,\n            type(obj).__name__,\n            obj._model_id.hex[:8],\n        )\n        self._objects[obj._model_id.hex] = adaptor = self.create_adaptor(obj)\n        self.initialize_adaptor(obj, adaptor)\n    return self._objects[obj._model_id.hex]\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.AdaptorRegistry.get_adaptor_class","title":"get_adaptor_class","text":"<pre><code>get_adaptor_class(obj: EventedBase) -&gt; type[Adaptor]\n</code></pre> <p>Return the adaptor class for the given model object.</p> Source code in <code>src/scenex/adaptors/_registry.py</code> <pre><code>def get_adaptor_class(self, obj: model.EventedBase) -&gt; type[_base.Adaptor]:\n    \"\"\"Return the adaptor class for the given model object.\"\"\"\n    cls = type(self)\n    cls_module = sys.modules[cls.__module__]\n    cls_file = cls_module.__file__\n    raise NotImplementedError(\n        f\"{cls.__name__}.get_adaptor_class not implemented in {cls_file}\"\n    )\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.AdaptorRegistry.initialize_adaptor","title":"initialize_adaptor","text":"<pre><code>initialize_adaptor(\n    model: EventedBase, adaptor: Adaptor\n) -&gt; None\n</code></pre> <p>Initialize the adaptor for the given model object.</p> Source code in <code>src/scenex/adaptors/_registry.py</code> <pre><code>def initialize_adaptor(\n    self, model: model.EventedBase, adaptor: _base.Adaptor\n) -&gt; None:\n    \"\"\"Initialize the adaptor for the given model object.\"\"\"\n    # syncronize all model properties with the adaptor\n    sync_adaptor(adaptor, model)\n    # connect the model events to the adaptor, to keep the adaptor in sync\n\n    model.events.connect(adaptor.handle_event)\n\n    if isinstance(model, models.Canvas):\n        for view in model.views:\n            self.get_adaptor(view, create=True)\n    if isinstance(model, models.View):\n        self.get_adaptor(model.scene, create=True)\n    if isinstance(model, models.Node):\n        adaptor = cast(\"_base.NodeAdaptor\", adaptor)\n        model.child_added.connect(adaptor._snx_add_child)\n        model.child_removed.connect(adaptor._snx_remove_child)\n        for child in model.children:\n            # perhaps optional ... since _implementations of _snx_add_child\n            # will also likely need to call get_adaptor\n            self.get_adaptor(child, create=True)\n            adaptor._snx_add_child(child)\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.AdaptorRegistry.validate_adaptor_class","title":"validate_adaptor_class  <code>classmethod</code>","text":"<pre><code>validate_adaptor_class(\n    obj: EventedBase, adaptor_cls: type[Adaptor]\n) -&gt; None\n</code></pre> <p>Validate that the given class is a valid adaptor for the given object.</p> Source code in <code>src/scenex/adaptors/_registry.py</code> <pre><code>@classmethod\ndef validate_adaptor_class(\n    cls, obj: model.EventedBase, adaptor_cls: type[_base.Adaptor]\n) -&gt; None:\n    \"\"\"Validate that the given class is a valid adaptor for the given object.\"\"\"\n    return _validate_adaptor_class(type(obj), adaptor_cls)\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.get_adaptor_registry","title":"get_adaptor_registry","text":"<pre><code>get_adaptor_registry(\n    backend: KnownBackend | str | None = None,\n) -&gt; AdaptorRegistry\n</code></pre> <p>Get the backend adaptor registry.</p> Source code in <code>src/scenex/adaptors/_auto.py</code> <pre><code>def get_adaptor_registry(backend: KnownBackend | str | None = None) -&gt; AdaptorRegistry:\n    \"\"\"Get the backend adaptor registry.\"\"\"\n    match determine_backend(backend):\n        case \"vispy\":\n            from . import _vispy\n\n            return _vispy.adaptors\n        case \"pygfx\":\n            from . import _pygfx\n\n            return _pygfx.adaptors\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.get_all_adaptors","title":"get_all_adaptors","text":"<pre><code>get_all_adaptors(obj: Any) -&gt; Iterator[Adaptor]\n</code></pre> <p>Get all loaded adaptors for the given object.</p> Source code in <code>src/scenex/adaptors/_auto.py</code> <pre><code>def get_all_adaptors(obj: Any) -&gt; Iterator[Adaptor]:\n    \"\"\"Get all loaded adaptors for the given object.\"\"\"\n    for mod_name in [\"scenex.adaptors._vispy\", \"scenex.adaptors._pygfx\"]:\n        if mod := sys.modules.get(mod_name):\n            reg = cast(\"AdaptorRegistry\", mod.adaptors)\n            with suppress(KeyError):\n                yield reg.get_adaptor(obj, create=False)\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Start the GUI event loop to display interactive visualizations.</p> <p>This function enters the native event loop of the graphics backend, allowing interactive visualizations to respond to user input (mouse, keyboard) and remain visible. The function blocks until the visualization window is closed.</p> <p>Call this function after creating and showing your visualizations with <code>show()</code>. It is only needed for desktop applications; in Jupyter notebooks, visualizations are displayed automatically without calling <code>run()</code>.</p> <p>Examples:</p> <p>Basic usage with a scene:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; import scenex as snx     &gt;&gt;&gt; scene = snx.Scene(     ...     children=[snx.Image(data=np.random.rand(100, 100).astype(np.float32))]     ... )     &gt;&gt;&gt; snx.show(scene)     Canvas(...)     &gt;&gt;&gt; snx.run()  # Blocks until window is closed</p> <p>Create multiple views and run:     &gt;&gt;&gt; canvas = snx.Canvas(views=[snx.View(), snx.View()])     &gt;&gt;&gt; canvas.visible = True     &gt;&gt;&gt; snx.run()</p> Notes <ul> <li>This function blocks execution until all visualization windows are closed</li> <li>Not needed in Jupyter notebooks or other interactive environments</li> <li>Must be called after <code>show()</code> has been used to create visualizations</li> <li>The event loop handles user interactions like pan, zoom, and picking</li> </ul> Source code in <code>src/scenex/adaptors/_auto.py</code> <pre><code>def run() -&gt; None:\n    \"\"\"Start the GUI event loop to display interactive visualizations.\n\n    This function enters the native event loop of the graphics backend, allowing\n    interactive visualizations to respond to user input (mouse, keyboard) and remain\n    visible. The function blocks until the visualization window is closed.\n\n    Call this function after creating and showing your visualizations with `show()`.\n    It is only needed for desktop applications; in Jupyter notebooks, visualizations\n    are displayed automatically without calling `run()`.\n\n    Examples\n    --------\n    Basic usage with a scene:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import scenex as snx\n        &gt;&gt;&gt; scene = snx.Scene(\n        ...     children=[snx.Image(data=np.random.rand(100, 100).astype(np.float32))]\n        ... )\n        &gt;&gt;&gt; snx.show(scene)\n        Canvas(...)\n        &gt;&gt;&gt; snx.run()  # Blocks until window is closed\n\n    Create multiple views and run:\n        &gt;&gt;&gt; canvas = snx.Canvas(views=[snx.View(), snx.View()])\n        &gt;&gt;&gt; canvas.visible = True\n        &gt;&gt;&gt; snx.run()\n\n    Notes\n    -----\n    - This function blocks execution until all visualization windows are closed\n    - Not needed in Jupyter notebooks or other interactive environments\n    - Must be called after `show()` has been used to create visualizations\n    - The event loop handles user interactions like pan, zoom, and picking\n    \"\"\"\n    app().run()\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.use","title":"use","text":"<pre><code>use(backend: KnownBackend | None = None) -&gt; None\n</code></pre> <p>Set the graphics backend for rendering scenex visualizations.</p> <p>This function allows you to explicitly select which graphics library (backend) scenex should use for rendering. It is the goal of scenex to support the full range of model API for each backend.</p> <p>If not called, scenex will automatically select an arbitrary available backend. You can also set the backend via the SCENEX_CANVAS_BACKEND environment variable.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the specified backend is not one of the known backends.</p> </li> </ul> <p>Examples:</p> <p>Use pygfx backend explicitly:     &gt;&gt;&gt; import scenex as snx     &gt;&gt;&gt; snx.use(\"pygfx\")  # doctest: +SKIP     &gt;&gt;&gt; canvas = snx.show(snx.View())</p> <p>Use vispy backend:     &gt;&gt;&gt; snx.use(\"vispy\")  # doctest: +SKIP     &gt;&gt;&gt; canvas = snx.show(snx.Scene())</p> <p>Reset to auto-detection:     &gt;&gt;&gt; snx.use(None)</p> Notes <p>The backend selection follows this priority order: 1. Backend specified by this function 2. SCENEX_CANVAS_BACKEND environment variable 3. Auto-detection (pygfx preferred, then vispy)</p> <p>This function should be called before creating any visualizations.</p> Source code in <code>src/scenex/adaptors/_auto.py</code> <pre><code>def use(backend: KnownBackend | None = None) -&gt; None:\n    \"\"\"Set the graphics backend for rendering scenex visualizations.\n\n    This function allows you to explicitly select which graphics library (backend)\n    scenex should use for rendering. It is the goal of scenex to support the full range\n    of model API for each backend.\n\n    If not called, scenex will automatically select an arbitrary available backend. You\n    can also set the backend via the SCENEX_CANVAS_BACKEND environment variable.\n\n    Parameters\n    ----------\n    backend : Literal[\"pygfx\", \"vispy\"] | None\n        The graphics backend to use:\n        - \"pygfx\": Modern WebGPU-based renderer with advanced features\n        - \"vispy\": OpenGL-based renderer with broad compatibility\n        - None: Reset to auto-detection\n\n    Raises\n    ------\n    ValueError\n        If the specified backend is not one of the known backends.\n\n    Examples\n    --------\n    Use pygfx backend explicitly:\n        &gt;&gt;&gt; import scenex as snx\n        &gt;&gt;&gt; snx.use(\"pygfx\")  # doctest: +SKIP\n        &gt;&gt;&gt; canvas = snx.show(snx.View())\n\n    Use vispy backend:\n        &gt;&gt;&gt; snx.use(\"vispy\")  # doctest: +SKIP\n        &gt;&gt;&gt; canvas = snx.show(snx.Scene())\n\n    Reset to auto-detection:\n        &gt;&gt;&gt; snx.use(None)\n\n    Notes\n    -----\n    The backend selection follows this priority order:\n    1. Backend specified by this function\n    2. SCENEX_CANVAS_BACKEND environment variable\n    3. Auto-detection (pygfx preferred, then vispy)\n\n    This function should be called before creating any visualizations.\n    \"\"\"\n    global _USE\n    if backend is None or _ensure_valid_backend(backend):\n        _USE = backend\n</code></pre>"},{"location":"reference/scenex/adaptors/#scenex.adaptors.use(backend)","title":"<code>backend</code>","text":"(<code>Literal['pygfx', 'vispy'] | None</code>, default:                   <code>None</code> )           \u2013            <p>The graphics backend to use: - \"pygfx\": Modern WebGPU-based renderer with advanced features - \"vispy\": OpenGL-based renderer with broad compatibility - None: Reset to auto-detection</p>"},{"location":"reference/scenex/app/","title":"app","text":""},{"location":"reference/scenex/app/#scenex.app","title":"scenex.app","text":"<p>Application and GUI framework abstraction layer.</p> <p>This module provides a unified interface for managing GUI applications across different frameworks (Qt, WxPython, Jupyter) and rendering backends. It handles the event loop, window creation, and platform-specific details, allowing scenex to work seamlessly across desktop and web environments.</p> <p>The app abstraction decouples scenex from specific GUI frameworks, making it possible to switch between Qt widgets, WxPython windows, or Jupyter notebook outputs without changing your visualization code.</p> Main Components <ul> <li>App: Abstract base class for GUI applications</li> <li>GuiFrontend: Enumeration of supported GUI frameworks (Qt, WxPython, Jupyter)</li> <li>app(): Factory function that returns the active application instance</li> <li>determine_app(): Auto-detect which GUI framework to use</li> </ul> Supported Frontends <p>Qt (PyQt6, PySide6) WxPython Jupyter</p> Usage <p>The app is typically created automatically by <code>scenex.show()</code> and/or <code>scenex.run()</code>::</p> <pre><code>&gt;&gt;&gt; import scenex as snx\n&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; # Create a scenex scene\n&gt;&gt;&gt; my_array = np.random.rand(100, 100).astype(np.float32)\n&gt;&gt;&gt; my_scene = snx.Scene(children=[snx.Image(data=my_array)])\n\n&gt;&gt;&gt; # Showing the scene creates the app if needed\n&gt;&gt;&gt; snx.show(my_scene)\nCanvas(...)\n&gt;&gt;&gt; snx.run()  # Starts the event loop\n</code></pre> <p>But it CAN be useful to access the app instance directly. For example, it can be useful to ask the app to process any pending events::</p> <pre><code>&gt;&gt;&gt; from scenex.app import app\n\n&gt;&gt;&gt; app().process_events()\n</code></pre> Notes <p>This module is designed to be cleanly extractable to a separate library if needed. It fully encapsulates GUI framework logic and event loop management.</p> See Also <p>scenex.run : Convenience function to start the event loop scenex.show : Creates and displays visualizations</p> <p>Modules:</p> <ul> <li> <code>events</code>           \u2013            <p>Event system for handling user input and interaction.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>App</code>           \u2013            <p>Base class for GUI application wrappers.</p> </li> <li> <code>CursorType</code>           \u2013            <p>Enumeration of standard cursor types for canvas interaction.</p> </li> <li> <code>GuiFrontend</code>           \u2013            <p>Enum of available GUI frontends.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>app</code>             \u2013              <p>Get the active GUI application instance.</p> </li> <li> <code>determine_app</code>             \u2013              <p>Determine which GUI backend to use for the application.</p> </li> <li> <code>ensure_main_thread</code>             \u2013              <p>Decorator that ensures a function is called in the main GUI thread.</p> </li> </ul>"},{"location":"reference/scenex/app/#scenex.app.App","title":"App","text":"<p>Base class for GUI application wrappers.</p> <p>App provides an abstract interface for integrating scenex with different GUI frameworks (Qt, WxPython, Jupyter). Each GUI backend implements this interface to provide framework-specific application lifecycle management, event handling, and threading operations.</p> <p>The App class is typically accessed via the <code>app()</code> function, which automatically determines and initializes the appropriate backend based on the environment and available GUI frameworks.</p> Notes <p>This is an abstract base class. Concrete implementations are provided by backend-specific subclasses (QtAppWrap, WxAppWrap, JupyterAppWrap).</p> See Also <p>app : Function to get the active application instance GuiFrontend : Enumeration of available GUI backends determine_app : Function to determine which GUI backend to use</p> <p>Methods:</p> <ul> <li> <code>call_in_main_thread</code>             \u2013              <p>Schedule a function to be called in the main GUI thread.</p> </li> <li> <code>call_later</code>             \u2013              <p>Schedule a function to be called after a delay.</p> </li> <li> <code>create_app</code>             \u2013              <p>Create the application instance, if not already created.</p> </li> <li> <code>get_executor</code>             \u2013              <p>Return an executor for running tasks in background threads.</p> </li> <li> <code>install_event_filter</code>             \u2013              <p>Install an event filter on a canvas to forward events to the model.</p> </li> <li> <code>process_events</code>             \u2013              <p>Yields the current thread to process all pending GUI events.</p> </li> <li> <code>run</code>             \u2013              <p>Start the application event loop.</p> </li> <li> <code>set_cursor</code>             \u2013              <p>Set the cursor for the given canvas.</p> </li> <li> <code>show</code>             \u2013              <p>Show or hide a canvas window.</p> </li> </ul>"},{"location":"reference/scenex/app/#scenex.app.App.call_in_main_thread","title":"call_in_main_thread","text":"<pre><code>call_in_main_thread(\n    func: Callable[P, T], *args: args, **kwargs: kwargs\n) -&gt; Future[T]\n</code></pre> <p>Schedule a function to be called in the main GUI thread.</p> <p>Many GUI frameworks require that widget operations occur on the main thread. This method safely schedules a function call on the main thread and returns a Future that will contain the result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Future[T]</code>           \u2013            <p>A Future object that will contain the function's return value once the call completes.</p> </li> </ul> Notes <p>The base implementation executes the function immediately and returns a completed Future. Subclasses should override this to provide thread-safe execution.</p> Source code in <code>src/scenex/app/_auto.py</code> <pre><code>def call_in_main_thread(\n    self, func: Callable[P, T], *args: P.args, **kwargs: P.kwargs\n) -&gt; Future[T]:\n    \"\"\"Schedule a function to be called in the main GUI thread.\n\n    Many GUI frameworks require that widget operations occur on the main\n    thread. This method safely schedules a function call on the main thread\n    and returns a Future that will contain the result.\n\n    Parameters\n    ----------\n    func : Callable[P, T]\n        The function to call.\n    *args : P.args\n        Positional arguments to pass to func.\n    **kwargs : P.kwargs\n        Keyword arguments to pass to func.\n\n    Returns\n    -------\n    Future[T]\n        A Future object that will contain the function's return value once\n        the call completes.\n\n    Notes\n    -----\n    The base implementation executes the function immediately and returns\n    a completed Future. Subclasses should override this to provide\n    thread-safe execution.\n    \"\"\"\n    future: Future[T] = Future()\n    future.set_result(func(*args, **kwargs))\n    return future\n</code></pre>"},{"location":"reference/scenex/app/#scenex.app.App.call_in_main_thread(func)","title":"<code>func</code>","text":"(<code>Callable[P, T]</code>)           \u2013            <p>The function to call.</p>"},{"location":"reference/scenex/app/#scenex.app.App.call_in_main_thread(*args)","title":"<code>*args</code>","text":"(<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to func.</p>"},{"location":"reference/scenex/app/#scenex.app.App.call_in_main_thread(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to func.</p>"},{"location":"reference/scenex/app/#scenex.app.App.call_later","title":"call_later","text":"<pre><code>call_later(msec: int, func: Callable[[], None]) -&gt; None\n</code></pre> <p>Schedule a function to be called after a delay.</p> <p>Parameters:</p> Notes <p>Must be implemented by subclasses.</p> Source code in <code>src/scenex/app/_auto.py</code> <pre><code>def call_later(self, msec: int, func: Callable[[], None]) -&gt; None:\n    \"\"\"Schedule a function to be called after a delay.\n\n    Parameters\n    ----------\n    msec : int\n        Delay in milliseconds before calling the function.\n    func : Callable[[], None]\n        The function to call. Must take no arguments.\n\n    Notes\n    -----\n    Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"Must be implemented by subclasses.\")\n</code></pre>"},{"location":"reference/scenex/app/#scenex.app.App.call_later(msec)","title":"<code>msec</code>","text":"(<code>int</code>)           \u2013            <p>Delay in milliseconds before calling the function.</p>"},{"location":"reference/scenex/app/#scenex.app.App.call_later(func)","title":"<code>func</code>","text":"(<code>Callable[[], None]</code>)           \u2013            <p>The function to call. Must take no arguments.</p>"},{"location":"reference/scenex/app/#scenex.app.App.create_app","title":"create_app","text":"<pre><code>create_app() -&gt; Any\n</code></pre> <p>Create the application instance, if not already created.</p> <p>This method initializes the underlying GUI framework's application object (e.g., QApplication for Qt). If an application instance already exists, this method should return the existing instance.</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The backend-specific application object.</p> </li> </ul> Notes <p>Must be implemented by subclasses.</p> Source code in <code>src/scenex/app/_auto.py</code> <pre><code>def create_app(self) -&gt; Any:\n    \"\"\"Create the application instance, if not already created.\n\n    This method initializes the underlying GUI framework's application object\n    (e.g., QApplication for Qt). If an application instance already exists,\n    this method should return the existing instance.\n\n    Returns\n    -------\n    Any\n        The backend-specific application object.\n\n    Notes\n    -----\n    Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"Must be implemented by subclasses.\")\n</code></pre>"},{"location":"reference/scenex/app/#scenex.app.App.get_executor","title":"get_executor","text":"<pre><code>get_executor() -&gt; Executor\n</code></pre> <p>Return an executor for running tasks in background threads.</p> <p>Returns:</p> <ul> <li> <code>Executor</code>           \u2013            <p>A concurrent.futures.Executor instance (typically a ThreadPoolExecutor) for running background tasks.</p> </li> </ul> Notes <p>The default implementation returns a shared ThreadPoolExecutor with 2 workers. Subclasses can override this to provide framework-specific executors.</p> Source code in <code>src/scenex/app/_auto.py</code> <pre><code>def get_executor(self) -&gt; Executor:\n    \"\"\"Return an executor for running tasks in background threads.\n\n    Returns\n    -------\n    Executor\n        A concurrent.futures.Executor instance (typically a ThreadPoolExecutor)\n        for running background tasks.\n\n    Notes\n    -----\n    The default implementation returns a shared ThreadPoolExecutor with 2\n    workers. Subclasses can override this to provide framework-specific\n    executors.\n    \"\"\"\n    return _thread_pool_executor()\n</code></pre>"},{"location":"reference/scenex/app/#scenex.app.App.install_event_filter","title":"install_event_filter","text":"<pre><code>install_event_filter(\n    canvas: Any, model_canvas: Canvas\n) -&gt; EventFilter\n</code></pre> <p>Install an event filter on a canvas to forward events to the model.</p> <p>Implementations of this method will capture all events given to the native widget, translated them into scenex events, and route them to <code>model_canvas</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventFilter</code>           \u2013            <p>A handle that can be used to uninstall the event filter.</p> </li> </ul> Notes <p>Must be implemented by subclasses.</p> Source code in <code>src/scenex/app/_auto.py</code> <pre><code>def install_event_filter(self, canvas: Any, model_canvas: Canvas) -&gt; EventFilter:\n    \"\"\"Install an event filter on a canvas to forward events to the model.\n\n    Implementations of this method will capture all events given to the native\n    widget, translated them into scenex events, and route them to `model_canvas`.\n\n    Parameters\n    ----------\n    canvas : Any\n        The backend-specific native canvas widget.\n    model_canvas : Canvas\n        The scenex Canvas model that should receive events.\n\n    Returns\n    -------\n    EventFilter\n        A handle that can be used to uninstall the event filter.\n\n    Notes\n    -----\n    Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"Must be implemented by subclasses.\")\n</code></pre>"},{"location":"reference/scenex/app/#scenex.app.App.install_event_filter(canvas)","title":"<code>canvas</code>","text":"(<code>Any</code>)           \u2013            <p>The backend-specific native canvas widget.</p>"},{"location":"reference/scenex/app/#scenex.app.App.install_event_filter(model_canvas)","title":"<code>model_canvas</code>","text":"(<code>Canvas</code>)           \u2013            <p>The scenex Canvas model that should receive events.</p>"},{"location":"reference/scenex/app/#scenex.app.App.process_events","title":"process_events","text":"<pre><code>process_events() -&gt; None\n</code></pre> <p>Yields the current thread to process all pending GUI events.</p> Notes <p>Must be implemented by subclasses.</p> Source code in <code>src/scenex/app/_auto.py</code> <pre><code>def process_events(self) -&gt; None:\n    \"\"\"Yields the current thread to process all pending GUI events.\n\n    Notes\n    -----\n    Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"Must be implemented by subclasses.\")\n</code></pre>"},{"location":"reference/scenex/app/#scenex.app.App.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Start the application event loop.</p> <p>This method enters the GUI framework's main event loop, which processes user input, window events, and other GUI operations. The method blocks until the application is closed.</p> Notes <p>Must be implemented by subclasses.</p> Source code in <code>src/scenex/app/_auto.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Start the application event loop.\n\n    This method enters the GUI framework's main event loop, which processes\n    user input, window events, and other GUI operations. The method blocks\n    until the application is closed.\n\n    Notes\n    -----\n    Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"Must be implemented by subclasses.\")\n</code></pre>"},{"location":"reference/scenex/app/#scenex.app.App.set_cursor","title":"set_cursor","text":"<pre><code>set_cursor(canvas: Canvas, cursor: CursorType) -&gt; None\n</code></pre> <p>Set the cursor for the given canvas.</p> <p>Backends override this to translate the abstract cursor into native form.</p> <p>Parameters:</p> Source code in <code>src/scenex/app/_auto.py</code> <pre><code>def set_cursor(self, canvas: Canvas, cursor: CursorType) -&gt; None:\n    \"\"\"Set the cursor for the given canvas.\n\n    Backends override this to translate the abstract cursor into native form.\n\n    Parameters\n    ----------\n    canvas : Canvas\n        The canvas on which to set the cursor.\n    cursor : CursorType\n        The type of cursor to set.\n    \"\"\"\n    raise NotImplementedError(\"Must be implemented by subclasses.\")\n</code></pre>"},{"location":"reference/scenex/app/#scenex.app.App.set_cursor(canvas)","title":"<code>canvas</code>","text":"(<code>Canvas</code>)           \u2013            <p>The canvas on which to set the cursor.</p>"},{"location":"reference/scenex/app/#scenex.app.App.set_cursor(cursor)","title":"<code>cursor</code>","text":"(<code>CursorType</code>)           \u2013            <p>The type of cursor to set.</p>"},{"location":"reference/scenex/app/#scenex.app.App.show","title":"show","text":"<pre><code>show(canvas: Canvas, visible: bool) -&gt; None\n</code></pre> <p>Show or hide a canvas window.</p> <p>Parameters:</p> Notes <p>Must be implemented by subclasses.</p> Source code in <code>src/scenex/app/_auto.py</code> <pre><code>def show(self, canvas: Canvas, visible: bool) -&gt; None:\n    \"\"\"Show or hide a canvas window.\n\n    Parameters\n    ----------\n    canvas : Canvas\n        The canvas to show or hide\n    visible : bool\n        True to show the canvas window, False to hide it.\n\n    Notes\n    -----\n    Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"Must be implemented by subclasses.\")\n</code></pre>"},{"location":"reference/scenex/app/#scenex.app.App.show(canvas)","title":"<code>canvas</code>","text":"(<code>Canvas</code>)           \u2013            <p>The canvas to show or hide</p>"},{"location":"reference/scenex/app/#scenex.app.App.show(visible)","title":"<code>visible</code>","text":"(<code>bool</code>)           \u2013            <p>True to show the canvas window, False to hide it.</p>"},{"location":"reference/scenex/app/#scenex.app.CursorType","title":"CursorType","text":"<p>               Bases: <code>Enum</code></p> <pre><code>\n              flowchart TD\n              scenex.app.CursorType[CursorType]\n\n              \n\n              click scenex.app.CursorType href \"\" \"scenex.app.CursorType\"\n            </code></pre> <p>Enumeration of standard cursor types for canvas interaction.</p> <p>CursorType provides platform-independent cursor shapes that can be set on canvases to indicate different interaction modes or states. Each cursor type is mapped to the appropriate platform-specific cursor by the GUI backend.</p> <p>Attributes:</p> <ul> <li> <code>DEFAULT</code>               (<code>int</code>)           \u2013            <p>The standard arrow cursor, typically used for normal selection and interaction.</p> </li> <li> <code>CROSS</code>               (<code>int</code>)           \u2013            <p>A crosshair cursor, useful for precise positioning or drawing operations.</p> </li> <li> <code>V_ARROW</code>               (<code>int</code>)           \u2013            <p>A vertical resize arrow cursor, indicating vertical resizing capability.</p> </li> <li> <code>H_ARROW</code>               (<code>int</code>)           \u2013            <p>A horizontal resize arrow cursor, indicating horizontal resizing capability.</p> </li> <li> <code>ALL_ARROW</code>               (<code>int</code>)           \u2013            <p>A multi-directional arrow cursor, indicating omnidirectional movement.</p> </li> <li> <code>BDIAG_ARROW</code>               (<code>int</code>)           \u2013            <p>A diagonal resize arrow cursor (backward diagonal), for diagonal resizing.</p> </li> <li> <code>FDIAG_ARROW</code>               (<code>int</code>)           \u2013            <p>A diagonal resize arrow cursor (forward diagonal), for diagonal resizing.</p> </li> </ul> <p>Examples:</p> <p>Set a crosshair cursor during drawing mode:     &gt;&gt;&gt; import scenex as snx     &gt;&gt;&gt; canvas = snx.Canvas()     &gt;&gt;&gt; app().set_cursor(canvas, CursorType.CROSS)</p> <p>Restore default cursor after operation:     &gt;&gt;&gt; app().set_cursor(canvas, CursorType.DEFAULT)</p> See Also <p>App.set_cursor : Method to set cursor on a canvas</p>"},{"location":"reference/scenex/app/#scenex.app.GuiFrontend","title":"GuiFrontend","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <pre><code>\n              flowchart TD\n              scenex.app.GuiFrontend[GuiFrontend]\n\n              \n\n              click scenex.app.GuiFrontend href \"\" \"scenex.app.GuiFrontend\"\n            </code></pre> <p>Enum of available GUI frontends.</p> <p>Attributes:</p> <ul> <li> <code>JUPYTER</code>               (<code>str</code>)           \u2013            <p>JUPYTER</p> </li> <li> <code>QT</code>               (<code>str</code>)           \u2013            <p>PyQt5/PySide2/PyQt6/PySide6</p> </li> <li> <code>WX</code>               (<code>str</code>)           \u2013            <p>WX</p> </li> </ul>"},{"location":"reference/scenex/app/#scenex.app.app","title":"app","text":"<pre><code>app() -&gt; App\n</code></pre> <p>Get the active GUI application instance.</p> <p>Returns the singleton App instance for the current process, creating and initializing it if necessary. The GUI backend is determined automatically using <code>determine_app()</code>.</p> <p>This function should be used whenever you need to interact with the GUI application, such as running the event loop, showing windows, or scheduling thread-safe operations.</p> <p>Returns:</p> <ul> <li> <code>App</code>           \u2013            <p>The active App instance wrapping the GUI backend.</p> </li> </ul> <p>Examples:</p> <p>Get the app and run the event loop:     &gt;&gt;&gt; app().run()</p> See Also <p>determine_app : Function that selects which GUI backend to use GuiFrontend : Enumeration of available backends App : Base class defining the application interface</p> Source code in <code>src/scenex/app/_auto.py</code> <pre><code>def app() -&gt; App:\n    \"\"\"Get the active GUI application instance.\n\n    Returns the singleton App instance for the current process, creating and\n    initializing it if necessary. The GUI backend is determined automatically\n    using `determine_app()`.\n\n    This function should be used whenever you need to interact with the GUI\n    application, such as running the event loop, showing windows, or scheduling\n    thread-safe operations.\n\n    Returns\n    -------\n    App\n        The active App instance wrapping the GUI backend.\n\n    Examples\n    --------\n    Get the app and run the event loop:\n        &gt;&gt;&gt; app().run()\n\n    See Also\n    --------\n    determine_app : Function that selects which GUI backend to use\n    GuiFrontend : Enumeration of available backends\n    App : Base class defining the application interface\n    \"\"\"\n    global _APP\n    if _APP is not None:\n        return _APP\n\n    # ensure the app is created for explicitly requested frontends\n    _APP = _load_app(*GUI_PROVIDERS[determine_app()])\n    _APP.create_app()\n    return _APP\n</code></pre>"},{"location":"reference/scenex/app/#scenex.app.determine_app","title":"determine_app","text":"<pre><code>determine_app() -&gt; GuiFrontend\n</code></pre> <p>Determine which GUI backend to use for the application.</p> <p>This function selects the appropriate GUI framework backend through a three-tier strategy:</p> <ol> <li>Explicit request: If the SCENEX_APP_BACKEND environment variable    is set, that backend is used (e.g., \"qt\", \"wx\", \"jupyter\").</li> <li>Running application: If a GUI application is already running in the    process (detected via framework imports), that backend is used.</li> <li>Available backend: Try importing each backend in a predefined order until one    succeeds.</li> </ol> <p>Returns:</p> <ul> <li> <code>GuiFrontend</code>           \u2013            <p>The determined GUI backend to use.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the SCENEX_APP_BACKEND environment variable is set to an invalid value.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If no GUI backend can be found or loaded.</p> </li> </ul> <p>Examples:</p> <p>Let the function auto-detect the backend:     &gt;&gt;&gt; backend = determine_app()</p> <p>Force a specific backend via environment variable:     &gt;&gt;&gt; import os     &gt;&gt;&gt; os.environ[\"SCENEX_APP_BACKEND\"] = \"qt\"  # doctest: +SKIP     &gt;&gt;&gt; backend = determine_app()  # Will use Qt</p> See Also <p>app : Get the active App instance using the determined backend GuiFrontend : Enumeration of available backends</p> Source code in <code>src/scenex/app/_auto.py</code> <pre><code>def determine_app() -&gt; GuiFrontend:\n    \"\"\"Determine which GUI backend to use for the application.\n\n    This function selects the appropriate GUI framework backend through a\n    three-tier strategy:\n\n    1. **Explicit request**: If the SCENEX_APP_BACKEND environment variable\n       is set, that backend is used (e.g., \"qt\", \"wx\", \"jupyter\").\n    2. **Running application**: If a GUI application is already running in the\n       process (detected via framework imports), that backend is used.\n    3. **Available backend**: Try importing each backend in a predefined order until one\n       succeeds.\n\n    Returns\n    -------\n    GuiFrontend\n        The determined GUI backend to use.\n\n    Raises\n    ------\n    ValueError\n        If the SCENEX_APP_BACKEND environment variable is set to an invalid\n        value.\n    RuntimeError\n        If no GUI backend can be found or loaded.\n\n    Examples\n    --------\n    Let the function auto-detect the backend:\n        &gt;&gt;&gt; backend = determine_app()\n\n    Force a specific backend via environment variable:\n        &gt;&gt;&gt; import os\n        &gt;&gt;&gt; os.environ[\"SCENEX_APP_BACKEND\"] = \"qt\"  # doctest: +SKIP\n        &gt;&gt;&gt; backend = determine_app()  # Will use Qt\n\n    See Also\n    --------\n    app : Get the active App instance using the determined backend\n    GuiFrontend : Enumeration of available backends\n    \"\"\"\n    running = list(_running_apps())\n\n    # Try 1: Load a frontend explicitly requested by the user\n    requested = os.getenv(GUI_ENV_VAR, \"\").lower()\n    valid = {x.value for x in GuiFrontend}\n    if requested:\n        if requested not in valid:\n            raise ValueError(\n                f\"Invalid GUI frontend: {requested!r}. Valid options: {valid}\"\n            )\n        return GuiFrontend(requested)\n\n    # Try 2: Utilize an existing, running app\n    for key in GUI_PROVIDERS.keys():\n        if key in running:\n            return key\n\n    # Try 3: Load an existing app\n    errors: list[tuple[str, BaseException]] = []\n    for key, provider in GUI_PROVIDERS.items():\n        try:\n            _load_app(*provider)\n            return key\n        except Exception as e:\n            errors.append((key, e))\n\n    raise RuntimeError(  # pragma: no cover\n        f\"Could not find an appropriate GUI frontend: {valid!r}. Tried:\\n\\n\"\n        + \"\\n\".join(f\"- {key}: {err}\" for key, err in errors)\n    )\n</code></pre>"},{"location":"reference/scenex/app/#scenex.app.ensure_main_thread","title":"ensure_main_thread","text":"<pre><code>ensure_main_thread(\n    func: Callable[P, T],\n) -&gt; Callable[P, Future[T]]\n</code></pre> <p>Decorator that ensures a function is called in the main GUI thread.</p> <p>This decorator wraps a function so that when called, it is automatically scheduled to run on the main GUI thread rather than the caller's thread. This is essential for GUI operations that must occur on the main thread.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Callable[P, Future[T]]</code>           \u2013            <p>A wrapped version of func that returns a Future instead of the direct result. The Future will contain the function's return value once the call completes on the main thread.</p> </li> </ul> <p>Examples:</p> <p>Ensure a GUI operation runs on the main thread:     &gt;&gt;&gt; @ensure_main_thread     ... def update_widget(value: int) -&gt; None:     ...     # Update some GUI widget with the given value     ...     pass     &gt;&gt;&gt; future = update_widget(42)  # Returns immediately with Future     &gt;&gt;&gt; result = future.result()  # Block until completion if needed</p> See Also <p>App.call_in_main_thread : Underlying method for thread-safe calls</p> Source code in <code>src/scenex/app/_auto.py</code> <pre><code>def ensure_main_thread(func: Callable[P, T]) -&gt; Callable[P, Future[T]]:\n    \"\"\"Decorator that ensures a function is called in the main GUI thread.\n\n    This decorator wraps a function so that when called, it is automatically\n    scheduled to run on the main GUI thread rather than the caller's thread.\n    This is essential for GUI operations that must occur on the main thread.\n\n    Parameters\n    ----------\n    func : Callable[P, T]\n        The function to wrap. Can have any signature.\n\n    Returns\n    -------\n    Callable[P, Future[T]]\n        A wrapped version of func that returns a Future instead of the direct\n        result. The Future will contain the function's return value once the\n        call completes on the main thread.\n\n    Examples\n    --------\n    Ensure a GUI operation runs on the main thread:\n        &gt;&gt;&gt; @ensure_main_thread\n        ... def update_widget(value: int) -&gt; None:\n        ...     # Update some GUI widget with the given value\n        ...     pass\n        &gt;&gt;&gt; future = update_widget(42)  # Returns immediately with Future\n        &gt;&gt;&gt; result = future.result()  # Block until completion if needed\n\n    See Also\n    --------\n    App.call_in_main_thread : Underlying method for thread-safe calls\n    \"\"\"\n\n    @wraps(func)\n    def _wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; Future[T]:\n        return app().call_in_main_thread(func, *args, **kwargs)\n\n    return _wrapper\n</code></pre>"},{"location":"reference/scenex/app/#scenex.app.ensure_main_thread(func)","title":"<code>func</code>","text":"(<code>Callable[P, T]</code>)           \u2013            <p>The function to wrap. Can have any signature.</p>"},{"location":"reference/scenex/app/events/","title":"events","text":""},{"location":"reference/scenex/app/events/#scenex.app.events","title":"scenex.app.events","text":"<p>Event system for handling user input and interaction.</p> <p>This module provides a unified event abstraction for user interactions across different GUI frameworks and rendering backends. Events represent user actions (e.g. mouse clicks, movement, scrolling) and system events (e.g. window resize), allowing event filters, camera controllers, etc. to respond to input in a framework-agnostic way.</p> Event Types <p>Mouse Events:     - MousePressEvent: Mouse button pressed     - MouseReleaseEvent: Mouse button released     - MouseMoveEvent: Mouse cursor moved     - MouseDoublePressEvent: Mouse button double-pressed     - MouseEnterEvent: Mouse entered a view     - MouseLeaveEvent: Mouse left a view     - WheelEvent: Mouse wheel scrolled</p> <p>System Events:     - ResizeEvent: Canvas window resized</p> Event Flow <p>Events are dispatched by the canvas to views and their camera controllers::</p> <pre><code>Canvas \u2192 View (filter_event) \u2192 Camera Controller (handle_event)\n</code></pre> <p>The flow works as follows: 1. Canvas determines which view contains the cursor position 2. Canvas calls the view's filter_event() method with the event 3. If the view's camera is interactive, the camera controller's handle_event()    is called 4. Handlers return True to stop propagation or False to continue</p> Key Concepts <p>Ray: 3D ray in world space representing the mouse position     - Used for 3D picking and intersection tests     - Computed from 2D canvas position via camera unprojection</p> <p>MouseButton: Enumeration of mouse buttons (LEFT, RIGHT, MIDDLE, etc.)</p> <p>Examples:</p> <p>Set a custom event filter on a view::</p> <pre><code>from scenex.model import View\nfrom scenex.app.events import MousePressEvent\n\n\ndef on_click(event):\n    if isinstance(event, MousePressEvent):\n        print(f\"Clicked at {event.canvas_pos}\")\n        return True  # Event handled\n    return False\n\n\nview = View(scene=my_scene, camera=my_camera)\nview.set_event_filter(on_click)\n</code></pre> See Also <p>scenex.model.Camera : Camera with interactive interaction strategies scenex.model.View : View with event filter support</p> <p>Classes:</p> <ul> <li> <code>Event</code>           \u2013            <p>Base class for all user interaction and system events.</p> </li> <li> <code>EventFilter</code>           \u2013            <p>Base class for event filter handles.</p> </li> <li> <code>MouseButton</code>           \u2013            <p>Enumeration of mouse button states as bit flags.</p> </li> <li> <code>MouseDoublePressEvent</code>           \u2013            <p>Mouse button double-click.</p> </li> <li> <code>MouseEnterEvent</code>           \u2013            <p>Mouse cursor entering the view area.</p> </li> <li> <code>MouseEvent</code>           \u2013            <p>Base class for all mouse-related interaction events.</p> </li> <li> <code>MouseLeaveEvent</code>           \u2013            <p>Mouse cursor leaving the view area.</p> </li> <li> <code>MouseMoveEvent</code>           \u2013            <p>Mouse cursor movement within the view.</p> </li> <li> <code>MousePressEvent</code>           \u2013            <p>Mouse button press.</p> </li> <li> <code>MouseReleaseEvent</code>           \u2013            <p>Mouse button release.</p> </li> <li> <code>Ray</code>           \u2013            <p>A 3D ray in world space representing a mouse position.</p> </li> <li> <code>ResizeEvent</code>           \u2013            <p>Canvas window resize event.</p> </li> <li> <code>WheelEvent</code>           \u2013            <p>Mouse wheel scroll event.</p> </li> </ul>"},{"location":"reference/scenex/app/events/#scenex.app.events.Event","title":"Event  <code>dataclass</code>","text":"<pre><code>Event()\n</code></pre> <p>Base class for all user interaction and system events.</p> <p>Event is the root of the event hierarchy in scenex. All specific event types (mouse, keyboard, resize) inherit from this base class, enabling polymorphic event handling and extensibility for custom event types.</p> <p>The inheritance-based design allows: - Type checking with isinstance() to discriminate event types - Extensibility for adding new event types downstream - Structured event filtering based on event class hierarchy</p> See Also <p>MouseEvent : Base class for mouse-related events ResizeEvent : Window resize event</p>"},{"location":"reference/scenex/app/events/#scenex.app.events.EventFilter","title":"EventFilter","text":"<p>Base class for event filter handles.</p> <p>EventFilter instances are returned when installing event filters on views or canvases. They provide a mechanism to uninstall the filter when it's no longer needed, ensuring proper cleanup and preventing memory leaks.</p> <p>Methods:</p> <ul> <li> <code>uninstall</code>             \u2013              <p>Remove this event filter.</p> </li> </ul>"},{"location":"reference/scenex/app/events/#scenex.app.events.EventFilter.uninstall","title":"uninstall","text":"<pre><code>uninstall() -&gt; None\n</code></pre> <p>Remove this event filter.</p> <p>Uninstalls the event filter, ensuring that the filter function will no longer be called for future events. After calling uninstall(), this EventFilter instance should not be used further.</p> Source code in <code>src/scenex/app/events/_events.py</code> <pre><code>def uninstall(self) -&gt; None:\n    \"\"\"Remove this event filter.\n\n    Uninstalls the event filter, ensuring that the filter function will no\n    longer be called for future events. After calling uninstall(), this\n    EventFilter instance should not be used further.\n    \"\"\"\n    raise NotImplementedError(\"This method should be implemented by subclasses.\")\n</code></pre>"},{"location":"reference/scenex/app/events/#scenex.app.events.MouseButton","title":"MouseButton","text":"<p>               Bases: <code>IntFlag</code></p> <pre><code>\n              flowchart TD\n              scenex.app.events.MouseButton[MouseButton]\n\n              \n\n              click scenex.app.events.MouseButton href \"\" \"scenex.app.events.MouseButton\"\n            </code></pre> <p>Enumeration of mouse button states as bit flags.</p> <p>MouseButton uses IntFlag to allow bitwise operations, enabling representation of multiple simultaneous button presses.</p> <p>Examples:</p> <p>Check if left button is pressed:     &gt;&gt;&gt; event = MousePressEvent(     ...     canvas_pos=(100, 150),     ...     world_ray=Ray(origin=(0, 0, 0), direction=(0, 0, -1), source=None),     ...     buttons=MouseButton.LEFT | MouseButton.RIGHT,     ... )     &gt;&gt;&gt; if event.buttons &amp; MouseButton.LEFT:     ...     print(\"Left button is down\")     Left button is down</p> <p>Check for specific button combination:     &gt;&gt;&gt; if event.buttons == (MouseButton.LEFT | MouseButton.RIGHT):     ...     print(\"Both left and right buttons pressed\")     Both left and right buttons pressed</p> <p>Check if any button is pressed:     &gt;&gt;&gt; if event.buttons != MouseButton.NONE:     ...     print(\"Some button is pressed\")     Some button is pressed</p>"},{"location":"reference/scenex/app/events/#scenex.app.events.MouseDoublePressEvent","title":"MouseDoublePressEvent  <code>dataclass</code>","text":"<pre><code>MouseDoublePressEvent(\n    canvas_pos: tuple[float, float],\n    world_ray: Ray,\n    buttons: MouseButton,\n)\n</code></pre> <p>               Bases: <code>MouseEvent</code></p> <pre><code>\n              flowchart TD\n              scenex.app.events.MouseDoublePressEvent[MouseDoublePressEvent]\n              scenex.app.events._events.MouseEvent[MouseEvent]\n              scenex.app.events._events.Event[Event]\n\n                              scenex.app.events._events.MouseEvent --&gt; scenex.app.events.MouseDoublePressEvent\n                                scenex.app.events._events.Event --&gt; scenex.app.events._events.MouseEvent\n                \n\n\n\n              click scenex.app.events.MouseDoublePressEvent href \"\" \"scenex.app.events.MouseDoublePressEvent\"\n              click scenex.app.events._events.MouseEvent href \"\" \"scenex.app.events._events.MouseEvent\"\n              click scenex.app.events._events.Event href \"\" \"scenex.app.events._events.Event\"\n            </code></pre> <p>Mouse button double-click.</p> <p>Fired when a mouse button is double-clicked (pressed twice in rapid succession). The timing threshold for double-click detection is system-dependent.</p> See Also <p>MousePressEvent : Single mouse button press</p>"},{"location":"reference/scenex/app/events/#scenex.app.events.MouseEnterEvent","title":"MouseEnterEvent  <code>dataclass</code>","text":"<pre><code>MouseEnterEvent(\n    canvas_pos: tuple[float, float],\n    world_ray: Ray,\n    buttons: MouseButton,\n)\n</code></pre> <p>               Bases: <code>MouseEvent</code></p> <pre><code>\n              flowchart TD\n              scenex.app.events.MouseEnterEvent[MouseEnterEvent]\n              scenex.app.events._events.MouseEvent[MouseEvent]\n              scenex.app.events._events.Event[Event]\n\n                              scenex.app.events._events.MouseEvent --&gt; scenex.app.events.MouseEnterEvent\n                                scenex.app.events._events.Event --&gt; scenex.app.events._events.MouseEvent\n                \n\n\n\n              click scenex.app.events.MouseEnterEvent href \"\" \"scenex.app.events.MouseEnterEvent\"\n              click scenex.app.events._events.MouseEvent href \"\" \"scenex.app.events._events.MouseEvent\"\n              click scenex.app.events._events.Event href \"\" \"scenex.app.events._events.Event\"\n            </code></pre> <p>Mouse cursor entering the view area.</p> <p>Fired when the mouse cursor enters the bounds of a view from outside. Includes the entry position and button states.</p> See Also <p>MouseLeaveEvent : Mouse cursor leaving the view</p>"},{"location":"reference/scenex/app/events/#scenex.app.events.MouseEvent","title":"MouseEvent  <code>dataclass</code>","text":"<pre><code>MouseEvent(\n    canvas_pos: tuple[float, float],\n    world_ray: Ray,\n    buttons: MouseButton,\n)\n</code></pre> <p>               Bases: <code>Event</code></p> <pre><code>\n              flowchart TD\n              scenex.app.events.MouseEvent[MouseEvent]\n              scenex.app.events._events.Event[Event]\n\n                              scenex.app.events._events.Event --&gt; scenex.app.events.MouseEvent\n                \n\n\n              click scenex.app.events.MouseEvent href \"\" \"scenex.app.events.MouseEvent\"\n              click scenex.app.events._events.Event href \"\" \"scenex.app.events._events.Event\"\n            </code></pre> <p>Base class for all mouse-related interaction events.</p> <p>MouseEvent provides common fields for all mouse interactions, including the 2D canvas position, the 3D world ray for picking, and the state of mouse buttons. Specific mouse event types (move, press, release, etc.) inherit from this base.</p> <p>Attributes:</p> <ul> <li> <code>canvas_pos</code>               (<code>tuple[float, float]</code>)           \u2013            <p>The (x, y) position of the mouse cursor in canvas pixel coordinates, with origin at the top-left corner.</p> </li> <li> <code>world_ray</code>               (<code>Ray</code>)           \u2013            <p>The 3D ray in world space corresponding to this mouse position, used for 3D picking and intersection testing. The ray passes from the camera through the cursor position.</p> </li> <li> <code>buttons</code>               (<code>MouseButton</code>)           \u2013            <p>Bit flags indicating which mouse buttons are currently pressed. Use bitwise operations to test button states (e.g., buttons &amp; MouseButton.LEFT).</p> </li> </ul> See Also <p>MouseMoveEvent : Mouse cursor movement MousePressEvent : Mouse button press MouseReleaseEvent : Mouse button release WheelEvent : Mouse wheel scroll Ray : 3D ray for picking</p>"},{"location":"reference/scenex/app/events/#scenex.app.events.MouseLeaveEvent","title":"MouseLeaveEvent  <code>dataclass</code>","text":"<pre><code>MouseLeaveEvent()\n</code></pre> <p>               Bases: <code>Event</code></p> <pre><code>\n              flowchart TD\n              scenex.app.events.MouseLeaveEvent[MouseLeaveEvent]\n              scenex.app.events._events.Event[Event]\n\n                              scenex.app.events._events.Event --&gt; scenex.app.events.MouseLeaveEvent\n                \n\n\n              click scenex.app.events.MouseLeaveEvent href \"\" \"scenex.app.events.MouseLeaveEvent\"\n              click scenex.app.events._events.Event href \"\" \"scenex.app.events._events.Event\"\n            </code></pre> <p>Mouse cursor leaving the view area.</p> <p>Fired when the mouse cursor exits the bounds of a view. This is distinct from other mouse events in that it does not include position or button information, as the cursor is no longer over the view.</p> <p>Note that this does not inherit from MouseEvent, as no position or buttons are available when the cursor has left the view.</p> See Also <p>MouseEnterEvent : Mouse cursor entering the view</p>"},{"location":"reference/scenex/app/events/#scenex.app.events.MouseMoveEvent","title":"MouseMoveEvent  <code>dataclass</code>","text":"<pre><code>MouseMoveEvent(\n    canvas_pos: tuple[float, float],\n    world_ray: Ray,\n    buttons: MouseButton,\n)\n</code></pre> <p>               Bases: <code>MouseEvent</code></p> <pre><code>\n              flowchart TD\n              scenex.app.events.MouseMoveEvent[MouseMoveEvent]\n              scenex.app.events._events.MouseEvent[MouseEvent]\n              scenex.app.events._events.Event[Event]\n\n                              scenex.app.events._events.MouseEvent --&gt; scenex.app.events.MouseMoveEvent\n                                scenex.app.events._events.Event --&gt; scenex.app.events._events.MouseEvent\n                \n\n\n\n              click scenex.app.events.MouseMoveEvent href \"\" \"scenex.app.events.MouseMoveEvent\"\n              click scenex.app.events._events.MouseEvent href \"\" \"scenex.app.events._events.MouseEvent\"\n              click scenex.app.events._events.Event href \"\" \"scenex.app.events._events.Event\"\n            </code></pre> <p>Mouse cursor movement within the view.</p> <p>Fired when the mouse cursor moves within the view bounds. Includes the current position, world ray, and button states. This event fires continuously during cursor movement.</p>"},{"location":"reference/scenex/app/events/#scenex.app.events.MousePressEvent","title":"MousePressEvent  <code>dataclass</code>","text":"<pre><code>MousePressEvent(\n    canvas_pos: tuple[float, float],\n    world_ray: Ray,\n    buttons: MouseButton,\n)\n</code></pre> <p>               Bases: <code>MouseEvent</code></p> <pre><code>\n              flowchart TD\n              scenex.app.events.MousePressEvent[MousePressEvent]\n              scenex.app.events._events.MouseEvent[MouseEvent]\n              scenex.app.events._events.Event[Event]\n\n                              scenex.app.events._events.MouseEvent --&gt; scenex.app.events.MousePressEvent\n                                scenex.app.events._events.Event --&gt; scenex.app.events._events.MouseEvent\n                \n\n\n\n              click scenex.app.events.MousePressEvent href \"\" \"scenex.app.events.MousePressEvent\"\n              click scenex.app.events._events.MouseEvent href \"\" \"scenex.app.events._events.MouseEvent\"\n              click scenex.app.events._events.Event href \"\" \"scenex.app.events._events.Event\"\n            </code></pre> <p>Mouse button press.</p> <p>Fired when a mouse button is pressed down. The buttons field indicates which button(s) are now pressed. For detecting which button was newly pressed, compare with previous button states.</p> See Also <p>MouseReleaseEvent : Mouse button release MouseDoublePressEvent : Double-click detection</p>"},{"location":"reference/scenex/app/events/#scenex.app.events.MouseReleaseEvent","title":"MouseReleaseEvent  <code>dataclass</code>","text":"<pre><code>MouseReleaseEvent(\n    canvas_pos: tuple[float, float],\n    world_ray: Ray,\n    buttons: MouseButton,\n)\n</code></pre> <p>               Bases: <code>MouseEvent</code></p> <pre><code>\n              flowchart TD\n              scenex.app.events.MouseReleaseEvent[MouseReleaseEvent]\n              scenex.app.events._events.MouseEvent[MouseEvent]\n              scenex.app.events._events.Event[Event]\n\n                              scenex.app.events._events.MouseEvent --&gt; scenex.app.events.MouseReleaseEvent\n                                scenex.app.events._events.Event --&gt; scenex.app.events._events.MouseEvent\n                \n\n\n\n              click scenex.app.events.MouseReleaseEvent href \"\" \"scenex.app.events.MouseReleaseEvent\"\n              click scenex.app.events._events.MouseEvent href \"\" \"scenex.app.events._events.MouseEvent\"\n              click scenex.app.events._events.Event href \"\" \"scenex.app.events._events.Event\"\n            </code></pre> <p>Mouse button release.</p> <p>Fired when a mouse button is released. The buttons field reflects the state after the release (i.e., the released button is no longer set in the flags).</p> See Also <p>MousePressEvent : Mouse button press</p>"},{"location":"reference/scenex/app/events/#scenex.app.events.Ray","title":"Ray","text":"<p>               Bases: <code>NamedTuple</code></p> <pre><code>\n              flowchart TD\n              scenex.app.events.Ray[Ray]\n\n              \n\n              click scenex.app.events.Ray href \"\" \"scenex.app.events.Ray\"\n            </code></pre> <p>A 3D ray in world space representing a mouse position.</p> <p>A Ray represents the path of the mouse cursor projected into 3D world space, starting from the camera and passing through the cursor position on the view. Rays are the fundamental mechanism for 3D picking and intersection testing, allowing determination of which scene objects are under the mouse cursor.</p> <p>The ray is defined by an origin point (typically the camera position) and a normalized direction vector. All MouseEvent instances include a world_ray that can be used to test intersections with scene geometry.</p> <p>Attributes:</p> <ul> <li> <code>origin</code>               (<code>tuple[float, float, float]</code>)           \u2013            <p>The starting point of the ray in world coordinates, typically the camera position for perspective projections or a point on the view plane for orthographic projections.</p> </li> <li> <code>direction</code>               (<code>tuple[float, float, float]</code>)           \u2013            <p>The normalized direction vector of the ray in world coordinates. For perspective views, this points from the camera through the cursor. For orthographic views, this is parallel to the camera's view direction.</p> </li> <li> <code>source</code>               (<code>View</code>)           \u2013            <p>The view that generated this ray, providing context for which camera and scene the ray originated from.</p> </li> </ul> <p>Examples:</p> <p>Find all intersections with a scene:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; import scenex as snx     &gt;&gt;&gt; view = snx.View(     ...     scene=snx.Scene(     ...         children=[     ...             snx.Image(data=np.random.rand(100, 100)),     ...             snx.Points(     ...                 vertices=np.asarray([[0, 0, 0], [1, 1, 0]]),     ...                 size=5,     ...                 edge_width=0,     ...             ),     ...         ]     ...     )     ... )     &gt;&gt;&gt; ray = Ray(origin=(1, 1, 10), direction=(0, 0, -1), source=view)     &gt;&gt;&gt; ray.intersections(view.scene)     [(Points(...), 7.5), (Image(...), 10.0)]</p> See Also <p>MouseEvent : Events that include world_ray Node.passes_through : Node method for computing ray intersections</p> <p>Methods:</p> <ul> <li> <code>intersections</code>             \u2013              <p>Find all nodes intersected by this ray in the scene graph.</p> </li> <li> <code>point_at_distance</code>             \u2013              <p>Compute the 3D point at a given distance along the ray.</p> </li> </ul>"},{"location":"reference/scenex/app/events/#scenex.app.events.Ray.intersections","title":"intersections","text":"<pre><code>intersections(graph: Node) -&gt; list[Intersection]\n</code></pre> <p>Find all nodes intersected by this ray in the scene graph.</p> <p>Recursively tests the ray against the given node and all its descendants, returning all intersections sorted by distance from the ray origin. Only visible nodes are tested.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Intersection]</code>           \u2013            <p>List of (node, distance) tuples for all intersections, sorted by increasing distance from the ray origin. The distance is the parameter t where intersection occurs at origin + t * direction.</p> </li> </ul> Source code in <code>src/scenex/app/events/_events.py</code> <pre><code>def intersections(self, graph: Node) -&gt; list[Intersection]:\n    \"\"\"Find all nodes intersected by this ray in the scene graph.\n\n    Recursively tests the ray against the given node and all its descendants,\n    returning all intersections sorted by distance from the ray origin. Only\n    visible nodes are tested.\n\n    Parameters\n    ----------\n    graph : Node\n        The root node to test. Typically a Scene, but can be any node with\n        children.\n\n    Returns\n    -------\n    list[Intersection]\n        List of (node, distance) tuples for all intersections, sorted by\n        increasing distance from the ray origin. The distance is the parameter\n        t where intersection occurs at origin + t * direction.\n    \"\"\"\n    through: list[Intersection] = []\n    if graph.visible:\n        # ...check the node itself...\n        if (d := graph.passes_through(self)) is not None:\n            through.append((graph, d))\n        # ...then check its children...\n        for child in graph.children:\n            through.extend(self.intersections(child))\n    return sorted(through, key=lambda inter: inter[1])\n</code></pre>"},{"location":"reference/scenex/app/events/#scenex.app.events.Ray.intersections(graph)","title":"<code>graph</code>","text":"(<code>Node</code>)           \u2013            <p>The root node to test. Typically a Scene, but can be any node with children.</p>"},{"location":"reference/scenex/app/events/#scenex.app.events.Ray.point_at_distance","title":"point_at_distance","text":"<pre><code>point_at_distance(\n    distance: float,\n) -&gt; tuple[float, float, float]\n</code></pre> <p>Compute the 3D point at a given distance along the ray.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[float, float, float]</code>           \u2013            <p>The (x, y, z) coordinates of the point at the specified distance along the ray.</p> </li> </ul> Source code in <code>src/scenex/app/events/_events.py</code> <pre><code>def point_at_distance(self, distance: float) -&gt; tuple[float, float, float]:\n    \"\"\"Compute the 3D point at a given distance along the ray.\n\n    Parameters\n    ----------\n    distance : float\n        The distance along the ray from the origin. Positive values extend\n        in the direction of the ray, negative values extend backward from\n        the origin.\n\n    Returns\n    -------\n    tuple[float, float, float]\n        The (x, y, z) coordinates of the point at the specified distance\n        along the ray.\n    \"\"\"\n    x = self.origin[0] + self.direction[0] * distance\n    y = self.origin[1] + self.direction[1] * distance\n    z = self.origin[2] + self.direction[2] * distance\n    return (x, y, z)\n</code></pre>"},{"location":"reference/scenex/app/events/#scenex.app.events.Ray.point_at_distance(distance)","title":"<code>distance</code>","text":"(<code>float</code>)           \u2013            <p>The distance along the ray from the origin. Positive values extend in the direction of the ray, negative values extend backward from the origin.</p>"},{"location":"reference/scenex/app/events/#scenex.app.events.ResizeEvent","title":"ResizeEvent  <code>dataclass</code>","text":"<pre><code>ResizeEvent(width: int, height: int)\n</code></pre> <p>               Bases: <code>Event</code></p> <pre><code>\n              flowchart TD\n              scenex.app.events.ResizeEvent[ResizeEvent]\n              scenex.app.events._events.Event[Event]\n\n                              scenex.app.events._events.Event --&gt; scenex.app.events.ResizeEvent\n                \n\n\n              click scenex.app.events.ResizeEvent href \"\" \"scenex.app.events.ResizeEvent\"\n              click scenex.app.events._events.Event href \"\" \"scenex.app.events._events.Event\"\n            </code></pre> <p>Canvas window resize event.</p> <p>Fired when the canvas window changes dimensions, whether from user interaction (dragging window edges), programmatic resizing, or window manager actions. This event allows views and other components to adapt to new canvas dimensions.</p> <p>Attributes:</p> <ul> <li> <code>width</code>               (<code>int</code>)           \u2013            <p>The new width of the canvas in pixels.</p> </li> <li> <code>height</code>               (<code>int</code>)           \u2013            <p>The new height of the canvas in pixels.</p> </li> </ul>"},{"location":"reference/scenex/app/events/#scenex.app.events.WheelEvent","title":"WheelEvent  <code>dataclass</code>","text":"<pre><code>WheelEvent(\n    canvas_pos: tuple[float, float],\n    world_ray: Ray,\n    buttons: MouseButton,\n    angle_delta: tuple[float, float],\n)\n</code></pre> <p>               Bases: <code>MouseEvent</code></p> <pre><code>\n              flowchart TD\n              scenex.app.events.WheelEvent[WheelEvent]\n              scenex.app.events._events.MouseEvent[MouseEvent]\n              scenex.app.events._events.Event[Event]\n\n                              scenex.app.events._events.MouseEvent --&gt; scenex.app.events.WheelEvent\n                                scenex.app.events._events.Event --&gt; scenex.app.events._events.MouseEvent\n                \n\n\n\n              click scenex.app.events.WheelEvent href \"\" \"scenex.app.events.WheelEvent\"\n              click scenex.app.events._events.MouseEvent href \"\" \"scenex.app.events._events.MouseEvent\"\n              click scenex.app.events._events.Event href \"\" \"scenex.app.events._events.Event\"\n            </code></pre> <p>Mouse wheel scroll event.</p> <p>Fired when the mouse wheel (or trackpad scroll) is used. Includes the scroll delta in both horizontal and vertical directions. The magnitude and units of angle_delta are platform-dependent but typically represent degrees or steps.</p> <p>Attributes:</p> <ul> <li> <code>angle_delta</code>               (<code>tuple[float, float]</code>)           \u2013            <p>The (horizontal, vertical) scroll delta. Positive vertical values typically represent scrolling up/away from the user, negative values down/toward the user. Horizontal scrolling (if supported) uses the first component.</p> </li> </ul>"},{"location":"reference/scenex/conftest/","title":"conftest","text":""},{"location":"reference/scenex/conftest/#scenex.conftest","title":"scenex.conftest","text":"<p>Pytest setup for doctests.</p>"},{"location":"reference/scenex/imgui/","title":"imgui","text":""},{"location":"reference/scenex/imgui/#scenex.imgui","title":"scenex.imgui","text":"<p>ImGui controls for interactive scenex visualization.</p> <p>This module provides ImGui-based interactive controls for scenex scenes. It adds an overlay widget panel that allows real-time manipulation of scene parameters, view properties, and node attributes through sliders, checkboxes, color pickers, and other widgets.</p> <p>The controls are automatically generated from Pydantic model fields, providing a consistent interface without requiring manual widget creation.</p> Requirements <p>This module requires additional dependencies::</p> <pre><code>pip install scenex[imgui]\n</code></pre> <p>This installs imgui_bundle and pygfx with ImGui support.</p> Main Function <p>add_imgui_controls : function     Add an interactive ImGui control panel to a view</p> Example <p>Add controls to a scene with an image::</p> <pre><code>import scenex as snx\nfrom scenex.imgui import add_imgui_controls\n\n# Create a scene with some content\nimage = snx.Image(data=my_array)\nview = snx.View(scene=snx.Scene(children=[image]))\n\n# Add interactive controls\nadd_imgui_controls(view)\n\n# Show and run\nsnx.show(view)\nsnx.run()\n</code></pre> <p>The control panel will display collapsible sections for the view and each child node, with automatically generated widgets for adjusting properties like opacity, colors, transforms, and node-specific parameters.</p> Notes <p>Only works with pygfx backend</p> <p>Functions:</p> <ul> <li> <code>add_imgui_controls</code>             \u2013              <p>Add an interactive ImGui control panel to a view.</p> </li> </ul>"},{"location":"reference/scenex/imgui/#scenex.imgui.add_imgui_controls","title":"add_imgui_controls","text":"<pre><code>add_imgui_controls(view: View) -&gt; None\n</code></pre> <p>Add an interactive ImGui control panel to a view.</p> <p>Creates an overlay control panel that allows real-time manipulation of view properties and scene node attributes through automatically generated widgets. The panel displays collapsible sections for the view and each child node in the scene, with widgets dynamically created based on Pydantic field types.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If the view is not using the pygfx backend.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If the pygfx renderer has not been initialized yet.</p> </li> <li> <code>ImportError</code>             \u2013            <p>If required dependencies (imgui_bundle, pygfx) are not installed.</p> </li> </ul> Notes <ul> <li>Only works with the pygfx backend</li> <li>The control panel is rendered as an overlay on the canvas. It is not (currently)   restricted to a specific area of the canvas</li> <li>Current architecture necessitates this function be called AFTER setting up camera   interaction strategies and/or view event filters. All view events are intercepted   and may not propagate to the user's view filter or camera filter, but a best   attempt is made to propagate events that do not interact with the ImGui control   panel.</li> <li>Widgets are automatically generated from Pydantic field metadata:<ul> <li>Literal types \u2192 dropdown menus</li> <li>bool \u2192 checkbox</li> <li>int/float with bounds \u2192 slider</li> <li>int/float without bounds \u2192 input field</li> <li>Color \u2192 color picker</li> <li>Colormap \u2192 colormap preview button</li> </ul> </li> </ul> <p>Examples:</p> <p>Basic usage with an image::</p> <pre><code>&gt;&gt;&gt; import scenex as snx\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from scenex.imgui import add_imgui_controls\n\n&gt;&gt;&gt; my_array = np.random.rand(100, 100).astype(np.float32)\n&gt;&gt;&gt; image = snx.Image(data=my_array)\n&gt;&gt;&gt; view = snx.View(scene=snx.Scene(children=[image]))\n&gt;&gt;&gt; snx.show(view)\nCanvas(...)\n&gt;&gt;&gt; add_imgui_controls(view)\n&gt;&gt;&gt; snx.run()\n</code></pre> <p>The control panel will show sections for: - View properties (camera, layout, etc.) - Image node (colormap, clims, opacity, etc.) - Points node (size, color, symbol, etc.) - Mesh node (color, opacity, blending, etc.)</p> Source code in <code>src/scenex/imgui/_controls.py</code> <pre><code>def add_imgui_controls(view: View) -&gt; None:\n    \"\"\"Add an interactive ImGui control panel to a view.\n\n    Creates an overlay control panel that allows real-time manipulation of view\n    properties and scene node attributes through automatically generated widgets.\n    The panel displays collapsible sections for the view and each child node in\n    the scene, with widgets dynamically created based on Pydantic field types.\n\n    Parameters\n    ----------\n    view : View\n        The view to control.\n\n    Raises\n    ------\n    NotImplementedError\n        If the view is not using the pygfx backend.\n    RuntimeError\n        If the pygfx renderer has not been initialized yet.\n    ImportError\n        If required dependencies (imgui_bundle, pygfx) are not installed.\n\n    Notes\n    -----\n    - Only works with the pygfx backend\n    - The control panel is rendered as an overlay on the canvas. It is not (currently)\n      restricted to a specific area of the canvas\n    - Current architecture necessitates this function be called AFTER setting up camera\n      interaction strategies and/or view event filters. All view events are intercepted\n      and may not propagate to the user's view filter or camera filter, but a best\n      attempt is made to propagate events that do not interact with the ImGui control\n      panel.\n    - Widgets are automatically generated from Pydantic field metadata:\n        * Literal types \u2192 dropdown menus\n        * bool \u2192 checkbox\n        * int/float with bounds \u2192 slider\n        * int/float without bounds \u2192 input field\n        * Color \u2192 color picker\n        * Colormap \u2192 colormap preview button\n\n    Examples\n    --------\n    Basic usage with an image::\n\n        &gt;&gt;&gt; import scenex as snx\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from scenex.imgui import add_imgui_controls\n\n        &gt;&gt;&gt; my_array = np.random.rand(100, 100).astype(np.float32)\n        &gt;&gt;&gt; image = snx.Image(data=my_array)\n        &gt;&gt;&gt; view = snx.View(scene=snx.Scene(children=[image]))\n        &gt;&gt;&gt; snx.show(view)\n        Canvas(...)\n        &gt;&gt;&gt; add_imgui_controls(view)\n        &gt;&gt;&gt; snx.run()\n\n    The control panel will show sections for:\n    - View properties (camera, layout, etc.)\n    - Image node (colormap, clims, opacity, etc.)\n    - Points node (size, color, symbol, etc.)\n    - Mesh node (color, opacity, blending, etc.)\n    \"\"\"\n    snx_canvas_model = view.canvas\n    try:\n        snx_canvas_adaptor = snx_canvas_model._get_adaptors(backend=\"pygfx\")[0]\n        snx_view_adaptor = view._get_adaptors(backend=\"pygfx\")[0]\n    except (KeyError, IndexError):\n        warnings.warn(\n            \"No pygfx adaptor found view/canvas; cannot add imgui controls.\",\n            stacklevel=2,\n        )\n        return\n\n    render_canv = cast(\"CanvasAdaptor\", snx_canvas_adaptor)._snx_get_native()\n\n    if not (\n        isinstance(snx_canvas_adaptor, PygfxCanvasAdaptor)\n        and isinstance(snx_view_adaptor, PygfxViewAdaptor)\n        and isinstance(render_canv, BaseRenderCanvas)\n    ):\n        raise NotImplementedError(\n            \"Imgui controls can currently only be added to a canvas backed by pygfx.\"\n        )\n    if not snx_canvas_adaptor._renderer:\n        raise RuntimeError(\"The pygfx renderer has not been initialized yet.\")\n\n    imgui_renderer = ImguiRenderer(\n        device=snx_canvas_adaptor._renderer.device,\n        canvas=render_canv,  # pyright: ignore[reportArgumentType] (incorrect hint)\n    )\n\n    if implot.get_current_context() is None:\n        implot.create_context()  # must run after ImGui context exists\n\n    @imgui_renderer.set_gui  # type: ignore [untyped-decorator]\n    def _update_gui() -&gt; None:\n        render_imgui_view_controls(view)\n\n    @render_canv.request_draw\n    def _update() -&gt; None:\n        snx_canvas_adaptor._draw()\n        imgui_renderer.render()\n\n    class ImguiEventFilter:\n        internal_filter: Callable[[Event], bool] | None = None\n\n        def __call__(self, event: Event) -&gt; bool:\n            # NOTE: As the scenex event system matures\n            # It may capture more events (notably, keypresses).\n            # We will have to intercept scenex events here if that occurs\n            if isinstance(event, MouseMoveEvent):\n                move_dict = {\"x\": event.canvas_pos[0], \"y\": event.canvas_pos[1]}\n                imgui_renderer._on_mouse_move(move_dict)\n                if move_dict.get(\"stop_propagation\", False):\n                    return True\n            if isinstance(event, MousePressEvent):\n                btn = imgui_filter.convert_btn(event.buttons)\n                press_dict = {\"button\": btn, \"event_type\": \"pointer_down\"}\n                imgui_renderer._on_mouse(press_dict)\n                if press_dict.get(\"stop_propagation\", False):\n                    return True\n            if isinstance(event, MouseReleaseEvent):\n                btn = imgui_filter.convert_btn(event.buttons)\n                release_dict = {\"button\": btn, \"event_type\": \"pointer_up\"}\n                imgui_renderer._on_mouse(release_dict)\n                if release_dict.get(\"stop_propagation\", False):\n                    return True\n            if isinstance(event, WheelEvent):\n                # FIXME: Validate correct delta sign\n                wheel_dict = {\"dx\": event.angle_delta[0], \"dy\": event.angle_delta[1]}\n                imgui_renderer._on_wheel(wheel_dict)\n                if wheel_dict.get(\"stop_propagation\", False):\n                    return True\n\n            if self.internal_filter is None:\n                return False\n            return self.internal_filter(event)\n\n        def convert_btn(self, btn: MouseButton) -&gt; int:\n            if btn &amp; MouseButton.LEFT:\n                return 1\n            if btn &amp; MouseButton.RIGHT:\n                return 2\n            if btn &amp; MouseButton.MIDDLE:\n                return 3\n            return 0\n\n    imgui_filter = ImguiEventFilter()\n    imgui_filter.internal_filter = view.set_event_filter(imgui_filter)\n</code></pre>"},{"location":"reference/scenex/imgui/#scenex.imgui.add_imgui_controls(view)","title":"<code>view</code>","text":"(<code>View</code>)           \u2013            <p>The view to control.</p>"},{"location":"reference/scenex/model/","title":"model","text":""},{"location":"reference/scenex/model/#scenex.model","title":"scenex.model","text":"<p>Declarative model classes for building scene graphs.</p> <p>This module provides all the core model objects for constructing interactive 3D visualizations. The models form a scene graph - a hierarchical tree structure where each node can have children, with transformations, visibility, and other properties propagating down the tree.</p> Scene Graph Structure <p>The scene graph follows this hierarchy::</p> <pre><code>Canvas (rendering surface)\n\u2514\u2500\u2500 Grid (layout manager)\n    \u2514\u2500\u2500 View (viewport)\n        \u251c\u2500\u2500 Scene (root node)\n        \u2502   \u2514\u2500\u2500 Node (visual elements)\n        \u2502       \u251c\u2500\u2500 Image, Points, Line, Mesh, Volume, Text\n        \u2502       \u2514\u2500\u2500 Child nodes with transforms\n        \u2514\u2500\u2500 Camera (viewing perspective)\n</code></pre> <p>Parent node properties (like transforms, visibility, and opacity) are composed with child properties during rendering rather than mutating the children themselves. This means the scene graph structure stays immutable\u2014child property values never change, but their effective rendered values are computed by composing ancestor properties.</p> Main Model Categories <p>Container Models     - Canvas: Top-level rendering surface (window or canvas element)     - View: Rectangular viewport displaying a scene through a camera     - Scene: Root container for visual elements     - Grid: Layout system for arranging multiple views on a single canvas</p> <p>Visual Nodes     - Image: 2D images with colormapping and intensity normalization     - Points: Point markers with customizable symbols     - Line: Connected polylines with per-vertex coloring     - Mesh: Triangle mesh surfaces     - Volume: 3D volumetric rendering     - Text: Screen-space text labels</p> <p>Supporting Models     - Camera: Viewing perspective and projection     - Transform: 4x4 affine transformations     - Layout: Position, size, and styling for rectangular areas     - ColorModel: Color specification (uniform, per-face, per-vertex)</p> <p>Interaction Models     - PanZoom: Pan and zoom camera interaction     - Orbit: Orbit camera interaction     - Letterbox: Maintain aspect ratio on view resize</p> <p>Examples:</p> <p>Build a simple scene::</p> <pre><code>&gt;&gt;&gt; from scenex.model import Scene, Image, Points\n&gt;&gt;&gt; import numpy as np\n\n&gt;&gt;&gt; scene = Scene(\n...     children=[\n...         Image(data=np.random.rand(100, 100)),\n...         Points(vertices=np.random.rand(50, 2) * 100),\n...     ]\n... )\n</code></pre> <p>Create a view with interactive camera::</p> <pre><code>&gt;&gt;&gt; from scenex.model import View, Camera, PanZoom\n\n&gt;&gt;&gt; view = View(scene=scene, camera=Camera(controller=PanZoom(), interactive=True))\n</code></pre> Notes <p>To display models, use <code>scenex.show()</code> which creates backend adaptors. The adaptors handle the actual rendering by translating these declarative models into graphics library calls (pygfx, vispy, etc.), and listen for model changes after initial setup.</p> See Also <p>scenex.adaptors : Backend implementations for rendering scenex.show : Function to display models</p> <p>Classes:</p> <ul> <li> <code>BlendMode</code>           \u2013            <p>A set of available blending modes.</p> </li> <li> <code>Camera</code>           \u2013            <p>A camera that defines the viewing perspective and projection for a scene.</p> </li> <li> <code>CameraController</code>           \u2013            <p>Base class defining how a camera responds to user interaction events.</p> </li> <li> <code>Canvas</code>           \u2013            <p>A rendering surface that displays one or more views.</p> </li> <li> <code>ColorModel</code>           \u2013            <p>Base class for color models used in scene nodes.</p> </li> <li> <code>EventedBase</code>           \u2013            <p>Base class for all evented pydantic-style models.</p> </li> <li> <code>FaceColors</code>           \u2013            <p>Per-face coloring strategy for mesh-like nodes.</p> </li> <li> <code>Image</code>           \u2013            <p>A 2D image rendered as a textured rectangle.</p> </li> <li> <code>Layout</code>           \u2013            <p>Rectangular layout model with positioning and styling.</p> </li> <li> <code>Letterbox</code>           \u2013            <p>Maintain content aspect ratio on resize via letterboxing/pillarboxing.</p> </li> <li> <code>Line</code>           \u2013            <p>A polyline defined by connected vertices.</p> </li> <li> <code>Mesh</code>           \u2013            <p>A 3D surface mesh composed of triangular faces.</p> </li> <li> <code>Node</code>           \u2013            <p>Base class for all nodes in the scene graph.</p> </li> <li> <code>Orbit</code>           \u2013            <p>3D orbit controller for rotating around a focal point.</p> </li> <li> <code>PanZoom</code>           \u2013            <p>2D pan and zoom controller for orthographic views.</p> </li> <li> <code>Points</code>           \u2013            <p>A collection of point markers rendered at specified coordinates.</p> </li> <li> <code>ResizePolicy</code>           \u2013            <p>Base class defining how a view adapts to changes in its layout dimensions.</p> </li> <li> <code>Scene</code>           \u2013            <p>The root container node for a scene graph.</p> </li> <li> <code>Text</code>           \u2013            <p>A text label positioned in 3D world space.</p> </li> <li> <code>Transform</code>           \u2013            <p>A 4x4 homogeneous transformation matrix for 3D affine transformations.</p> </li> <li> <code>UniformColor</code>           \u2013            <p>Uniform coloring strategy for scene nodes.</p> </li> <li> <code>VertexColors</code>           \u2013            <p>Per-vertex coloring strategy for mesh, line, or points nodes.</p> </li> <li> <code>View</code>           \u2013            <p>A rectangular viewport that displays a scene through a camera.</p> </li> <li> <code>Volume</code>           \u2013            <p>A 3D volumetric dataset rendered with volume rendering techniques.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.BlendMode","title":"BlendMode","text":"<p>               Bases: <code>Enum</code></p> <pre><code>\n              flowchart TD\n              scenex.model.BlendMode[BlendMode]\n\n              \n\n              click scenex.model.BlendMode href \"\" \"scenex.model.BlendMode\"\n            </code></pre> <p>A set of available blending modes.</p> <p>Blending modes determine how the colors of rendered objects are combined with the colors already present in the framebuffer. More practically, if two objects overlap from the camera's perspective in the scene, the blending mode of the new object determines how its colors are combined with those of the object previously rendered.</p> <p>Note that the draw order plays a crucial role in blending.</p> <p>Attributes:</p> <ul> <li> <code>ADDITIVE</code>           \u2013            <p>The object's color value, multiplied by its alpha value, is added to the</p> </li> <li> <code>ALPHA</code>           \u2013            <p>The object's color is blended with the background using standard alpha compositing.</p> </li> <li> <code>OPAQUE</code>           \u2013            <p>The object's color value, multiplied by its alpha value, overwrites the</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.BlendMode.ADDITIVE","title":"ADDITIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ADDITIVE = 'additive'\n</code></pre> <p>The object's color value, multiplied by its alpha value, is added to the background color.</p>"},{"location":"reference/scenex/model/#scenex.model.BlendMode.ALPHA","title":"ALPHA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ALPHA = 'alpha'\n</code></pre> <p>The object's color is blended with the background using standard alpha compositing. The resulting color is a weighted combination of the foreground and background, where weights are determined by alpha values.</p>"},{"location":"reference/scenex/model/#scenex.model.BlendMode.OPAQUE","title":"OPAQUE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OPAQUE = 'opaque'\n</code></pre> <p>The object's color value, multiplied by its alpha value, overwrites the background color.</p>"},{"location":"reference/scenex/model/#scenex.model.Camera","title":"Camera","text":"<pre><code>Camera(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <pre><code>\n              flowchart TD\n              scenex.model.Camera[Camera]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.node.Node --&gt; scenex.model.Camera\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n              click scenex.model.Camera href \"\" \"scenex.model.Camera\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A camera that defines the viewing perspective and projection for a scene.</p> <p>The Camera is a node in the scene graph that determines how 3D world space is projected onto a 2D canvas. It combines a view transformation (positioning the camera in the scene) with a projection transformation (defining the viewing volume and perspective).</p> <p>Cameras use two transforms: - <code>transform</code> (inherited from Node): Maps local 3D space to world 3D space,   positioning and orienting the camera in the scene. - <code>projection</code>: Maps normalized device coordinates [-1, 1] x [-1, 1] to rays in   local 3D space, defining the viewing volume and projection type.</p> <p>The camera uses a right-handed coordinate system following OpenGL conventions: the positive x-axis points right, the positive y-axis points up, and the positive z-axis points out of the screen toward the viewer.</p> <p>Examples:</p> <p>Create a camera with pan-zoom controller:     &gt;&gt;&gt; camera = Camera(controller=PanZoom(), interactive=True)</p> <p>Create a camera with orbit controller:     &gt;&gt;&gt; camera = Camera(controller=Orbit(center=(0, 0, 0)), interactive=True)</p> <p>Position a camera and point it at a target:     &gt;&gt;&gt; camera = Camera()     &gt;&gt;&gt; camera.transform = Transform().translated((10, 0, 0))     &gt;&gt;&gt; camera.look_at((0, 0, 0), up=(0, 0, 1))</p> <p>Create a perspective camera:     &gt;&gt;&gt; from scenex.utils.projections import perspective     &gt;&gt;&gt; camera = Camera(projection=perspective(fov=70, near=0.1, far=100))</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>look_at</code>             \u2013              <p>Adjusts the camera to look at a target point in the world.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>passes_through</code>             \u2013              <p>Returns the depth t at which the provided ray intersects this node.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> <li> <code>forward</code>               (<code>Vector3D</code>)           \u2013            <p>The forward direction of the camera in world space, as a unit vector.</p> </li> <li> <code>up</code>               (<code>Vector3D</code>)           \u2013            <p>The up direction of the camera in world space, as a unit vector.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/model/#scenex.model.Camera.forward","title":"forward  <code>property</code> <code>writable</code>","text":"<pre><code>forward: Vector3D\n</code></pre> <p>The forward direction of the camera in world space, as a unit vector.</p>"},{"location":"reference/scenex/model/#scenex.model.Camera.up","title":"up  <code>property</code> <code>writable</code>","text":"<pre><code>up: Vector3D\n</code></pre> <p>The up direction of the camera in world space, as a unit vector.</p>"},{"location":"reference/scenex/model/#scenex.model.Camera.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.look_at","title":"look_at","text":"<pre><code>look_at(\n    target: Position3D, /, *, up: Vector3D | None = None\n) -&gt; None\n</code></pre> <p>Adjusts the camera to look at a target point in the world.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_nodes/camera.py</code> <pre><code>def look_at(self, target: Position3D, /, *, up: Vector3D | None = None) -&gt; None:\n    \"\"\"Adjusts the camera to look at a target point in the world.\n\n    Parameters\n    ----------\n    target: Position3D\n        The position in 3D space that the camera should look at.\n    up: Vector3D, optional\n        The up direction for the camera. If provided, this vector must be\n        perpendicular to the forward vector that results from looking at target.\n    \"\"\"\n    position = self.transform.map((0, 0, 0))[:3]\n    self.forward = tuple(target - position)\n    if up is not None:\n        if np.linalg.norm(up) == 0:\n            raise ValueError(\"Up vector must be non-zero.\")\n        if np.abs(np.dot(self.forward, up)) &gt; 1e-6:\n            raise ValueError(\"Up vector must be perpendicular to forward vector.\")\n        self.up = up\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.look_at(target)","title":"<code>target</code>","text":"(<code>Position3D</code>)           \u2013            <p>The position in 3D space that the camera should look at.</p>"},{"location":"reference/scenex/model/#scenex.model.Camera.look_at(up)","title":"<code>up</code>","text":"(<code>Vector3D | None</code>, default:                   <code>None</code> )           \u2013            <p>The up direction for the camera. If provided, this vector must be perpendicular to the forward vector that results from looking at target.</p>"},{"location":"reference/scenex/model/#scenex.model.Camera.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.passes_through","title":"passes_through","text":"<pre><code>passes_through(ray: Ray) -&gt; float | None\n</code></pre> <p>Returns the depth t at which the provided ray intersects this node.</p> <p>The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t, where t&gt;=0</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>t</code> (              <code>float | None</code> )          \u2013            <p>The depth t at which the ray intersects the node, or None if it never intersects.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def passes_through(self, ray: Ray) -&gt; float | None:\n    \"\"\"Returns the depth t at which the provided ray intersects this node.\n\n    The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t,\n    where t&gt;=0\n\n    Parameters\n    ----------\n    ray : Ray\n        The ray passing through the scene\n\n    Returns\n    -------\n    t: float | None\n        The depth t at which the ray intersects the node, or None if it never\n        intersects.\n    \"\"\"\n    # Nodes that want to support ray intersection should override this method.\n    return None\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.passes_through(ray)","title":"<code>ray</code>","text":"(<code>Ray</code>)           \u2013            <p>The ray passing through the scene</p>"},{"location":"reference/scenex/model/#scenex.model.Camera.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Camera.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Camera.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Camera.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.CameraController","title":"CameraController","text":"<p>               Bases: <code>EventedBase</code></p> <pre><code>\n              flowchart TD\n              scenex.model.CameraController[CameraController]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._base.EventedBase --&gt; scenex.model.CameraController\n                \n\n\n              click scenex.model.CameraController href \"\" \"scenex.model.CameraController\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>Base class defining how a camera responds to user interaction events.</p> <p>A CameraController handles user input (mouse, keyboard, wheel) to manipulate camera transforms and projections, enabling interactive behaviors like panning, zooming, orbiting, or custom camera controls. Controllers are attached to Camera instances via the <code>controller</code> field and automatically receive events when the camera is marked as <code>interactive=True</code>.</p> <p>Event handlers should return True if they fully handled the event (stopping further propagation) or False if other handlers should continue processing the event.</p> <p>Examples:</p> <p>Create a camera with pan/zoom controller:     &gt;&gt;&gt; camera = Camera(controller=PanZoom(), interactive=True)</p> <p>Create a camera with orbit controller:     &gt;&gt;&gt; camera = Camera(controller=Orbit(center=(0, 0, 0)), interactive=True)</p> See Also <p>PanZoom : 2D pan and zoom controller Orbit : 3D orbit controller Camera : Camera class that uses controllers</p> <p>Methods:</p> <ul> <li> <code>handle_event</code>             \u2013              <p>Handle a user interaction event to control the camera.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.CameraController.handle_event","title":"handle_event  <code>abstractmethod</code>","text":"<pre><code>handle_event(event: Event, camera: Camera) -&gt; bool\n</code></pre> <p>Handle a user interaction event to control the camera.</p> <p>This method is called automatically on all events on the camera's view that were not handled by previous handlers during scenex event processing.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the event was fully handled and should not propagate to other handlers, False if not handled or other handlers should process it.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/camera.py</code> <pre><code>@abstractmethod\ndef handle_event(self, event: Event, camera: Camera) -&gt; bool:\n    \"\"\"\n    Handle a user interaction event to control the camera.\n\n    This method is called automatically on all events on the camera's view that were\n    not handled by previous handlers during scenex event processing.\n\n    Parameters\n    ----------\n    event : Event\n        The input event to handle (MouseMoveEvent, MousePressEvent, WheelEvent,\n        KeyPressEvent, etc.)\n    camera : Camera\n        The camera node to manipulate.\n\n    Returns\n    -------\n    bool\n        True if the event was fully handled and should not propagate to other\n        handlers, False if not handled or other handlers should process it.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.CameraController.handle_event(event)","title":"<code>event</code>","text":"(<code>Event</code>)           \u2013            <p>The input event to handle (MouseMoveEvent, MousePressEvent, WheelEvent, KeyPressEvent, etc.)</p>"},{"location":"reference/scenex/model/#scenex.model.CameraController.handle_event(camera)","title":"<code>camera</code>","text":"(<code>Camera</code>)           \u2013            <p>The camera node to manipulate.</p>"},{"location":"reference/scenex/model/#scenex.model.CameraController.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Canvas","title":"Canvas","text":"<pre><code>Canvas(\n    *,\n    views: Iterable[View] = (),\n    **data: Unpack[CanvasKwargs],\n)\n</code></pre> <p>               Bases: <code>EventedBase</code></p> <pre><code>\n              flowchart TD\n              scenex.model.Canvas[Canvas]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._base.EventedBase --&gt; scenex.model.Canvas\n                \n\n\n              click scenex.model.Canvas href \"\" \"scenex.model.Canvas\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A rendering surface that displays one or more views.</p> <p>The Canvas represents the top-level rendering context where views are displayed. In desktop applications, a canvas corresponds to a window. In web applications, it corresponds to a DOM element. Multiple views can be laid out horizontally on a single canvas; more complex layouts are planned in the near future.</p> <p>Examples:</p> <p>Create a simple canvas with default settings:     &gt;&gt;&gt; canvas = Canvas()</p> <p>Create a canvas with custom size and title:     &gt;&gt;&gt; canvas = Canvas(width=800, height=600, title=\"My Visualization\")</p> <p>Create a canvas with multiple views side-by-side:     &gt;&gt;&gt; canvas = Canvas(width=800, height=400, views=[View(), View()])</p> <p>Methods:</p> <ul> <li> <code>close</code>             \u2013              <p>Close the canvas and release resources.</p> </li> <li> <code>handle</code>             \u2013              <p>Handle the passed event.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Post-initialization hook for the model.</p> </li> <li> <code>render</code>             \u2013              <p>Show the canvas.</p> </li> <li> <code>to_ndc</code>             \u2013              <p>Map XY canvas position (pixels) to normalized device coordinates (NDC).</p> </li> <li> <code>to_world</code>             \u2013              <p>Map XY canvas position (pixels) to a Ray traveling through world space.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>size</code>               (<code>tuple[int, int]</code>)           \u2013            <p>Return the size of the canvas.</p> </li> </ul> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def __init__(\n    self,\n    *,\n    views: Iterable[View] = (),\n    **data: Unpack[CanvasKwargs],\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Canvas.size","title":"size  <code>property</code> <code>writable</code>","text":"<pre><code>size: tuple[int, int]\n</code></pre> <p>Return the size of the canvas.</p>"},{"location":"reference/scenex/model/#scenex.model.Canvas.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the canvas and release resources.</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the canvas and release resources.\"\"\"\n    for adaptor in self._get_adaptors():\n        cast(\"CanvasAdaptor\", adaptor)._snx_close()\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Canvas.handle","title":"handle","text":"<pre><code>handle(event: Event) -&gt; bool\n</code></pre> <p>Handle the passed event.</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def handle(self, event: Event) -&gt; bool:\n    \"\"\"Handle the passed event.\"\"\"\n    handled = False\n    if isinstance(event, MouseEvent):\n        current_view = self._containing_view(event.canvas_pos)\n\n        # Check if we've moved between views and handle transitions\n        # BEGIN UNTESTED CODE!\n        # TODO: Add a test for this once multiple views are better supported\n        if self._last_mouse_view != current_view:\n            # Send leave event to the previous view\n            if self._last_mouse_view is not None:\n                leave_event = MouseLeaveEvent()\n                self._last_mouse_view.filter_event(leave_event)\n\n                # Send enter event to the new view (if any)\n                if current_view is not None:\n                    enter_event = MouseEnterEvent(\n                        canvas_pos=event.canvas_pos,\n                        world_ray=event.world_ray,\n                        buttons=event.buttons,\n                    )\n                    current_view.filter_event(enter_event)\n\n        self._last_mouse_view = current_view\n        # END UNTESTED CODE!\n\n        # Handle the original mouse event in the current view\n        if current_view is not None:\n            # Give the view a chance to observe the result\n            if current_view.filter_event(event):\n                return True\n\n            # No nodes in the view handled the event - pass it to the camera\n            if current_view.camera.interactive:\n                if on_mouse := current_view.camera.controller:\n                    handled |= on_mouse.handle_event(event, current_view.camera)\n    elif isinstance(event, MouseLeaveEvent):\n        # Mouse left the entire canvas\n        if self._last_mouse_view is not None:\n            handled = self._last_mouse_view.filter_event(event)\n            self._last_mouse_view = None\n    elif isinstance(event, ResizeEvent):\n        # TODO: How might some event filter tap into the resize?\n        self.size = (event.width, event.height)\n    return handled\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Canvas.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Post-initialization hook for the model.</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Post-initialization hook for the model.\"\"\"\n    # Update all current views\n    for view in self.views:\n        view._canvas = self\n\n    self.events.width.connect(self._compute_layout)\n    self.events.height.connect(self._compute_layout)\n\n    self._compute_layout()\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Canvas.render","title":"render","text":"<pre><code>render() -&gt; ndarray\n</code></pre> <p>Show the canvas.</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def render(self) -&gt; np.ndarray:\n    \"\"\"Show the canvas.\"\"\"\n    if adaptors := self._get_adaptors():\n        return cast(\"CanvasAdaptor\", adaptors[0])._snx_render()\n    raise RuntimeError(\"No adaptor found for Canvas.\")\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Canvas.to_ndc","title":"to_ndc","text":"<pre><code>to_ndc(\n    canvas_pos: tuple[float, float],\n) -&gt; tuple[float, float] | None\n</code></pre> <p>Map XY canvas position (pixels) to normalized device coordinates (NDC).</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def to_ndc(self, canvas_pos: tuple[float, float]) -&gt; tuple[float, float] | None:\n    \"\"\"Map XY canvas position (pixels) to normalized device coordinates (NDC).\"\"\"\n    view = self._containing_view(canvas_pos)\n    if view is None:\n        return None\n\n    # Get position relative to viewport\n    pos_rel = (\n        canvas_pos[0] - view.layout.x,\n        canvas_pos[1] - view.layout.y,\n    )\n\n    width, height = view.layout.size\n\n    # Convert position to Normalized Device Coordinates (NDC) - i.e., within [-1, 1]\n    x = pos_rel[0] / width * 2 - 1\n    y = -(pos_rel[1] / height * 2 - 1)\n    return (x, y)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Canvas.to_world","title":"to_world","text":"<pre><code>to_world(canvas_pos: tuple[float, float]) -&gt; Ray | None\n</code></pre> <p>Map XY canvas position (pixels) to a Ray traveling through world space.</p> Source code in <code>src/scenex/model/_canvas.py</code> <pre><code>def to_world(self, canvas_pos: tuple[float, float]) -&gt; Ray | None:\n    \"\"\"Map XY canvas position (pixels) to a Ray traveling through world space.\"\"\"\n    # Code adapted from:\n    # https://github.com/pygfx/pygfx/pull/753/files#diff-173d643434d575e67f8c0a5bf2d7ea9791e6e03a4e7a64aa5fa2cf4172af05cdR395\n    view = self._containing_view(canvas_pos)\n    if view is None:\n        return None\n\n    # Convert position to Normalized Device Coordinates (NDC) - i.e., within [-1, 1]\n    pos_ndc = self.to_ndc(canvas_pos)\n\n    # Note that the camera matrix is the matrix multiplication of:\n    # * The projection matrix, which projects local space (the rectangular\n    #   bounds of the perspective camera) into NDC.\n    # * The view matrix, i.e. the transform positioning the camera in the world.\n    # The result is a matrix mapping world coordinates\n    camera_matrix = view.camera.projection @ view.camera.transform.inv().T\n    # Unproject the canvas NDC coordinates into world space.\n    pos_world = la.vec_unproject(pos_ndc, camera_matrix)\n\n    # To find the direction of the ray, we find a unprojected point farther away\n    # and subtract the closer point.\n    pos_world_farther = la.vec_unproject(pos_ndc, camera_matrix, depth=1)\n    direction = pos_world_farther - pos_world\n    direction = direction / np.linalg.norm(direction)\n\n    ray = Ray(\n        origin=tuple(pos_world),\n        direction=tuple(direction),\n        source=view,\n    )\n    return ray\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.ColorModel","title":"ColorModel","text":"<pre><code>ColorModel(**data: Any)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              scenex.model.ColorModel[ColorModel]\n\n              \n\n              click scenex.model.ColorModel href \"\" \"scenex.model.ColorModel\"\n            </code></pre> <p>Base class for color models used in scene nodes.</p> <p>This class should not be instantiated directly. Instead, use one of its subclasses: - UniformColor: for a single color applied to the entire geometry - FaceColors: for per-face coloring (one color per face) - VertexColors: for per-vertex coloring (one color per vertex)</p> <p>The <code>color</code> field is typed as <code>Any</code> to allow flexibility in subclasses.</p> Source code in <code>src/scenex/model/_color.py</code> <pre><code>def __init__(self, **data: Any) -&gt; None:\n    if type(self) is ColorModel:\n        raise TypeError(\"ColorModel cannot be instantiated directly\")\n    super().__init__(**data)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.EventedBase","title":"EventedBase","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              scenex.model.EventedBase[EventedBase]\n\n              \n\n              click scenex.model.EventedBase href \"\" \"scenex.model.EventedBase\"\n            </code></pre> <p>Base class for all evented pydantic-style models.</p> <p>Methods:</p> <ul> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.EventedBase.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.FaceColors","title":"FaceColors","text":"<pre><code>FaceColors(**data: Any)\n</code></pre> <p>               Bases: <code>ColorModel</code></p> <pre><code>\n              flowchart TD\n              scenex.model.FaceColors[FaceColors]\n              scenex.model._color.ColorModel[ColorModel]\n\n                              scenex.model._color.ColorModel --&gt; scenex.model.FaceColors\n                \n\n\n              click scenex.model.FaceColors href \"\" \"scenex.model.FaceColors\"\n              click scenex.model._color.ColorModel href \"\" \"scenex.model._color.ColorModel\"\n            </code></pre> <p>Per-face coloring strategy for mesh-like nodes.</p> <p>This model applies a different color to each face of a mesh. The <code>color</code> field is a sequence of <code>Color</code> instances, one for each face.</p> <p>Examples:</p> <p>Per-face coloring:     &gt;&gt;&gt; from cmap import Color     &gt;&gt;&gt; from scenex import FaceColors     &gt;&gt;&gt; model = FaceColors(color=[Color(\"red\"), Color(\"blue\"), Color(\"green\")])</p> Source code in <code>src/scenex/model/_color.py</code> <pre><code>def __init__(self, **data: Any) -&gt; None:\n    if type(self) is ColorModel:\n        raise TypeError(\"ColorModel cannot be instantiated directly\")\n    super().__init__(**data)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image","title":"Image","text":"<pre><code>Image(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <pre><code>\n              flowchart TD\n              scenex.model.Image[Image]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.node.Node --&gt; scenex.model.Image\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n              click scenex.model.Image href \"\" \"scenex.model.Image\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A 2D image rendered as a textured rectangle.</p> <p>Image displays a 2D array of intensity values, mapping them to colors using a colormap. The image is rendered as a rectangle in 3D space, with pixels centered at integer coordinates starting from (0, 0). The image supports various rendering options including colormapping, intensity normalization, gamma correction, and interpolation.</p> <p>The image's geometry spans from (-0.5, -0.5) to (width-0.5, height-0.5), meaning that pixel centers are at integer coordinates. This convention aligns with standard image processing practices.</p> <p>Examples:</p> <p>Create a simple grayscale image:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; data = np.random.rand(100, 100)     &gt;&gt;&gt; img = Image(data=data)</p> <p>Create an image with custom colormap and intensity range:     &gt;&gt;&gt; img = Image(data=data, cmap=Colormap(\"viridis\"), clims=(0, 255))</p> <p>Create a transformed and semi-transparent image:     &gt;&gt;&gt; img = Image(     ...     data=data,     ...     transform=Transform().translated((10, 20)).scaled((2, 2)),     ...     opacity=0.7,     ... )</p> <p>Apply gamma correction to brighten dark images:     &gt;&gt;&gt; img = Image(data=data, gamma=0.5)</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/model/#scenex.model.Image.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Image.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Image.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Image.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Layout","title":"Layout","text":"<p>               Bases: <code>EventedBase</code></p> <pre><code>\n              flowchart TD\n              scenex.model.Layout[Layout]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._base.EventedBase --&gt; scenex.model.Layout\n                \n\n\n              click scenex.model.Layout href \"\" \"scenex.model.Layout\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>Rectangular layout model with positioning and styling.</p> <p>The Layout model defines the position, size, and visual styling of rectangular areas. It uses a box model with margin, border, padding, and content areas, similar to CSS.</p> <p>Examples:</p> <p>Create a layout at position (100, 100) with size 400x300:     &gt;&gt;&gt; layout = Layout(x=100, y=100, width=400, height=300)</p> <p>Create a layout with border and padding:     &gt;&gt;&gt; layout = Layout(     ...     width=200,     ...     height=200,     ...     border_width=2,     ...     border_color=Color(\"white\"),     ...     padding=10,     ... )</p> Notes <p>The layout follows this box model::</p> <pre><code>    y\n    |\n    v\nx-&gt; +--------------------------------+  ^\n    |            margin              |  |\n    |  +--------------------------+  |  |\n    |  |         border           |  |  |\n    |  |  +--------------------+  |  |  |\n    |  |  |      padding       |  |  |  |\n    |  |  |  +--------------+  |  |  |   height\n    |  |  |  |   content    |  |  |  |  |\n    |  |  |  |              |  |  |  |  |\n    |  |  |  +--------------+  |  |  |  |\n    |  |  +--------------------+  |  |  |\n    |  +--------------------------+  |  |\n    +--------------------------------+  v\n\n    &lt;------------ width -------------&gt;\n</code></pre> <p>Methods:</p> <ul> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>content_rect</code>               (<code>tuple[float, float, float, float]</code>)           \u2013            <p>Return the (x, y, width, height) of the content area.</p> </li> <li> <code>position</code>               (<code>tuple[float, float]</code>)           \u2013            <p>Return the x, y position of the layout as a tuple.</p> </li> <li> <code>size</code>               (<code>tuple[float, float]</code>)           \u2013            <p>Return the width, height of the layout as a tuple.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.Layout.content_rect","title":"content_rect  <code>property</code>","text":"<pre><code>content_rect: tuple[float, float, float, float]\n</code></pre> <p>Return the (x, y, width, height) of the content area.</p>"},{"location":"reference/scenex/model/#scenex.model.Layout.position","title":"position  <code>property</code>","text":"<pre><code>position: tuple[float, float]\n</code></pre> <p>Return the x, y position of the layout as a tuple.</p>"},{"location":"reference/scenex/model/#scenex.model.Layout.size","title":"size  <code>property</code>","text":"<pre><code>size: tuple[float, float]\n</code></pre> <p>Return the width, height of the layout as a tuple.</p>"},{"location":"reference/scenex/model/#scenex.model.Layout.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Letterbox","title":"Letterbox","text":"<p>               Bases: <code>ResizePolicy</code></p> <pre><code>\n              flowchart TD\n              scenex.model.Letterbox[Letterbox]\n              scenex.model._view.ResizePolicy[ResizePolicy]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._view.ResizePolicy --&gt; scenex.model.Letterbox\n                                scenex.model._base.EventedBase --&gt; scenex.model._view.ResizePolicy\n                \n\n\n\n              click scenex.model.Letterbox href \"\" \"scenex.model.Letterbox\"\n              click scenex.model._view.ResizePolicy href \"\" \"scenex.model._view.ResizePolicy\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>Maintain content aspect ratio on resize via letterboxing/pillarboxing.</p> <p>The Letterbox strategy preserves the original aspect ratio of the camera's projection when the view is resized. When the view's aspect ratio differs from the content's aspect ratio, the projection is expanded in the narrower dimension to ensure all original content remains visible with black bars (letterboxing for wide views, pillarboxing for tall views).</p> <p>The strategy tracks resize sequences (e.g., dragging a window corner) by storing the camera's projection as a reference at the start of that sequence. At any point during the sequence, the projection matrix is expanded in either width or height to retain the rectangle of that reference projection. A new sequence is defined by a change in the projection matrix, either programmatically made or through user input, signalled by a camera projection matrix different from that set during the last resize operation.</p> <p>Examples:</p> <p>Create a view with letterbox resizing:     &gt;&gt;&gt; from scenex.utils.projections import orthographic     &gt;&gt;&gt; view = View(     ...     camera=Camera(projection=orthographic(100, 100, 100)),     ...     on_resize=Letterbox(),     ... )</p> <p>When view is resized to 200x100 pixels, the projection expands horizontally to maintain the 1:1 aspect ratio, showing more content on the sides rather than stretching the image.</p> Notes <p>This approach follows the conventions of vispy's PanZoomCamera and pygfx's PerspectiveCamera. The projection matrix scales are inversely proportional to the displayed region: smaller scale values show more content.</p> See Also <p>ResizePolicy : Base class for resize policies View : View class that uses resize strategies Camera : Camera class with projection property</p> <p>Methods:</p> <ul> <li> <code>handle_resize</code>             \u2013              <p>Handle view resize by adjusting projection to maintain aspect ratio.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.Letterbox.handle_resize","title":"handle_resize","text":"<pre><code>handle_resize(view: View) -&gt; None\n</code></pre> <p>Handle view resize by adjusting projection to maintain aspect ratio.</p> Source code in <code>src/scenex/model/_view.py</code> <pre><code>def handle_resize(self, view: View) -&gt; None:\n    \"\"\"Handle view resize by adjusting projection to maintain aspect ratio.\"\"\"\n    # If the current projection differs from the last adjustment, or if there is no\n    # reference to begin with, this is a new resize sequence.\n    if view.camera.projection != self._last_adjustment or self._reference is None:\n        self._reference = view.camera.projection\n\n    view_width = int(view.layout.width)\n    view_height = int(view.layout.height)\n    if view_height == 0 or self._reference is None:\n        return\n\n    # Extract projection scales that define the content aspect ratio\n    ref_mat = self._reference.root\n    ref_x_scale = ref_mat[0, 0]\n    ref_y_scale = ref_mat[1, 1]\n    if ref_y_scale == 0:\n        return\n\n    # Compute aspect ratios\n    # NOTE: projection scales are inversely proportional to the displayed region,\n    # so content_aspect = y_scale / x_scale\n    view_aspect = view_width / view_height\n    content_aspect = abs(ref_y_scale / ref_x_scale)\n\n    # Expand the narrower dimension to match the view aspect\n    if content_aspect &lt; view_aspect:\n        # View is wider: expand horizontal frustum (reduce x scale)\n        adjusted_proj = self._reference.scaled(\n            (content_aspect / view_aspect, 1.0, 1.0)\n        )\n    else:\n        # View is taller: expand vertical frustum (reduce y scale)\n        adjusted_proj = self._reference.scaled(\n            (1.0, view_aspect / content_aspect, 1.0)\n        )\n\n    # Store the adjustment before applying it\n    view.camera.projection = self._last_adjustment = adjusted_proj\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Letterbox.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Line","title":"Line","text":"<pre><code>Line(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <pre><code>\n              flowchart TD\n              scenex.model.Line[Line]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.node.Node --&gt; scenex.model.Line\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n              click scenex.model.Line href \"\" \"scenex.model.Line\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A polyline defined by connected vertices.</p> <p>Line renders a sequence of connected line segments by drawing from each vertex to the next. The line can be colored uniformly or with per-vertex colors that smoothly interpolate along the path. Lines support width control and anti-aliasing for smooth rendering.</p> <p>Vertices can be 2D or 3D coordinates. For 2D vertices, the z-coordinate is assumed to be 0, placing the line in the xy-plane.</p> <p>Examples:</p> <p>Create a simple line connecting several points:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; vertices = np.array([[0, 0], [10, 5], [20, 0]])     &gt;&gt;&gt; line = Line(     ...     vertices=vertices,     ...     color=UniformColor(color=Color(\"red\")),     ... )</p> <p>Create a line with per-vertex colors:     &gt;&gt;&gt; vertices = np.array([[0, 0], [10, 10], [20, 0]])     &gt;&gt;&gt; colors = [Color(\"red\"), Color(\"green\"), Color(\"blue\")]     &gt;&gt;&gt; line = Line(     ...     vertices=vertices,     ...     color=VertexColors(color=colors),     ...     width=2.0,     ... )</p> <p>Create a 3D line:     &gt;&gt;&gt; vertices = np.array([[0, 0, 0], [10, 5, 3], [20, 0, 6]])     &gt;&gt;&gt; line = Line(vertices=vertices, width=3.0)</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>passes_through</code>             \u2013              <p>Check if the ray passes through this line.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Line.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/model/#scenex.model.Line.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Line.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Line.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Line.passes_through","title":"passes_through","text":"<pre><code>passes_through(ray: Ray) -&gt; float | None\n</code></pre> <p>Check if the ray passes through this line.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float | None</code>           \u2013            <p>The distance to the closest intersection, or None if no intersection.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/line.py</code> <pre><code>def passes_through(self, ray: Ray) -&gt; float | None:\n    \"\"\"\n    Check if the ray passes through this line.\n\n    Parameters\n    ----------\n    ray : Ray\n        The ray to test for intersection.\n\n    Returns\n    -------\n    float | None\n        The distance to the closest intersection, or None if no intersection.\n    \"\"\"\n    verts = np.asarray(self.vertices)\n    # Convert vertices to canvas space\n    canvas_vertices = self._node_to_canvas(ray.source)\n    # Convert ray to canvas space\n    canvas_ray = Line._world_to_canvas(ray, np.array([ray.origin]))[0]\n\n    starts = canvas_vertices[:-1]\n    ends = canvas_vertices[1:]\n\n    # Compute the distance from the ray ON THE CANVAS to the closest point the line\n    # associated with each line segment.\n    #\n    # Equation loaned from https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points\n    num = np.abs(\n        (ends[:, 1] - starts[:, 1]) * canvas_ray[0]\n        - (ends[:, 0] - starts[:, 0]) * canvas_ray[1]\n        + ends[:, 0] * starts[:, 1]\n        - ends[:, 1] * starts[:, 0]\n    )\n    den = np.sqrt(\n        (ends[:, 1] - starts[:, 1]) ** 2 + (ends[:, 0] - starts[:, 0]) ** 2\n    )\n    den[den == 0] = float(\"inf\")  # Avoid division by zero\n    distance = num / den\n\n    # Determine the corresponding point in world space corresponding to that closest\n    # point. Note that this point is only on the line segment if 0 &lt;= t &lt;= 1.\n    # (We check this at the end.)\n    a = np.subtract(canvas_ray, starts)\n    b = np.subtract(ends, starts)\n    # Vectorized version of dot product\n    t = np.sum(a * b, axis=1) / np.sum(b * b, axis=1)\n    intersect_world = verts[1:] + t[:, np.newaxis] * (verts[:-1] - verts[1:])\n\n    # Calculate the distance along the ray to the intersection point\n    # The ray is defined as: ray.origin + d * ray.direction\n    # We need to find d such that ray.origin + d * ray.direction = intersect_world\n    # This gives us: d * ray.direction = intersect_world - ray.origin\n    # Solving for d: d = dot(intersect_world - ray.origin, ray.direction) /\n    #                     dot(ray.direction, ray.direction)\n    ray_to_intersect = np.subtract(intersect_world, ray.origin)\n    ray_dir_squared = np.dot(ray.direction, ray.direction)\n\n    if ray_dir_squared == 0:\n        return None  # Degenerate ray\n\n    d = np.dot(ray_to_intersect, ray.direction) / ray_dir_squared\n\n    # Our ray intersects the line if:\n    # 1. The distance from the ray to the line is less than the line width\n    # 2. The intersection point is within the line segment (0 &lt;= t &lt;= 1)\n    # 3. The intersection point is in front of the ray origin (d &gt;= 0)\n    condition = (distance &lt;= self.width) &amp; (t &gt;= 0) &amp; (t &lt;= 1) &amp; (d &gt;= 0)\n    valid_intersections = d[condition]\n    if len(valid_intersections):\n        return float(np.min(valid_intersections))\n    else:\n        return None\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Line.passes_through(ray)","title":"<code>ray</code>","text":"(<code>Ray</code>)           \u2013            <p>The ray to test for intersection.</p>"},{"location":"reference/scenex/model/#scenex.model.Line.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Line.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Line.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Line.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Line.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Line.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Mesh","title":"Mesh","text":"<pre><code>Mesh(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <pre><code>\n              flowchart TD\n              scenex.model.Mesh[Mesh]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.node.Node --&gt; scenex.model.Mesh\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n              click scenex.model.Mesh href \"\" \"scenex.model.Mesh\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A 3D surface mesh composed of triangular faces.</p> <p>Mesh represents a 3D surface defined by vertices and triangular faces. Each face is specified by three indices into the vertex array, forming a triangle. The mesh uses counter-clockwise winding order: for a face (v1, v2, v3), the normal vector points in the direction of (v2 - v1) x (v3 - v1).</p> <p>Meshes support ray-triangle intersection testing using the M\u00f6ller-Trumbore algorithm, enabling efficient picking and interaction.</p> <p>Examples:</p> <p>Create a simple triangle mesh:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; vertices = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0]])     &gt;&gt;&gt; faces = np.array([[0, 1, 2]])     &gt;&gt;&gt; mesh = Mesh(     ...     vertices=vertices,     ...     faces=faces,     ...     color=UniformColor(color=Color(\"blue\")),     ... )</p> <p>Create a square made of two triangles:     &gt;&gt;&gt; vertices = np.array(     ...     [     ...         [0, 0, 0],  # bottom-left     ...         [1, 0, 0],  # bottom-right     ...         [1, 1, 0],  # top-right     ...         [0, 1, 0],  # top-left     ...     ]     ... )     &gt;&gt;&gt; faces = np.array(     ...     [     ...         [0, 1, 2],  # first triangle     ...         [0, 2, 3],  # second triangle     ...     ]     ... )     &gt;&gt;&gt; mesh = Mesh(vertices=vertices, faces=faces)</p> Notes <p>Face winding order (counter-clockwise) determines which side of the triangle is considered the \"front\" face. The normal vector for face (v1, v2, v3) points in the direction of (v2 - v1) x (v3 - v1).</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>intersecting_faces</code>             \u2013              <p>Find all faces that intersect with the given ray.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>passes_through</code>             \u2013              <p>Check if the ray passes through this mesh and return the closest distance.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Mesh.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/model/#scenex.model.Mesh.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Mesh.intersecting_faces","title":"intersecting_faces","text":"<pre><code>intersecting_faces(ray: Ray) -&gt; list[tuple[int, float]]\n</code></pre> <p>Find all faces that intersect with the given ray.</p> <p>Uses the M\u00f6ller-Trumbore intersection algorithm, vectorized over all triangles. Adapted from https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm#C++_implementation</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[tuple[int, float]]</code>           \u2013            <p>A list of tuples containing (face_index, distance) for each intersecting face. Sorted by distance (closest first).</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/mesh.py</code> <pre><code>def intersecting_faces(self, ray: Ray) -&gt; list[tuple[int, float]]:\n    \"\"\"\n    Find all faces that intersect with the given ray.\n\n    Uses the M\u00f6ller-Trumbore intersection algorithm, vectorized over all triangles.\n    Adapted from https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm#C++_implementation\n\n    Parameters\n    ----------\n    ray : Ray\n        The ray to test for intersections.\n\n    Returns\n    -------\n    list[tuple[int, float]]\n        A list of tuples containing (face_index, distance) for each\n        intersecting face. Sorted by distance (closest first).\n    \"\"\"\n    tracked_faces = np.arange(len(self.faces))\n\n    # Suppose the triangle is defined by vertices v1, v2, v3\n    # Barycentric coordinates are given by\n    # P = (1 - u - v)*v1 + u*v2 + v*v3,\n    #   = v1 + u(v2 - v1) + v(v3 - v1)\n    #   = v1 + u*e1 + v*e2\n    # But the intersection point is also given by our ray equation:\n    # P = ray.origin + t*ray.direction\n    # So we need to solve the equation\n    # ray.origin + t*ray.direction = v1 + u*e1 + v*e2\n    # Rearranging:\n    # ray.origin - v1 = -t*ray.direction + u*e1 + v*e2\n    e1 = self.vertices[self.faces[:, 1]] - self.vertices[self.faces[:, 0]]\n    e2 = self.vertices[self.faces[:, 2]] - self.vertices[self.faces[:, 0]]\n\n    # First, cull all triangles parallel to the ray\n    # We compute the determinant (scalar triple product) for this\n    ray_cross_e2 = np.cross(ray.direction, e2)\n    # NOTE: Vectorized version of row-wise dot product of ray_cross_e2 and e1\n    det = np.sum(ray_cross_e2 * e1, axis=1)\n    parallel_triangles = np.isclose(det, 0)\n\n    # Remove parallel triangles from consideration\n    e1 = e1[~parallel_triangles]\n    e2 = e2[~parallel_triangles]\n    ray_cross_e2 = ray_cross_e2[~parallel_triangles]\n    det = det[~parallel_triangles]\n    v1 = self.vertices[self.faces[:, 0]][~parallel_triangles]\n    tracked_faces = tracked_faces[~parallel_triangles]\n\n    # We can use Cramer's Rule to solve for t, u, v\n    # (We solve for u, v first to check if the intersection is within the triangle)\n    #\n    # u = (1/det) * scalar_triple_product(ray.direction, s, e2)\n    inv_det = 1 / det\n    s = ray.origin - v1\n    u = inv_det * np.sum(s * ray_cross_e2, axis=1)\n    # v = (1/det) * scalar_triple_product(ray.direction, e1, s)\n    s_cross_e1 = np.cross(s, e1)\n    v = inv_det * np.sum(ray.direction * s_cross_e1, axis=1)\n\n    # Cull triangles where the intersection is outside the triangle\n    intersecting = (u &gt;= 0) &amp; (v &gt;= 0) &amp; (u + v &lt; 1)\n\n    if not np.any(intersecting):\n        return []\n\n    # Get the indices and data for intersecting triangles\n    tracked_faces = tracked_faces[intersecting]\n    inv_det = inv_det[intersecting]\n    e2 = e2[intersecting]\n    s_cross_e1 = s_cross_e1[intersecting]\n\n    # t = (1/det) * scalar_triple_product(s, e1, e2)\n    t = inv_det * np.sum(e2 * s_cross_e1, axis=1)\n\n    # Create list of (face_index, distance) tuples and sort by distance\n    intersections = list(zip(tracked_faces, t, strict=True))\n    intersections.sort(key=lambda x: x[1])  # Sort by distance\n\n    return intersections\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Mesh.intersecting_faces(ray)","title":"<code>ray</code>","text":"(<code>Ray</code>)           \u2013            <p>The ray to test for intersections.</p>"},{"location":"reference/scenex/model/#scenex.model.Mesh.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Mesh.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Mesh.passes_through","title":"passes_through","text":"<pre><code>passes_through(ray: Ray) -&gt; float | None\n</code></pre> <p>Check if the ray passes through this mesh and return the closest distance.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float | None</code>           \u2013            <p>The distance to the closest intersection, or None if no intersection.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/mesh.py</code> <pre><code>def passes_through(self, ray: Ray) -&gt; float | None:\n    \"\"\"\n    Check if the ray passes through this mesh and return the closest distance.\n\n    Parameters\n    ----------\n    ray : Ray\n        The ray to test for intersection.\n\n    Returns\n    -------\n    float | None\n        The distance to the closest intersection, or None if no intersection.\n    \"\"\"\n    intersections = self.intersecting_faces(ray)\n    if not intersections:\n        return None\n\n    # Return the closest intersection distance\n    return float(intersections[0][1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Mesh.passes_through(ray)","title":"<code>ray</code>","text":"(<code>Ray</code>)           \u2013            <p>The ray to test for intersection.</p>"},{"location":"reference/scenex/model/#scenex.model.Mesh.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Mesh.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Mesh.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Mesh.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Mesh.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Mesh.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node","title":"Node","text":"<pre><code>Node(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>EventedBase</code></p> <pre><code>\n              flowchart TD\n              scenex.model.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._base.EventedBase --&gt; scenex.model.Node\n                \n\n\n              click scenex.model.Node href \"\" \"scenex.model.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>Base class for all nodes in the scene graph.</p> <p>Node is the fundamental building block of scenex's scene graph architecture. Nodes form a hierarchical tree structure where each node can have a parent and children, creating a parent-child relationship that propagates transformations, visibility, and other properties through the graph.</p> <p>Nodes are abstract and should not be instantiated directly. Use concrete subclasses like Image, Points, Line, Mesh, Scene, or Camera instead.</p> <p>The scene graph hierarchy allows: - Hierarchical transformations: A node's transform is relative to its parent - Property inheritance: Visibility and opacity affect all descendants - Spatial relationships: Nodes can find paths to other nodes in the graph - Event handling: Interactive nodes can respond to user input</p> Notes <p>Do not instantiate Node directly. Use concrete subclasses instead.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>passes_through</code>             \u2013              <p>Returns the depth t at which the provided ray intersects this node.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/model/#scenex.model.Node.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node.passes_through","title":"passes_through","text":"<pre><code>passes_through(ray: Ray) -&gt; float | None\n</code></pre> <p>Returns the depth t at which the provided ray intersects this node.</p> <p>The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t, where t&gt;=0</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>t</code> (              <code>float | None</code> )          \u2013            <p>The depth t at which the ray intersects the node, or None if it never intersects.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def passes_through(self, ray: Ray) -&gt; float | None:\n    \"\"\"Returns the depth t at which the provided ray intersects this node.\n\n    The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t,\n    where t&gt;=0\n\n    Parameters\n    ----------\n    ray : Ray\n        The ray passing through the scene\n\n    Returns\n    -------\n    t: float | None\n        The depth t at which the ray intersects the node, or None if it never\n        intersects.\n    \"\"\"\n    # Nodes that want to support ray intersection should override this method.\n    return None\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node.passes_through(ray)","title":"<code>ray</code>","text":"(<code>Ray</code>)           \u2013            <p>The ray passing through the scene</p>"},{"location":"reference/scenex/model/#scenex.model.Node.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Node.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Node.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Node.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Orbit","title":"Orbit","text":"<p>               Bases: <code>CameraController</code></p> <pre><code>\n              flowchart TD\n              scenex.model.Orbit[Orbit]\n              scenex.model._nodes.camera.CameraController[CameraController]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.camera.CameraController --&gt; scenex.model.Orbit\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.camera.CameraController\n                \n\n\n\n              click scenex.model.Orbit href \"\" \"scenex.model.Orbit\"\n              click scenex.model._nodes.camera.CameraController href \"\" \"scenex.model._nodes.camera.CameraController\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>3D orbit controller for rotating around a focal point.</p> <p>Orbit provides intuitive 3D navigation for perspective views by allowing the camera to rotate around a fixed center point while maintaining its distance.</p> <p>The strategy uses spherical coordinates to control camera position: - Azimuth: Rotation around the polar axis (typically Z), controlling left/right   movement around the scene - Elevation: Angle from the polar axis, controlling up/down viewing angle - Distance: Radius from the center point, controlled by zooming</p> <p>During rotation, foreground objects (between the camera and the center) move in the direction of mouse movement, providing intuitive control where the visible scene appears to rotate under the mouse.</p> <p>The right mouse button allows panning the orbit center itself, enabling exploration of large scenes by moving the focal point while maintaining the camera's viewing angle and distance.</p> <p>Attributes:</p> <ul> <li> <code>center</code>               (<code>tuple[float, float, float]</code>)           \u2013            <p>The point in 3D space around which the camera orbits. This is the focal point that remains stationary during rotation. Default is (0, 0, 0).</p> </li> <li> <code>polar_axis</code>               (<code>tuple[float, float, float]</code>)           \u2013            <p>The axis defining the \"up\" direction for orbit calculations. Azimuth rotations occur around this axis. Default is (0, 0, 1) for Z-up orientation.</p> </li> </ul> <p>Examples:</p> <p>Orbit around the origin:     &gt;&gt;&gt; from scenex.utils import projections     &gt;&gt;&gt; # Create a perspective camera...     &gt;&gt;&gt; camera = Camera(     ...     interactive=True,     ...     projection=projections.perspective(fov=70, near=1, far=1000),     ... )     &gt;&gt;&gt; # ...positioned along the X axis...     &gt;&gt;&gt; camera.transform = Transform().translated((100, 0, 0))     &gt;&gt;&gt; # ...looking at the origin...     &gt;&gt;&gt; camera.look_at((0, 0, 0), up=(0, 0, 1))     &gt;&gt;&gt; # ...that orbits around the origin     &gt;&gt;&gt; camera.controller = Orbit(center=(0, 0, 0))</p> <p>Orbit around a data volume's center:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; my_data = np.random.rand(100, 100, 100).astype(np.float32)     &gt;&gt;&gt; volume = Volume(data=my_data)     &gt;&gt;&gt; center = np.mean(volume.bounding_box, axis=0)     &gt;&gt;&gt; # Create a perspective camera...     &gt;&gt;&gt; camera = Camera(     ...     interactive=True,     ...     projection=projections.perspective(fov=70, near=1, far=1000),     ... )     &gt;&gt;&gt; # ...positioned along the X axis from the volume center...     &gt;&gt;&gt; camera.transform = Transform().translated(center).translated((100, 0, 0))     &gt;&gt;&gt; # ...looking at the center...     &gt;&gt;&gt; camera.look_at(center, up=(0, 0, 1))     &gt;&gt;&gt; # ...that orbits around the center     &gt;&gt;&gt; camera.controller = Orbit(center=center)</p> <p>Custom polar axis for Y-up scenes:     &gt;&gt;&gt; camera = Camera(     ...     controller=Orbit(center=(0, 0, 0), polar_axis=(0, 1, 0)),     ...     interactive=True,     ... )</p> Interactions <ul> <li>Left mouse drag: Orbit/rotate the camera around the center point</li> <li>Right mouse drag: Pan the orbit center (translates the focal point)</li> <li>Mouse wheel: Zoom toward/away from center (change radius)</li> </ul> Notes <p>Elevation is automatically clamped to [0\u00b0, 180\u00b0] to prevent the camera from going upside down. Without this clamping, the camera could rotate past the polar axis, causing horizontal mouse movement to make the foreground rotate in the opposite direction to the actual mouse movement.</p> See Also <p>PanZoom : 2D pan and zoom controller for orthographic views CameraController : Base class for camera controllers Camera : Camera class with controller field Camera.look_at : Method to orient camera toward a point</p> <p>Methods:</p> <ul> <li> <code>handle_event</code>             \u2013              <p>Handle mouse and wheel events to orbit the camera.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.Orbit.handle_event","title":"handle_event","text":"<pre><code>handle_event(event: Event, camera: Camera) -&gt; bool\n</code></pre> <p>Handle mouse and wheel events to orbit the camera.</p> Source code in <code>src/scenex/model/_nodes/camera.py</code> <pre><code>def handle_event(self, event: Event, camera: Camera) -&gt; bool:\n    \"\"\"Handle mouse and wheel events to orbit the camera.\"\"\"\n    if not camera.interactive:\n        return False\n\n    handled = False\n    center_array = np.asarray(self.center)\n\n    # Orbit on mouse move with left button held\n    if (\n        isinstance(event, MouseMoveEvent)\n        and event.buttons == MouseButton.LEFT\n        and self._last_canvas_pos is not None\n    ):\n        # The process of orbiting is as follows:\n        # 1. Compute the azimuth and elevation changes based on mouse movement.\n        #   - Azimuth describes the angle between the the positive X axis and\n        #       the projection of the camera's position onto the XY plane.\n        #   - Elevation describes the angle between the camera's position and\n        #       the positive Z axis.\n        # 2. Ensure these changes are clamped to valid ranges (only really\n        #   applies to elevation).\n        # 3. Adjust the current transform by:\n        #   a. Translating by the negative of the centerpoint, to take it out of\n        #       the computation.\n        #   b. Rotating to adjust the elevation. The axis of rotation is defined\n        #       by the camera's right vector. Note that this is done before the\n        #       azimuth adjustment because that adjustment will alter the\n        #       camera's right vector.\n        #   c. Rotating to adjust the azimuth. The axis of rotation is always\n        #       the positive Z axis.\n        #   d. Translating by the centerpoint, to reorient the camera around\n        #           that centerpoint.\n\n        # Step 0: Gather transform components, relative to camera center\n        orbit_mat = camera.transform.translated(-center_array)\n        position, _rotation, _scale = la.mat_decompose(orbit_mat.T)\n        camera_right = np.cross(camera.forward, camera.up)\n\n        # Step 1\n        d_azimuth = self._last_canvas_pos[0] - event.canvas_pos[0]\n        d_elevation = self._last_canvas_pos[1] - event.canvas_pos[1]\n\n        # Step 2\n        e_bound = float(la.vec_angle(position, (0, 0, 1)) * 180 / math.pi)\n        if e_bound + d_elevation &lt; 0:\n            d_elevation = -e_bound\n        if e_bound + d_elevation &gt; 180:\n            d_elevation = 180 - e_bound\n\n        # Step 3\n        camera.transform = (\n            camera.transform.translated(-center_array)  # 3a\n            .rotated(d_elevation, camera_right)  # 3b\n            .rotated(d_azimuth, self.polar_axis)  # 3c\n            .translated(center_array)  # 3d\n        )\n\n        handled = True\n\n    # Pan on mouse press with right button\n    elif isinstance(event, MousePressEvent) and event.buttons == MouseButton.RIGHT:\n        self._pan_ray = event.world_ray\n\n    # Pan on mouse move with right button held\n    elif (\n        isinstance(event, MouseMoveEvent)\n        and event.buttons == MouseButton.RIGHT\n        and self._pan_ray is not None\n    ):\n        dr = np.linalg.norm(camera.transform.map((0, 0, 0))[:3] - center_array)\n        old_center = self._pan_ray.origin[:3] + np.multiply(\n            dr, self._pan_ray.direction\n        )\n        new_center = event.world_ray.origin[:3] + np.multiply(\n            dr, event.world_ray.direction\n        )\n        diff = np.subtract(old_center, new_center)\n        camera.transform = camera.transform.translated(diff)\n        # Update the center\n        new_center_array = center_array + diff\n        new_center_tuple = (\n            float(new_center_array[0]),\n            float(new_center_array[1]),\n            float(new_center_array[2]),\n        )\n        self.center = new_center_tuple\n        handled = True\n\n    elif isinstance(event, WheelEvent):\n        _dx, dy = event.angle_delta\n        if dy:\n            dr = camera.transform.map((0, 0, 0))[:3] - center_array\n            zoom = self._zoom_factor(dy)\n            camera.transform = camera.transform.translated(dr * (zoom - 1))\n        handled = True\n\n    if isinstance(event, MouseEvent):\n        self._last_canvas_pos = event.canvas_pos\n    return handled\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Orbit.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.PanZoom","title":"PanZoom","text":"<p>               Bases: <code>CameraController</code></p> <pre><code>\n              flowchart TD\n              scenex.model.PanZoom[PanZoom]\n              scenex.model._nodes.camera.CameraController[CameraController]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.camera.CameraController --&gt; scenex.model.PanZoom\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.camera.CameraController\n                \n\n\n\n              click scenex.model.PanZoom href \"\" \"scenex.model.PanZoom\"\n              click scenex.model._nodes.camera.CameraController href \"\" \"scenex.model._nodes.camera.CameraController\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>2D pan and zoom controller for orthographic views.</p> <p>PanZoom provides intuitive mouse-based navigation for 2D scenes and orthographic projections.</p> <p>The strategy operates in two complementary ways: - Panning (left mouse drag): Modifies camera.transform to translate the camera   position, maintaining the scene coordinates under the cursor. - Zooming (mouse wheel): Modifies camera.projection to scale the view, then   adjusts camera.transform to keep the zoom centered on the cursor position.</p> <p>Optional axis locking allows constraining interaction to horizontal or vertical movement only</p> <p>Attributes:</p> <ul> <li> <code>lock_x</code>               (<code>bool</code>)           \u2013            <p>If True, prevent horizontal panning and zooming. Movement is constrained to the vertical axis only. Default is False.</p> </li> <li> <code>lock_y</code>               (<code>bool</code>)           \u2013            <p>If True, prevent vertical panning and zooming. Movement is constrained to the horizontal axis only. Default is False.</p> </li> </ul> <p>Examples:</p> <p>Standard 2D pan and zoom:     &gt;&gt;&gt; camera = Camera(controller=PanZoom(), interactive=True)</p> <p>Lock horizontal movement for vertical scrolling only:     &gt;&gt;&gt; camera = Camera(controller=PanZoom(lock_x=True), interactive=True)</p> <p>Create an image viewer with pan/zoom:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; from scenex.utils import projections     &gt;&gt;&gt; my_data = np.random.rand(512, 512).astype(np.float32)     &gt;&gt;&gt; view = View(     ...     scene=Scene(children=[Image(data=my_data)]),     ...     camera=Camera(     ...         controller=PanZoom(),     ...         interactive=True,     ...     ),     ... )     &gt;&gt;&gt; projections.zoom_to_fit(view=view, type=\"orthographic\")</p> See Also <p>Orbit : 3D orbit controller for perspective views CameraController : Base class for camera controllers Camera : Camera class with controller field</p> <p>Methods:</p> <ul> <li> <code>handle_event</code>             \u2013              <p>Handle mouse and wheel events to pan/zoom the camera.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.PanZoom.handle_event","title":"handle_event","text":"<pre><code>handle_event(event: Event, camera: Camera) -&gt; bool\n</code></pre> <p>Handle mouse and wheel events to pan/zoom the camera.</p> Source code in <code>src/scenex/model/_nodes/camera.py</code> <pre><code>def handle_event(self, event: Event, camera: Camera) -&gt; bool:\n    \"\"\"Handle mouse and wheel events to pan/zoom the camera.\"\"\"\n    from scenex.app.events import (\n        MouseButton,\n        MouseMoveEvent,\n        MousePressEvent,\n        WheelEvent,\n    )\n\n    if not camera.interactive:\n        return False\n\n    handled = False\n\n    # Panning involves keeping a particular position underneath the cursor.\n    # That position is recorded on a left mouse button press.\n    if isinstance(event, MousePressEvent) and MouseButton.LEFT in event.buttons:\n        self._drag_pos = event.world_ray.origin[:2]\n    # Every time the cursor is moved, until the left mouse button is released,\n    # We translate the camera such that the position is back under the cursor\n    # (i.e. under the world ray origin)\n    elif (\n        isinstance(event, MouseMoveEvent)\n        and MouseButton.LEFT in event.buttons\n        and self._drag_pos\n    ):\n        new_pos = event.world_ray.origin[:2]\n        dx = self._drag_pos[0] - new_pos[0]\n        if not self.lock_x:\n            camera.transform = camera.transform.translated((dx, 0))\n        dy = self._drag_pos[1] - new_pos[1]\n        if not self.lock_y:\n            camera.transform = camera.transform.translated((0, dy))\n        handled = True\n\n    # Note that while panning adjusts the camera's transform matrix, zooming\n    # adjusts the projection matrix.\n    elif isinstance(event, WheelEvent):\n        # Zoom while keeping the position under the cursor fixed.\n        _dx, dy = event.angle_delta\n        if dy:\n            # Step 1: Adjust the projection matrix to zoom in or out.\n            zoom = self._zoom_factor(dy)\n            camera.projection = camera.projection.scaled(\n                (1 if self.lock_x else zoom, 1 if self.lock_y else zoom, 1.0)\n            )\n\n            # Step 2: Adjust the transform matrix to maintain the position\n            # under the cursor. The math is largely borrowed from\n            # https://github.com/pygfx/pygfx/blob/520af2d5bb2038ec309ef645e4a60d502f00d181/pygfx/controllers/_panzoom.py#L164\n\n            # Find the distance between the world ray and the camera\n            zoom_center = np.asarray(event.world_ray.origin)[:2]\n            camera_center = np.asarray(camera.transform.map((0, 0)))[:2]\n            # Compute the world distance before the zoom\n            delta_screen1 = zoom_center - camera_center\n            # Compute the world distance after the zoom\n            delta_screen2 = delta_screen1 * zoom\n            # The pan is the difference between the two\n            pan = (delta_screen2 - delta_screen1) / zoom\n            camera.transform = camera.transform.translated(\n                (\n                    pan[0] if not self.lock_x else 0,\n                    pan[1] if not self.lock_y else 0,\n                )\n            )\n            handled = True\n\n    return handled\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.PanZoom.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points","title":"Points","text":"<pre><code>Points(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <pre><code>\n              flowchart TD\n              scenex.model.Points[Points]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.node.Node --&gt; scenex.model.Points\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n              click scenex.model.Points href \"\" \"scenex.model.Points\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A collection of point markers rendered at specified coordinates.</p> <p>Points displays symbols (markers) at 2D or 3D coordinates in the scene. Each point is rendered using a specified symbol shape (disc, square, star, etc.) with customizable size, face color, and edge styling. Points support different scaling modes to control whether they maintain constant screen size or scale with the scene.</p> <p>Examples:</p> <p>Create simple point markers:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; vertices = np.random.rand(100, 2) * 100     &gt;&gt;&gt; points = Points(     ...     vertices=vertices,     ...     size=5,     ...     face_color=UniformColor(color=Color(\"red\")),     ... )</p> <p>Create points with custom symbols and styling:     &gt;&gt;&gt; points = Points(     ...     vertices=vertices,     ...     symbol=\"star\",     ...     size=20,     ...     face_color=UniformColor(color=Color(\"yellow\")),     ...     edge_color=UniformColor(color=Color(\"orange\")),     ...     edge_width=2,     ... )</p> <p>Create fixed-size points that don't scale with zoom:     &gt;&gt;&gt; points = Points(     ...     vertices=vertices,     ...     size=10,     ...     scaling=\"fixed\",     ...     face_color=UniformColor(color=Color(\"blue\")),     ... )</p> <p>Create 3D points:     &gt;&gt;&gt; vertices_3d = np.random.rand(50, 3) * 100     &gt;&gt;&gt; points = Points(vertices=vertices_3d, symbol=\"diamond\", size=15)</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/model/#scenex.model.Points.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Points.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Points.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Points.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.ResizePolicy","title":"ResizePolicy","text":"<p>               Bases: <code>EventedBase</code></p> <pre><code>\n              flowchart TD\n              scenex.model.ResizePolicy[ResizePolicy]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._base.EventedBase --&gt; scenex.model.ResizePolicy\n                \n\n\n              click scenex.model.ResizePolicy href \"\" \"scenex.model.ResizePolicy\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>Base class defining how a view adapts to changes in its layout dimensions.</p> <p>A ResizePolicy is invoked automatically when a view's layout dimensions change, providing a hook to adjust any aspect of the view in response. While the most common use case is adjusting the camera's projection matrix to maintain aspect ratio or fit content, strategies have full access to the view and can modify the camera, scene, layout, or any other properties as needed.</p> <p>Strategies are attached to View instances and called whenever the layout width or height changes, whether from user interaction (window resize, splitter drag) or programmatic updates.</p> <p>Examples:</p> <p>Maintain aspect ratio when view resizes:     &gt;&gt;&gt; view = View(camera=Camera(), on_resize=Letterbox())</p> <p>No resize behavior (omit the on_resize parameter):     &gt;&gt;&gt; view = View(camera=Camera())</p> See Also <p>Letterbox : Resize strategy that maintains aspect ratio View : View class that uses resize strategies Camera : Camera class with projection property</p> <p>Methods:</p> <ul> <li> <code>handle_resize</code>             \u2013              <p>Respond to view layout dimension changes.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.ResizePolicy.handle_resize","title":"handle_resize  <code>abstractmethod</code>","text":"<pre><code>handle_resize(view: View) -&gt; None\n</code></pre> <p>Respond to view layout dimension changes.</p> <p>This method is called automatically when the view's layout dimensions change. Implementations have full access to the view and can modify any of its properties.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_view.py</code> <pre><code>@abstractmethod\ndef handle_resize(self, view: View) -&gt; None:\n    \"\"\"\n    Respond to view layout dimension changes.\n\n    This method is called automatically when the view's layout dimensions change.\n    Implementations have full access to the view and can modify any of its\n    properties.\n\n    Parameters\n    ----------\n    view : View\n        The view being resized.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.ResizePolicy.handle_resize(view)","title":"<code>view</code>","text":"(<code>View</code>)           \u2013            <p>The view being resized.</p>"},{"location":"reference/scenex/model/#scenex.model.ResizePolicy.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene","title":"Scene","text":"<pre><code>Scene(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <pre><code>\n              flowchart TD\n              scenex.model.Scene[Scene]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.node.Node --&gt; scenex.model.Scene\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n              click scenex.model.Scene href \"\" \"scenex.model.Scene\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>The root container node for a scene graph.</p> <p>Scene is a specialized Node that serves as the root of a scene graph hierarchy. It contains all the visual elements (Images, Points, Lines, Meshes, etc.) and cameras that make up a complete 3D scene. While functionally identical to a Node, Scene provides semantic clarity that this is the top-level container.</p> <p>A Scene is typically associated with a View, which pairs it with a Camera to define what is rendered and how. Multiple views can display the same scene from different camera perspectives.</p> <p>Examples:</p> <p>Create a scene with visual elements:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; my_image = np.random.rand(100, 100).astype(np.float32)     &gt;&gt;&gt; my_points = np.random.rand(100, 3).astype(np.float32)     &gt;&gt;&gt; scene = Scene(     ...     children=[     ...         Image(data=my_image),     ...         Points(     ...             vertices=my_points,     ...             face_color=UniformColor(color=Color(\"red\")),     ...         ),     ...     ]     ... )</p> <p>Create an empty scene and later add children:     &gt;&gt;&gt; scene = Scene()     &gt;&gt;&gt; scene.add_child(Image(data=my_image))     &gt;&gt;&gt; scene.add_child(Points(vertices=my_points))</p> <p>Create a hierarchical scene with nested nodes:     &gt;&gt;&gt; grandchild = Image(data=my_image)     &gt;&gt;&gt; parent = Points(vertices=my_points)     &gt;&gt;&gt; scene = Scene(children=[parent])</p> <p>Use a scene with a view:     &gt;&gt;&gt; view = View(scene=scene, camera=Camera())     &gt;&gt;&gt; canvas = Canvas(views=[view])</p> Notes <p>Scene inherits all Node attributes and methods including transform, visible, opacity, and children management. The scene itself does not have visual representation; it only serves as a container for renderable nodes.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>passes_through</code>             \u2013              <p>Returns the depth t at which the provided ray intersects this node.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/scene.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[\"Node | dict[str, Any]\"] = (),\n    **data: \"Unpack[NodeKwargs]\",\n) -&gt; None: ...\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/model/#scenex.model.Scene.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene.passes_through","title":"passes_through","text":"<pre><code>passes_through(ray: Ray) -&gt; float | None\n</code></pre> <p>Returns the depth t at which the provided ray intersects this node.</p> <p>The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t, where t&gt;=0</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>t</code> (              <code>float | None</code> )          \u2013            <p>The depth t at which the ray intersects the node, or None if it never intersects.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def passes_through(self, ray: Ray) -&gt; float | None:\n    \"\"\"Returns the depth t at which the provided ray intersects this node.\n\n    The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t,\n    where t&gt;=0\n\n    Parameters\n    ----------\n    ray : Ray\n        The ray passing through the scene\n\n    Returns\n    -------\n    t: float | None\n        The depth t at which the ray intersects the node, or None if it never\n        intersects.\n    \"\"\"\n    # Nodes that want to support ray intersection should override this method.\n    return None\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene.passes_through(ray)","title":"<code>ray</code>","text":"(<code>Ray</code>)           \u2013            <p>The ray passing through the scene</p>"},{"location":"reference/scenex/model/#scenex.model.Scene.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Scene.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Scene.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Scene.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Text","title":"Text","text":"<pre><code>Text(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <pre><code>\n              flowchart TD\n              scenex.model.Text[Text]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.node.Node --&gt; scenex.model.Text\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n              click scenex.model.Text href \"\" \"scenex.model.Text\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A text label positioned in 3D world space.</p> <p>The text maintains a constant screen size regardless of camera zoom or distance, making it useful for labels, annotations, and markers. The text is positioned at the node's transformed origin point.</p> <p>Examples:</p> <p>Create a simple text label:     &gt;&gt;&gt; text = Text(text=\"Hello World\", color=Color(\"white\"), size=14)</p> Notes <p>Text maintains constant screen size, not world size. The font size is specified in pixels and does not scale with camera zoom or distance from the viewer.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>passes_through</code>             \u2013              <p>Returns the depth t at which the provided ray intersects this node.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Text.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/model/#scenex.model.Text.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Text.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Text.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Text.passes_through","title":"passes_through","text":"<pre><code>passes_through(ray: Ray) -&gt; float | None\n</code></pre> <p>Returns the depth t at which the provided ray intersects this node.</p> <p>The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t, where t&gt;=0</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>t</code> (              <code>float | None</code> )          \u2013            <p>The depth t at which the ray intersects the node, or None if it never intersects.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def passes_through(self, ray: Ray) -&gt; float | None:\n    \"\"\"Returns the depth t at which the provided ray intersects this node.\n\n    The ray, in this case, is defined by R(t) = ray_origin + ray_direction * t,\n    where t&gt;=0\n\n    Parameters\n    ----------\n    ray : Ray\n        The ray passing through the scene\n\n    Returns\n    -------\n    t: float | None\n        The depth t at which the ray intersects the node, or None if it never\n        intersects.\n    \"\"\"\n    # Nodes that want to support ray intersection should override this method.\n    return None\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Text.passes_through(ray)","title":"<code>ray</code>","text":"(<code>Ray</code>)           \u2013            <p>The ray passing through the scene</p>"},{"location":"reference/scenex/model/#scenex.model.Text.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Text.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Text.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Text.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Text.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Text.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform","title":"Transform","text":"<p>               Bases: <code>RootModel</code></p> <pre><code>\n              flowchart TD\n              scenex.model.Transform[Transform]\n\n              \n\n              click scenex.model.Transform href \"\" \"scenex.model.Transform\"\n            </code></pre> <p>A 4x4 homogeneous transformation matrix for 3D affine transformations.</p> <p>Transformations use homogeneous coordinates, where 3D points (x, y, z) are represented as 4-vectors (x, y, z, 1). This enables affine transformations (translation, rotation, scaling) to be represented as matrix multiplication.</p> <p>The Transform class is immutable (frozen). Operations like translated(), rotated(), and scaled() return new Transform instances rather than modifying the original.</p> <p>Examples:</p> <p>Create an identity transform:     &gt;&gt;&gt; transform = Transform()</p> <p>Translate an object:     &gt;&gt;&gt; transform = Transform().translated((10, 20, 30))</p> <p>Rotate 45 degrees around the z-axis:     &gt;&gt;&gt; transform = Transform().rotated(45, axis=(0, 0, 1))</p> <p>Scale uniformly by 2x:     &gt;&gt;&gt; transform = Transform().scaled((2, 2, 2))</p> <p>Chain multiple transformations:     &gt;&gt;&gt; transform = (     ...     Transform()     ...     .translated((10, 0, 0))     ...     .rotated(45, (0, 0, 1))     ...     .scaled((2, 2, 2))     ... )</p> <p>Rotate around a specific point:     &gt;&gt;&gt; transform = Transform().rotated(90, axis=(0, 0, 1), about=(10, 10, 0))</p> <p>Transform coordinates:     &gt;&gt;&gt; points = np.array([[0, 0, 0], [1, 1, 1]])     &gt;&gt;&gt; transformed = transform.map(points)</p> <p>Combine two transforms:     &gt;&gt;&gt; transform1 = Transform().translated((5, 0, 0))     &gt;&gt;&gt; transform2 = Transform().scaled((2, 2, 2))     &gt;&gt;&gt; combined = transform1 @ transform2</p> <p>Invert a transform:     &gt;&gt;&gt; inverse = transform.inv()</p> Notes <ul> <li>Transformations are applied in the order they are chained</li> <li>The transform is immutable; all operations return new instances</li> <li>Uses right-multiplication convention: point @ matrix</li> <li>Default rotation axis is (0, 0, 1) - the z-axis</li> </ul> <p>Methods:</p> <ul> <li> <code>chain</code>             \u2013              <p>Chain multiple transforms together.</p> </li> <li> <code>dot</code>             \u2013              <p>Return the dot product of this transform with another.</p> </li> <li> <code>imap</code>             \u2013              <p>Inverse map coordinates.</p> </li> <li> <code>inv</code>             \u2013              <p>Return the inverse of the transform.</p> </li> <li> <code>is_null</code>             \u2013              <p>Return True if the transform is the identity matrix.</p> </li> <li> <code>map</code>             \u2013              <p>Map coordinates.</p> </li> <li> <code>rotated</code>             \u2013              <p>Return new transform, rotated some angle about a given axis.</p> </li> <li> <code>scaled</code>             \u2013              <p>Return new transform, scaled about a given origin.</p> </li> <li> <code>translated</code>             \u2013              <p>Return new transform, translated by pos.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>T</code>               (<code>Transform</code>)           \u2013            <p>Return the transpose of the transform.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.Transform.T","title":"T  <code>property</code>","text":"<pre><code>T: Transform\n</code></pre> <p>Return the transpose of the transform.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.chain","title":"chain  <code>classmethod</code>","text":"<pre><code>chain(*transforms: Transform) -&gt; Transform\n</code></pre> <p>Chain multiple transforms together.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>Transform</code> )          \u2013            <p>Chained transform.</p> </li> </ul> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>@classmethod\ndef chain(cls, *transforms: Transform) -&gt; Transform:\n    \"\"\"Chain multiple transforms together.\n\n    Parameters\n    ----------\n    transforms : Transform\n        Transforms to chain.\n\n    Returns\n    -------\n    transform : Transform\n        Chained transform.\n    \"\"\"\n    return reduce(lambda a, b: a @ b, transforms, cls())\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.chain(transforms)","title":"<code>transforms</code>","text":"(<code>Transform</code>, default:                   <code>()</code> )           \u2013            <p>Transforms to chain.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.dot","title":"dot","text":"<pre><code>dot(other: Transform | ArrayLike) -&gt; Transform\n</code></pre> <p>Return the dot product of this transform with another.</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def dot(self, other: Transform | ArrayLike) -&gt; Transform:\n    \"\"\"Return the dot product of this transform with another.\"\"\"\n    if isinstance(other, Transform):\n        other = other.root\n    return Transform(np.dot(self.root, other))\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.imap","title":"imap","text":"<pre><code>imap(coords: ArrayLike) -&gt; NDArray\n</code></pre> <p>Inverse map coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>coords</code> (              <code>ndarray</code> )          \u2013            <p>Coordinates.</p> </li> </ul> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>@_arg_to_vec4\ndef imap(self, coords: ArrayLike) -&gt; NDArray:\n    \"\"\"Inverse map coordinates.\n\n    Parameters\n    ----------\n    coords : array-like\n        Coordinates to inverse map.\n\n    Returns\n    -------\n    coords : ndarray\n        Coordinates.\n    \"\"\"\n    return cast(\"NDArray\", np.dot(coords, np.linalg.inv(self.root)))\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.imap(coords)","title":"<code>coords</code>","text":"(<code>array - like</code>)           \u2013            <p>Coordinates to inverse map.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.inv","title":"inv","text":"<pre><code>inv() -&gt; Transform\n</code></pre> <p>Return the inverse of the transform.</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def inv(self) -&gt; Transform:\n    \"\"\"Return the inverse of the transform.\"\"\"\n    return Transform(np.linalg.inv(self.root))\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.is_null","title":"is_null","text":"<pre><code>is_null() -&gt; bool\n</code></pre> <p>Return True if the transform is the identity matrix.</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def is_null(self) -&gt; bool:\n    \"\"\"Return True if the transform is the identity matrix.\"\"\"\n    return np.allclose(self.root, np.eye(4))\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.map","title":"map","text":"<pre><code>map(coords: ArrayLike) -&gt; NDArray\n</code></pre> <p>Map coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>coords</code> (              <code>ndarray</code> )          \u2013            <p>Coordinates.</p> </li> </ul> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>@_arg_to_vec4\ndef map(self, coords: ArrayLike) -&gt; NDArray:\n    \"\"\"Map coordinates.\n\n    Parameters\n    ----------\n    coords : array-like\n        Coordinates to map.\n\n    Returns\n    -------\n    coords : ndarray\n        Coordinates.\n    \"\"\"\n    # looks backwards, but both matrices are transposed.\n    return cast(\"NDArray\", np.dot(coords, self.root))\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.map(coords)","title":"<code>coords</code>","text":"(<code>array - like</code>)           \u2013            <p>Coordinates to map.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.rotated","title":"rotated","text":"<pre><code>rotated(\n    angle: float,\n    axis: ArrayLike = (0, 0, 1),\n    about: ArrayLike | None = None,\n) -&gt; Transform\n</code></pre> <p>Return new transform, rotated some angle about a given axis.</p> <p>The rotation is applied after the transformations already present in the matrix.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def rotated(\n    self, angle: float, axis: ArrayLike = (0, 0, 1), about: ArrayLike | None = None\n) -&gt; Transform:\n    \"\"\"Return new transform, rotated some angle about a given axis.\n\n    The rotation is applied *after* the transformations already present\n    in the matrix.\n\n    Parameters\n    ----------\n    angle : float\n        The angle of rotation, in degrees.\n    axis : array-like\n        The x, y and z coordinates of the axis vector to rotate around.\n        By default, will rotate around the z-axis: `(0, 0, 1)`.\n    about : array-like or None\n        The x, y and z coordinates to rotate around. If None, will rotate around\n        the origin (0, 0, 0).\n    \"\"\"\n    if about is not None:\n        about = as_vec4(about)[0, :3]\n        return self.translated(-about).dot(rotate(angle, axis)).translated(about)\n    return self.dot(rotate(angle, axis))\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.rotated(angle)","title":"<code>angle</code>","text":"(<code>float</code>)           \u2013            <p>The angle of rotation, in degrees.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.rotated(axis)","title":"<code>axis</code>","text":"(<code>array - like</code>, default:                   <code>(0, 0, 1)</code> )           \u2013            <p>The x, y and z coordinates of the axis vector to rotate around. By default, will rotate around the z-axis: <code>(0, 0, 1)</code>.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.rotated(about)","title":"<code>about</code>","text":"(<code>array - like or None</code>, default:                   <code>None</code> )           \u2013            <p>The x, y and z coordinates to rotate around. If None, will rotate around the origin (0, 0, 0).</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.scaled","title":"scaled","text":"<pre><code>scaled(\n    scale_factor: ArrayLike, center: ArrayLike | None = None\n) -&gt; Transform\n</code></pre> <p>Return new transform, scaled about a given origin.</p> <p>The scaling is applied after the transformations already present in the matrix.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def scaled(\n    self, scale_factor: ArrayLike, center: ArrayLike | None = None\n) -&gt; Transform:\n    \"\"\"Return new transform, scaled about a given origin.\n\n    The scaling is applied *after* the transformations already present\n    in the matrix.\n\n    Parameters\n    ----------\n    scale_factor : array-like\n        Scale factors along x, y and z axes.\n    center : array-like or None\n        The x, y and z coordinates to scale around. If None,\n        (0, 0, 0) will be used.\n    \"\"\"\n    _scale = scale(as_vec4(scale_factor, default=(1, 1, 1, 1))[0, :3])\n    if center is not None:\n        center = as_vec4(center)[0, :3]\n        _scale = np.dot(np.dot(translate(-center), _scale), translate(center))\n    return self.dot(_scale)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.scaled(scale_factor)","title":"<code>scale_factor</code>","text":"(<code>array - like</code>)           \u2013            <p>Scale factors along x, y and z axes.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.scaled(center)","title":"<code>center</code>","text":"(<code>array - like or None</code>, default:                   <code>None</code> )           \u2013            <p>The x, y and z coordinates to scale around. If None, (0, 0, 0) will be used.</p>"},{"location":"reference/scenex/model/#scenex.model.Transform.translated","title":"translated","text":"<pre><code>translated(pos: ArrayLike) -&gt; Transform\n</code></pre> <p>Return new transform, translated by pos.</p> <p>The translation is applied after the transformations already present in the matrix.</p> <p>Parameters:</p> Source code in <code>src/scenex/model/_transform.py</code> <pre><code>def translated(self, pos: ArrayLike) -&gt; Transform:\n    \"\"\"Return new transform, translated by pos.\n\n    The translation is applied *after* the transformations already present\n    in the matrix.\n\n    Parameters\n    ----------\n    pos : ArrayLike\n        Position (x, y, z) to translate by.\n    \"\"\"\n    pos = as_vec4(np.array(pos))\n    return self.dot(translate(pos[0, :3]))\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Transform.translated(pos)","title":"<code>pos</code>","text":"(<code>ArrayLike</code>)           \u2013            <p>Position (x, y, z) to translate by.</p>"},{"location":"reference/scenex/model/#scenex.model.UniformColor","title":"UniformColor","text":"<pre><code>UniformColor(**data: Any)\n</code></pre> <p>               Bases: <code>ColorModel</code></p> <pre><code>\n              flowchart TD\n              scenex.model.UniformColor[UniformColor]\n              scenex.model._color.ColorModel[ColorModel]\n\n                              scenex.model._color.ColorModel --&gt; scenex.model.UniformColor\n                \n\n\n              click scenex.model.UniformColor href \"\" \"scenex.model.UniformColor\"\n              click scenex.model._color.ColorModel href \"\" \"scenex.model._color.ColorModel\"\n            </code></pre> <p>Uniform coloring strategy for scene nodes.</p> <p>This model applies a single color to the entire geometry (mesh, line, points, etc). The <code>color</code> field is a single <code>Color</code> instance (e.g. Color(\"red\")).</p> <p>Examples:</p> <p>Uniform coloring:     &gt;&gt;&gt; from cmap import Color     &gt;&gt;&gt; from scenex import UniformColor     &gt;&gt;&gt; model = UniformColor(color=Color(\"red\"))</p> Source code in <code>src/scenex/model/_color.py</code> <pre><code>def __init__(self, **data: Any) -&gt; None:\n    if type(self) is ColorModel:\n        raise TypeError(\"ColorModel cannot be instantiated directly\")\n    super().__init__(**data)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.VertexColors","title":"VertexColors","text":"<pre><code>VertexColors(**data: Any)\n</code></pre> <p>               Bases: <code>ColorModel</code></p> <pre><code>\n              flowchart TD\n              scenex.model.VertexColors[VertexColors]\n              scenex.model._color.ColorModel[ColorModel]\n\n                              scenex.model._color.ColorModel --&gt; scenex.model.VertexColors\n                \n\n\n              click scenex.model.VertexColors href \"\" \"scenex.model.VertexColors\"\n              click scenex.model._color.ColorModel href \"\" \"scenex.model._color.ColorModel\"\n            </code></pre> <p>Per-vertex coloring strategy for mesh, line, or points nodes.</p> <p>This model applies a different color to each vertex. The <code>color</code> field is a sequence of <code>Color</code> instances, one for each vertex.</p> <p>Examples:</p> <p>Per-vertex coloring:     &gt;&gt;&gt; from cmap import Color     &gt;&gt;&gt; from scenex import VertexColors     &gt;&gt;&gt; model = VertexColors(     ...     color=[Color(\"yellow\"), Color(\"purple\"), Color(\"cyan\")]     ... )</p> Source code in <code>src/scenex/model/_color.py</code> <pre><code>def __init__(self, **data: Any) -&gt; None:\n    if type(self) is ColorModel:\n        raise TypeError(\"ColorModel cannot be instantiated directly\")\n    super().__init__(**data)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.View","title":"View","text":"<p>               Bases: <code>EventedBase</code></p> <pre><code>\n              flowchart TD\n              scenex.model.View[View]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._base.EventedBase --&gt; scenex.model.View\n                \n\n\n              click scenex.model.View href \"\" \"scenex.model.View\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A rectangular viewport that displays a scene through a camera.</p> <p>A View represents a rectangular area on a canvas that renders a scene graph through a specific camera perspective. Each view associates exactly one scene with one camera, defining what is displayed and how it is viewed. Multiple views can exist on a single canvas, each potentially showing different scenes or the same scene from different camera angles.</p> <p>Examples:</p> <p>Create a view with a scene containing an image:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; my_array = np.random.rand(100, 100).astype(np.float32)     &gt;&gt;&gt; scene = Scene(children=[Image(data=my_array)])     &gt;&gt;&gt; view = View(scene=scene, camera=Camera())</p> <p>Create a view with interactive camera and letterbox resizing:     &gt;&gt;&gt; view = View(     ...     scene=scene,     ...     camera=Camera(controller=PanZoom(), interactive=True),     ...     on_resize=Letterbox(),     ... )</p> <p>Add a view to a canvas:     &gt;&gt;&gt; canvas = Canvas()     &gt;&gt;&gt; canvas.views.append(view)</p> <p>Methods:</p> <ul> <li> <code>filter_event</code>             \u2013              <p>Filters the event.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Post-initialization hook for the model.</p> </li> <li> <code>render</code>             \u2013              <p>Render the view to an array.</p> </li> <li> <code>set_event_filter</code>             \u2013              <p>Registers a callable to filter events.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>canvas</code>               (<code>Canvas</code>)           \u2013            <p>The canvas that the view is on.</p> </li> </ul>"},{"location":"reference/scenex/model/#scenex.model.View.canvas","title":"canvas  <code>property</code> <code>writable</code>","text":"<pre><code>canvas: Canvas\n</code></pre> <p>The canvas that the view is on.</p> <p>If one hasn't been created/assigned, a new one is created.</p>"},{"location":"reference/scenex/model/#scenex.model.View.filter_event","title":"filter_event","text":"<pre><code>filter_event(event: Event) -&gt; bool\n</code></pre> <p>Filters the event.</p> <p>This method allows the larger view to react to events that: 1. Require summarization of multiple smaller event responses. 2. Could not be picked up by a node (e.g. mouse leaving an image).</p> <p>Note the name has parity with Node.filter_event, but there's not much filtering going on.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event should not be propagated to other handlers.</p> </li> </ul> Source code in <code>src/scenex/model/_view.py</code> <pre><code>def filter_event(self, event: Event) -&gt; bool:\n    \"\"\"\n    Filters the event.\n\n    This method allows the larger view to react to events that:\n    1. Require summarization of multiple smaller event responses.\n    2. Could not be picked up by a node (e.g. mouse leaving an image).\n\n    Note the name has parity with Node.filter_event, but there's not much filtering\n    going on.\n\n    Parameters\n    ----------\n    event : Event\n        An event occurring in the view.\n\n    Returns\n    -------\n    bool\n        True iff the event should not be propagated to other handlers.\n    \"\"\"\n    if self._filter:\n        handled = self._filter(event)\n        if not isinstance(handled, bool):\n            # Some widget frameworks (i.e. Qt) get upset when non-booleans are\n            # returned. If the event-filter does not return a boolean, rather than\n            # letting that propagate upwards, we log a warning and return False.\n            logger.warning(\n                f\"Event filter {self._filter} did not return a boolean. \"\n                \"Returning False.\"\n            )\n            # Return False. We assume that if the user wanted to block future\n            # processing, they'd be less likely to forget a boolean return.\n            # Further, allowing downstream processing is a clear sign to they author\n            # that they forgot to block propagation.\n            handled = False\n        return handled\n    return False\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.View.filter_event(event)","title":"<code>event</code>","text":"(<code>Event</code>)           \u2013            <p>An event occurring in the view.</p>"},{"location":"reference/scenex/model/#scenex.model.View.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Post-initialization hook for the model.</p> Source code in <code>src/scenex/model/_view.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Post-initialization hook for the model.\"\"\"\n    super().model_post_init(__context)\n    self.camera.parent = self.scene\n\n    # FIXME: Reconnect this when the layout is changed\n    self.layout.events.width.connect(self._on_layout_change)\n    self.layout.events.height.connect(self._on_layout_change)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.View.render","title":"render","text":"<pre><code>render() -&gt; ndarray\n</code></pre> <p>Render the view to an array.</p> Source code in <code>src/scenex/model/_view.py</code> <pre><code>def render(self) -&gt; np.ndarray:\n    \"\"\"Render the view to an array.\"\"\"\n    if adaptors := self._get_adaptors():\n        return cast(\"ViewAdaptor\", adaptors[0])._snx_render()\n    raise RuntimeError(\"No adaptor found for View.\")\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.View.set_event_filter","title":"set_event_filter","text":"<pre><code>set_event_filter(\n    callable: Callable[[Event], bool] | None,\n) -&gt; Callable[[Event], bool] | None\n</code></pre> <p>Registers a callable to filter events.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Callable[[Event], bool] | None</code>           \u2013            <p>The previous event filter, or None if there was no filter.</p> </li> <li> <code>Note the name has parity with Node.filter_event, but there's not much filtering</code>           \u2013            </li> <li> <code>going on.</code>           \u2013            </li> </ul> Source code in <code>src/scenex/model/_view.py</code> <pre><code>def set_event_filter(\n    self, callable: Callable[[Event], bool] | None\n) -&gt; Callable[[Event], bool] | None:\n    \"\"\"\n    Registers a callable to filter events.\n\n    Parameters\n    ----------\n    callable : Callable[[Event], bool] | None\n        A callable that takes an Event and returns True if the event was handled,\n        False otherwise. Passing None is equivalent to removing any existing filter.\n        By returning True, the callable indicates that the event has been handled\n        and should not be propagated to subsequent handlers.\n\n    Returns\n    -------\n    Callable[[Event], bool] | None\n        The previous event filter, or None if there was no filter.\n\n    Note the name has parity with Node.filter_event, but there's not much filtering\n    going on.\n    \"\"\"\n    old, self._filter = self._filter, callable\n    return old\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.View.set_event_filter(callable)","title":"<code>callable</code>","text":"(<code>Callable[[Event], bool] | None</code>)           \u2013            <p>A callable that takes an Event and returns True if the event was handled, False otherwise. Passing None is equivalent to removing any existing filter. By returning True, the callable indicates that the event has been handled and should not be propagated to subsequent handlers.</p>"},{"location":"reference/scenex/model/#scenex.model.Volume","title":"Volume","text":"<pre><code>Volume(\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n)\n</code></pre> <p>               Bases: <code>Image</code></p> <pre><code>\n              flowchart TD\n              scenex.model.Volume[Volume]\n              scenex.model._nodes.image.Image[Image]\n              scenex.model._nodes.node.Node[Node]\n              scenex.model._base.EventedBase[EventedBase]\n\n                              scenex.model._nodes.image.Image --&gt; scenex.model.Volume\n                                scenex.model._nodes.node.Node --&gt; scenex.model._nodes.image.Image\n                                scenex.model._base.EventedBase --&gt; scenex.model._nodes.node.Node\n                \n\n\n\n\n              click scenex.model.Volume href \"\" \"scenex.model.Volume\"\n              click scenex.model._nodes.image.Image href \"\" \"scenex.model._nodes.image.Image\"\n              click scenex.model._nodes.node.Node href \"\" \"scenex.model._nodes.node.Node\"\n              click scenex.model._base.EventedBase href \"\" \"scenex.model._base.EventedBase\"\n            </code></pre> <p>A 3D volumetric dataset rendered with volume rendering techniques.</p> <p>Volume extends Image to support 3D volumetric data. Unlike images which are 2D arrays, volumes are 3D arrays of intensity values that are rendered using volume rendering techniques like maximum intensity projection (MIP) or isosurface rendering.</p> <p>The volume uses ZYX dimension ordering, meaning data.shape = (depth, height, width). Like Image, the volume supports colormapping, intensity normalization, and gamma correction. The rendering mode determines how the 3D data is projected onto the 2D viewing plane.</p> <p>Examples:</p> <p>Create a volume with MIP rendering:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; data = np.random.rand(50, 100, 100)  # ZYX dimensions     &gt;&gt;&gt; volume = Volume(data=data, render_mode=\"mip\")</p> <p>Create a volume with custom colormap and intensity range:     &gt;&gt;&gt; volume = Volume(     ...     data=data,     ...     cmap=Colormap(\"viridis\"),     ...     clims=(0, 1),     ...     render_mode=\"iso\",     ... )</p> Notes <p>Volume inherits all Image attributes including data, cmap, clims, gamma, and interpolation. The data should be a 3D array with shape (depth, height, width) following ZYX convention.</p> <p>Methods:</p> <ul> <li> <code>add_child</code>             \u2013              <p>Add a child node to this node.</p> </li> <li> <code>iter_parents</code>             \u2013              <p>Return list of parents starting from this node.</p> </li> <li> <code>model_post_init</code>             \u2013              <p>Called after the model is initialized.</p> </li> <li> <code>path_to_node</code>             \u2013              <p>Return two lists describing the path from this node to another.</p> </li> <li> <code>remove_child</code>             \u2013              <p>Remove a child node from this node. Does not raise if child is missing.</p> </li> <li> <code>transform_to_node</code>             \u2013              <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>tuple[Node, ...]</code>)           \u2013            <p>Return a tuple of the children of this node.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def __init__(\n    self,\n    *,\n    children: Iterable[Node | dict[str, Any]] = (),\n    **data: Unpack[NodeKwargs],\n) -&gt; None:\n    # prevent direct instantiation.\n    # makes it easier to use NodeUnion without having to deal with self-reference.\n    if type(self) is Node:\n        raise TypeError(\"Node cannot be instantiated directly. Use a subclass.\")\n\n    super().__init__(**data)  # pyright: ignore[reportCallIssue]\n\n    for ch in children:\n        if not isinstance(ch, Node):\n            ch = self._validate_json(ch)\n        self.add_child(ch)  # type: ignore [arg-type]\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Volume.children","title":"children  <code>property</code>","text":"<pre><code>children: tuple[Node, ...]\n</code></pre> <p>Return a tuple of the children of this node.</p>"},{"location":"reference/scenex/model/#scenex.model.Volume.add_child","title":"add_child","text":"<pre><code>add_child(child: AnyNode) -&gt; None\n</code></pre> <p>Add a child node to this node.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def add_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Add a child node to this node.\"\"\"\n    self._children.append(child)\n    child.parent = cast(\"AnyNode\", self)\n    self.child_added.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Volume.iter_parents","title":"iter_parents","text":"<pre><code>iter_parents() -&gt; Iterator[Node]\n</code></pre> <p>Return list of parents starting from this node.</p> <p>The chain ends at the first node with no parents.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def iter_parents(self) -&gt; Iterator[Node]:\n    \"\"\"Return list of parents starting from this node.\n\n    The chain ends at the first node with no parents.\n    \"\"\"\n    yield self\n\n    x = self\n    while True:\n        try:\n            parent = x.parent\n        except Exception:\n            break\n        if parent is None:\n            break\n        yield parent\n        x = parent\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Volume.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context: Any) -&gt; None\n</code></pre> <p>Called after the model is initialized.</p> Source code in <code>src/scenex/model/_base.py</code> <pre><code>def model_post_init(self, __context: Any) -&gt; None:\n    \"\"\"Called after the model is initialized.\"\"\"\n    objects.register(self)\n    logger.debug(\n        \"Created model %-12r id: %s\", type(self).__name__, self._model_id.hex[:8]\n    )\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Volume.path_to_node","title":"path_to_node","text":"<pre><code>path_to_node(other: Node) -&gt; tuple[list[Node], list[Node]]\n</code></pre> <p>Return two lists describing the path from this node to another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>p1</code> (              <code>list</code> )          \u2013            <p>First path (see below).</p> </li> <li> <code>p2</code> (              <code>list</code> )          \u2013            <p>Second path (see below).</p> </li> </ul> Notes <p>The first list starts with this node and ends with the common parent between the endpoint nodes. The second list contains the remainder of the path from the common parent to the specified ending node.</p> <p>For example, consider the following scenegraph::</p> <pre><code>A --- B --- C --- D\n                           --- E --- F\n</code></pre> <p>Calling <code>D.node_path(F)</code> will return::</p> <pre><code>([D, C, B], [E, F])\n</code></pre> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def path_to_node(self, other: Node) -&gt; tuple[list[Node], list[Node]]:\n    \"\"\"Return two lists describing the path from this node to another.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    p1 : list\n        First path (see below).\n    p2 : list\n        Second path (see below).\n\n    Notes\n    -----\n    The first list starts with this node and ends with the common parent\n    between the endpoint nodes. The second list contains the remainder of\n    the path from the common parent to the specified ending node.\n\n    For example, consider the following scenegraph::\n\n        A --- B --- C --- D\n               \\\n                --- E --- F\n\n    Calling `D.node_path(F)` will return::\n\n        ([D, C, B], [E, F])\n\n    \"\"\"\n    my_parents = list(self.iter_parents())\n    their_parents = list(other.iter_parents())\n    common_parent = next((p for p in my_parents if p in their_parents), None)\n    if common_parent is None:\n        slf = f\"{self.__class__.__name__} {id(self)}\"\n        nd = f\"{other.__class__.__name__} {id(other)}\"\n        raise RuntimeError(f\"No common parent between nodes {slf} and {nd}.\")\n\n    up = my_parents[: my_parents.index(common_parent) + 1]\n    down = their_parents[: their_parents.index(common_parent)][::-1]\n    return (up, down)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Volume.path_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Volume.remove_child","title":"remove_child","text":"<pre><code>remove_child(child: AnyNode) -&gt; None\n</code></pre> <p>Remove a child node from this node. Does not raise if child is missing.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def remove_child(self, child: AnyNode) -&gt; None:\n    \"\"\"Remove a child node from this node. Does not raise if child is missing.\"\"\"\n    if child in self._children:\n        self._children.remove(child)\n        child.parent = None\n        self.child_removed.emit(child)\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Volume.transform_to_node","title":"transform_to_node","text":"<pre><code>transform_to_node(other: Node) -&gt; Transform\n</code></pre> <p>Return Transform that maps from coordinate frame of <code>self</code> to <code>other</code>.</p> <p>Note that there must be a single path in the scenegraph that connects the two entities; otherwise an exception will be raised.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>transform</code> (              <code>instance of ChainTransform</code> )          \u2013            <p>The transform.</p> </li> </ul> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def transform_to_node(self, other: Node) -&gt; Transform:\n    \"\"\"Return Transform that maps from coordinate frame of `self` to `other`.\n\n    Note that there must be a _single_ path in the scenegraph that connects\n    the two entities; otherwise an exception will be raised.\n\n    Parameters\n    ----------\n    other : instance of Node\n        The other node.\n\n    Returns\n    -------\n    transform : instance of ChainTransform\n        The transform.\n    \"\"\"\n    a, b = self.path_to_node(other)\n    tforms = [n.transform for n in a[:-1]] + [n.transform.inv() for n in b]\n    return Transform.chain(*tforms[::-1])\n</code></pre>"},{"location":"reference/scenex/model/#scenex.model.Volume.transform_to_node(other)","title":"<code>other</code>","text":"(<code>instance of Node</code>)           \u2013            <p>The other node.</p>"},{"location":"reference/scenex/model/#scenex.model.Volume.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr() -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of self and its descendants.</p> Source code in <code>src/scenex/model/_nodes/node.py</code> <pre><code>def tree_repr(self) -&gt; str:\n    \"\"\"Return an ASCII/Unicode tree representation of self and its descendants.\"\"\"\n    from scenex.util import tree_repr\n\n    return tree_repr(self, node_repr=object.__repr__)\n</code></pre>"},{"location":"reference/scenex/util/","title":"util","text":""},{"location":"reference/scenex/util/#scenex.util","title":"scenex.util","text":"<p>Utility functions for displaying and debugging scenex visualizations.</p> <p>This module provides helper functions for common visualization tasks including displaying models, formatting scene graph trees, and utility functions used internally by scenex.</p> <p>The <code>show()</code> function is the primary entry point for creating visualizations, handling the details of canvas creation, backend selection, and camera fitting automatically for a provided node, view or canvas.</p> <p>Functions:</p> <ul> <li> <code>show</code>             \u2013              <p>Display a visualization by creating a canvas and making it visible.</p> </li> <li> <code>tree_dict</code>             \u2013              <p>Build an intermediate representation of the tree rooted at <code>node</code>.</p> </li> <li> <code>tree_repr</code>             \u2013              <p>Return an ASCII/Unicode tree representation of <code>node</code> and its descendants.</p> </li> </ul>"},{"location":"reference/scenex/util/#scenex.util.SupportsChildren","title":"SupportsChildren","text":"<p>               Bases: <code>Protocol</code></p> <pre><code>\n              flowchart TD\n              scenex.util.SupportsChildren[SupportsChildren]\n\n              \n\n              click scenex.util.SupportsChildren href \"\" \"scenex.util.SupportsChildren\"\n            </code></pre> <p>Protocol for node-like objects that have children.</p> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>Iterable[SupportsChildren]</code>)           \u2013            <p>Return the children of the node.</p> </li> </ul>"},{"location":"reference/scenex/util/#scenex.util.SupportsChildren.children","title":"children  <code>property</code>","text":"<pre><code>children: Iterable[SupportsChildren]\n</code></pre> <p>Return the children of the node.</p>"},{"location":"reference/scenex/util/#scenex.util.show","title":"show","text":"<pre><code>show(\n    obj: Node | View | Canvas, *, backend: str | None = None\n) -&gt; Canvas\n</code></pre> <p>Display a visualization by creating a canvas and making it visible.</p> <p>This is the primary function for creating and displaying scenex visualizations. It accepts nodes, views, or canvases, automatically wrapping them in the necessary container objects and creating the appropriate backend adaptors.</p> <p>The function automatically fits the camera view to show all visible content and makes the canvas window visible. After calling <code>show()</code>, use <code>run()</code> to enter the event loop (in desktop applications) or continue working (in notebooks).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Canvas</code>           \u2013            <p>The canvas containing the visualization. Can be used to further manipulate the display or access the created views.</p> </li> </ul> <p>Examples:</p> <p>Show a simple image:     &gt;&gt;&gt; import numpy as np     &gt;&gt;&gt; import scenex as snx     &gt;&gt;&gt; data = np.random.rand(100, 100).astype(np.float32)     &gt;&gt;&gt; img = snx.Image(data=data)     &gt;&gt;&gt; canvas = snx.show(img)     &gt;&gt;&gt; snx.run()</p> <p>Edit the returned canvas:     &gt;&gt;&gt; from cmap import Color     &gt;&gt;&gt; canvas.background_color = Color(\"white\")     &gt;&gt;&gt; canvas.width = 800     &gt;&gt;&gt; snx.run()</p> Notes <ul> <li>The camera is automatically zoomed to fit all visible content with 90% coverage</li> <li>Canvas size defaults to the view's layout dimensions</li> <li>Call <code>run()</code> after <code>show()</code> to enter the event loop in desktop applications</li> <li>In Jupyter notebooks, visualizations appear automatically without <code>run()</code></li> </ul> Source code in <code>src/scenex/util.py</code> <pre><code>def show(\n    obj: model.Node | model.View | model.Canvas, *, backend: str | None = None\n) -&gt; model.Canvas:\n    \"\"\"Display a visualization by creating a canvas and making it visible.\n\n    This is the primary function for creating and displaying scenex visualizations.\n    It accepts nodes, views, or canvases, automatically wrapping them in the necessary\n    container objects and creating the appropriate backend adaptors.\n\n    The function automatically fits the camera view to show all visible content and\n    makes the canvas window visible. After calling `show()`, use `run()` to enter\n    the event loop (in desktop applications) or continue working (in notebooks).\n\n    Parameters\n    ----------\n    obj : Node | View | Canvas\n        The object to visualize:\n        - Node (Image, Points, Line, etc.): Wrapped in Scene and View automatically\n        - Scene: Wrapped in a View with a default Camera\n        - View: Placed on a new Canvas\n        - Canvas: Displayed directly (already contains Views)\n    backend : str | None, optional\n        Graphics backend to use (\"pygfx\" or \"vispy\"). If None, uses the backend\n        specified by `use()`, `SCENEX_CANVAS_BACKEND` environment variable, or\n        auto-detection. Default is `None`.\n\n    Returns\n    -------\n    Canvas\n        The canvas containing the visualization. Can be used to further manipulate\n        the display or access the created views.\n\n    Examples\n    --------\n    Show a simple image:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import scenex as snx\n        &gt;&gt;&gt; data = np.random.rand(100, 100).astype(np.float32)\n        &gt;&gt;&gt; img = snx.Image(data=data)\n        &gt;&gt;&gt; canvas = snx.show(img)\n        &gt;&gt;&gt; snx.run()\n\n    Edit the returned canvas:\n        &gt;&gt;&gt; from cmap import Color\n        &gt;&gt;&gt; canvas.background_color = Color(\"white\")\n        &gt;&gt;&gt; canvas.width = 800\n        &gt;&gt;&gt; snx.run()\n\n    Notes\n    -----\n    - The camera is automatically zoomed to fit all visible content with 90% coverage\n    - Canvas size defaults to the view's layout dimensions\n    - Call `run()` after `show()` to enter the event loop in desktop applications\n    - In Jupyter notebooks, visualizations appear automatically without `run()`\n    \"\"\"\n    from .adaptors import get_adaptor_registry\n\n    view = None\n    if isinstance(obj, model.Canvas):\n        canvas = obj\n    else:\n        if isinstance(obj, model.View):\n            view = obj\n        elif isinstance(obj, model.Scene):\n            view = model.View(scene=obj)\n        elif isinstance(obj, model.Node):\n            scene = model.Scene(children=[obj])\n            view = model.View(scene=scene)\n\n        canvas = model.Canvas(\n            # Respect the view size if provided\n            width=int(view.layout.width),\n            height=int(view.layout.height),\n            views=[view],\n        )\n\n    canvas.visible = True\n    reg = get_adaptor_registry(backend=backend)\n    reg.get_adaptor(canvas, create=True)\n    app().create_app()\n    for view in canvas.views:\n        projections.zoom_to_fit(view, zoom_factor=0.9, preserve_aspect_ratio=True)\n\n        # logger.debug(\"SHOW MODEL  %s\", tree_repr(view.scene))\n        # native_scene = view.scene._get_native()\n        # logger.debug(\"SHOW NATIVE %s\", tree_repr(native_scene))\n    return canvas\n</code></pre>"},{"location":"reference/scenex/util/#scenex.util.show(obj)","title":"<code>obj</code>","text":"(<code>Node | View | Canvas</code>)           \u2013            <p>The object to visualize: - Node (Image, Points, Line, etc.): Wrapped in Scene and View automatically - Scene: Wrapped in a View with a default Camera - View: Placed on a new Canvas - Canvas: Displayed directly (already contains Views)</p>"},{"location":"reference/scenex/util/#scenex.util.show(backend)","title":"<code>backend</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Graphics backend to use (\"pygfx\" or \"vispy\"). If None, uses the backend specified by <code>use()</code>, <code>SCENEX_CANVAS_BACKEND</code> environment variable, or auto-detection. Default is <code>None</code>.</p>"},{"location":"reference/scenex/util/#scenex.util.tree_dict","title":"tree_dict","text":"<pre><code>tree_dict(\n    node: SupportsChildren,\n    *,\n    obj_name: Callable[[Any], str] = _cls_name_with_id,\n) -&gt; Tree\n</code></pre> <p>Build an intermediate representation of the tree rooted at <code>node</code>.</p> <p>Leaves are represented as strings, and non-leaf nodes are represented as dictionaries with the node name as the key and a list of child nodes as the value. This is useful for debugging and visualization purposes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str | dict[str, list[dict | str]]</code>           \u2013            <p>A string, if the node is a leaf, or a dictionary representing the tree, if the node has children, like <code>{\"node_name\": [\"child1\", \"child2\", ...]}</code>.</p> </li> </ul> Source code in <code>src/scenex/util.py</code> <pre><code>def tree_dict(\n    node: SupportsChildren,\n    *,\n    obj_name: Callable[[Any], str] = _cls_name_with_id,\n) -&gt; Tree:\n    \"\"\"Build an intermediate representation of the tree rooted at `node`.\n\n    Leaves are represented as strings, and non-leaf nodes are represented as\n    dictionaries with the node name as the key and a list of child nodes as the value.\n    This is useful for debugging and visualization purposes.\n\n    Parameters\n    ----------\n    node : SupportsChildren\n        The root node of the tree to be represented.\n    obj_name : Callable[[Any], str], optional\n        A function to convert the node to a string. Defaults to a lambda function that\n        returns the class name and ID\n\n    Returns\n    -------\n    str | dict[str, list[dict | str]]\n        A string, if the node is a leaf, or a dictionary representing the tree,\n        if the node has children, like `{\"node_name\": [\"child1\", \"child2\", ...]}`.\n    \"\"\"\n    node_name = obj_name(node)\n    if not (children := _get_children(node)):\n        return node_name\n\n    result: list[dict | str] = []\n    for child in children:\n        result.append(tree_dict(child, obj_name=obj_name))\n    return {obj_name(node): result}\n</code></pre>"},{"location":"reference/scenex/util/#scenex.util.tree_dict(node)","title":"<code>node</code>","text":"(<code>SupportsChildren</code>)           \u2013            <p>The root node of the tree to be represented.</p>"},{"location":"reference/scenex/util/#scenex.util.tree_dict(obj_name)","title":"<code>obj_name</code>","text":"(<code>Callable[[Any], str]</code>, default:                   <code>_cls_name_with_id</code> )           \u2013            <p>A function to convert the node to a string. Defaults to a lambda function that returns the class name and ID</p>"},{"location":"reference/scenex/util/#scenex.util.tree_repr","title":"tree_repr","text":"<pre><code>tree_repr(\n    node: SupportsChildren,\n    *,\n    node_repr: Callable[[Any], str] = __repr__,\n    _prefix: str = \"\",\n    _is_last: bool = True,\n) -&gt; str\n</code></pre> <p>Return an ASCII/Unicode tree representation of <code>node</code> and its descendants.</p> <p>This assumes that <code>node</code> is a tree-like object with a <code>children</code> attribute that is either a property or a callable that returns an iterable of child nodes.</p> <p>Parameters:</p> Source code in <code>src/scenex/util.py</code> <pre><code>def tree_repr(\n    node: SupportsChildren,\n    *,\n    node_repr: Callable[[Any], str] = object.__repr__,\n    _prefix: str = \"\",\n    _is_last: bool = True,\n) -&gt; str:\n    \"\"\"\n    Return an ASCII/Unicode tree representation of `node` and its descendants.\n\n    This assumes that `node` is a tree-like object with a `children` attribute that is\n    either a property or a callable that returns an iterable of child nodes.\n\n    Parameters\n    ----------\n    node : SupportsChildren\n        Any object that has a `children` attribute or method that returns an iterable\n        of child nodes.\n    node_repr : Callable[[Any], str], optional\n        Function to convert the node to a string. Defaults to `object.__repr__` (which\n        avoids complex repr functions on objects, but use `repr` if you want to see\n        the full representation).\n    _prefix : str, optional\n        Prefix to use for each line of the tree. Defaults to an empty string.\n    _is_last : bool, optional\n        Whether this node is the last child of its parent. Defaults to `True`.\n        This is used to determine the branch character to use in the tree\n        representation.\n    \"\"\"\n    if _prefix:\n        branch = \"\u2514\u2500\u2500 \" if _is_last else \"\u251c\u2500\u2500 \"\n    else:\n        branch = \"\"\n\n    lines: list[str] = [f\"{_prefix}{branch}{node_repr(node)}\"]\n    if children := list(_get_children(node)):\n        prefix_child = _prefix + (\"    \" if _is_last else \"\u2502   \")\n        for idx, child in enumerate(children):\n            lines.append(\n                tree_repr(\n                    child,\n                    node_repr=node_repr,\n                    _prefix=prefix_child,\n                    _is_last=idx == len(children) - 1,\n                )\n            )\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/scenex/util/#scenex.util.tree_repr(node)","title":"<code>node</code>","text":"(<code>SupportsChildren</code>)           \u2013            <p>Any object that has a <code>children</code> attribute or method that returns an iterable of child nodes.</p>"},{"location":"reference/scenex/util/#scenex.util.tree_repr(node_repr)","title":"<code>node_repr</code>","text":"(<code>Callable[[Any], str]</code>, default:                   <code>__repr__</code> )           \u2013            <p>Function to convert the node to a string. Defaults to <code>object.__repr__</code> (which avoids complex repr functions on objects, but use <code>repr</code> if you want to see the full representation).</p>"},{"location":"reference/scenex/util/#scenex.util.tree_repr(_prefix)","title":"<code>_prefix</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Prefix to use for each line of the tree. Defaults to an empty string.</p>"},{"location":"reference/scenex/util/#scenex.util.tree_repr(_is_last)","title":"<code>_is_last</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether this node is the last child of its parent. Defaults to <code>True</code>. This is used to determine the branch character to use in the tree representation.</p>"},{"location":"reference/scenex/utils/","title":"utils","text":""},{"location":"reference/scenex/utils/#scenex.utils","title":"scenex.utils","text":"<p>Utilities for working with scenex structures.</p> <p>Modules:</p> <ul> <li> <code>projections</code>           \u2013            <p>Utilities for creating projection matrices.</p> </li> </ul>"},{"location":"reference/scenex/utils/projections/","title":"projections","text":""},{"location":"reference/scenex/utils/projections/#scenex.utils.projections","title":"scenex.utils.projections","text":"<p>Utilities for creating projection matrices.</p> <p>Functions:</p> <ul> <li> <code>orthographic</code>             \u2013              <p>Creates an orthographic projection matrix.</p> </li> <li> <code>perspective</code>             \u2013              <p>Creates a perspective projection matrix.</p> </li> <li> <code>zoom_to_fit</code>             \u2013              <p>Adjusts the Camera to fit the entire scene.</p> </li> </ul>"},{"location":"reference/scenex/utils/projections/#scenex.utils.projections.orthographic","title":"orthographic","text":"<pre><code>orthographic(\n    width: float = 1, height: float = 1, depth: float = 1\n) -&gt; Transform\n</code></pre> <p>Creates an orthographic projection matrix.</p> <p>Note that the resulting projection matrix provides no positional offset; this would be out of scope, as such is the job of a camera's transform parameter.</p> <p>TODO: Consider passing bounds (i.e. a tuple[float, float]) for each parameter. Unfortunately, though, this would effectively allow positional offsets for width and height.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>projection</code> (              <code>Transform</code> )          \u2013            <p>A Transform matrix creating an orthographic camera view</p> </li> </ul> Source code in <code>src/scenex/utils/projections.py</code> <pre><code>def orthographic(width: float = 1, height: float = 1, depth: float = 1) -&gt; Transform:\n    \"\"\"Creates an orthographic projection matrix.\n\n    Note that the resulting projection matrix provides no positional offset; this would\n    be out of scope, as such is the job of a camera's transform parameter.\n\n    TODO: Consider passing bounds (i.e. a tuple[float, float]) for each parameter.\n    Unfortunately, though, this would effectively allow positional offsets for width and\n    height.\n\n    Parameters\n    ----------\n    width: float, optional\n        The width of the camera rectangular prism. Default 1 (mirroring the side length\n        of a unit cube).\n    height: float, optional\n        The height of the camera rectangular prism. Default 1 (mirroring the side length\n        of a unit cube).\n    depth: float, optional\n        The depth of the camera rectangular prism. The near and far clipping planes of\n        the resulting matrix become (-depth / 2) and (depth / 2) respectively. Default\n        1, increase (to render things farther away) or decrease (to increase\n        performance) as needed.\n\n        TODO: Is this a good default? May want to consider some large number (1000?)\n        instead\n\n    Returns\n    -------\n    projection: Transform\n        A Transform matrix creating an orthographic camera view\n    \"\"\"\n    width = width if width else 1e-6\n    height = height if height else 1e-6\n    depth = depth if depth else 1e-6\n    return Transform().scaled((2 / width, 2 / height, -2 / depth))\n</code></pre>"},{"location":"reference/scenex/utils/projections/#scenex.utils.projections.orthographic(width)","title":"<code>width</code>","text":"(<code>float</code>, default:                   <code>1</code> )           \u2013            <p>The width of the camera rectangular prism. Default 1 (mirroring the side length of a unit cube).</p>"},{"location":"reference/scenex/utils/projections/#scenex.utils.projections.orthographic(height)","title":"<code>height</code>","text":"(<code>float</code>, default:                   <code>1</code> )           \u2013            <p>The height of the camera rectangular prism. Default 1 (mirroring the side length of a unit cube).</p>"},{"location":"reference/scenex/utils/projections/#scenex.utils.projections.orthographic(depth)","title":"<code>depth</code>","text":"(<code>float</code>, default:                   <code>1</code> )           \u2013            <p>The depth of the camera rectangular prism. The near and far clipping planes of the resulting matrix become (-depth / 2) and (depth / 2) respectively. Default 1, increase (to render things farther away) or decrease (to increase performance) as needed.</p> <p>TODO: Is this a good default? May want to consider some large number (1000?) instead</p>"},{"location":"reference/scenex/utils/projections/#scenex.utils.projections.perspective","title":"perspective","text":"<pre><code>perspective(\n    fov: float, near: float, far: float\n) -&gt; Transform\n</code></pre> <p>Creates a perspective projection matrix.</p> <p>Note that the resulting projection matrix provides no positional offset; this would be out of scope, as such is the job of a camera's transform parameter.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>projection</code> (              <code>Transform</code> )          \u2013            <p>A Transform matrix creating a perspective camera view</p> </li> </ul> Source code in <code>src/scenex/utils/projections.py</code> <pre><code>def perspective(fov: float, near: float, far: float) -&gt; Transform:\n    \"\"\"Creates a perspective projection matrix.\n\n    Note that the resulting projection matrix provides no positional offset; this would\n    be out of scope, as such is the job of a camera's transform parameter.\n\n    Parameters\n    ----------\n    fov: float\n        The field of view of the camera rectangle.\n    near: float\n        The distance from the camera to the near clipping plane.\n    far: float\n        The distance from the camera to the far clipping plane.\n\n    Returns\n    -------\n    projection: Transform\n        A Transform matrix creating a perspective camera view\n    \"\"\"\n    if fov == 0:\n        raise ValueError(\n            \"Perspective matrices require fov&gt;0. Maybe consider an orthographic matrix?\"\n        )\n\n    matrix = np.zeros((4, 4))\n\n    # Computations derived from\n    # https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix.html\n    scaling_factor = 1 / (tan(fov / 2 * pi / 180))\n    matrix[0, 0] = scaling_factor\n    matrix[1, 1] = scaling_factor\n\n    z_scale = -1 * far / (far - near)\n    matrix[2, 2] = z_scale\n    z_translation = -1 * far * near / (far - near)\n    matrix[2, 3] = z_translation\n\n    matrix[3, 2] = -1\n    return Transform(root=matrix)\n</code></pre>"},{"location":"reference/scenex/utils/projections/#scenex.utils.projections.perspective(fov)","title":"<code>fov</code>","text":"(<code>float</code>)           \u2013            <p>The field of view of the camera rectangle.</p>"},{"location":"reference/scenex/utils/projections/#scenex.utils.projections.perspective(near)","title":"<code>near</code>","text":"(<code>float</code>)           \u2013            <p>The distance from the camera to the near clipping plane.</p>"},{"location":"reference/scenex/utils/projections/#scenex.utils.projections.perspective(far)","title":"<code>far</code>","text":"(<code>float</code>)           \u2013            <p>The distance from the camera to the far clipping plane.</p>"},{"location":"reference/scenex/utils/projections/#scenex.utils.projections.zoom_to_fit","title":"zoom_to_fit","text":"<pre><code>zoom_to_fit(\n    view: View,\n    type: Literal[\n        \"perspective\", \"orthographic\"\n    ] = \"orthographic\",\n    zoom_factor: float = 1.0,\n    preserve_aspect_ratio: bool = False,\n) -&gt; None\n</code></pre> <p>Adjusts the Camera to fit the entire scene.</p> <p>Parameters:</p> Source code in <code>src/scenex/utils/projections.py</code> <pre><code>def zoom_to_fit(\n    view: View,\n    type: Literal[\"perspective\", \"orthographic\"] = \"orthographic\",\n    zoom_factor: float = 1.0,\n    preserve_aspect_ratio: bool = False,\n) -&gt; None:\n    \"\"\"Adjusts the Camera to fit the entire scene.\n\n    Parameters\n    ----------\n    view: View\n        The view to adjust. Contains the camera, whose parameters will be adjusted, and\n        the scene, whose elements will be considered in the adjustment.\n    type: Literal[\"perspective\", \"orthographic\"]\n        The type of canvas projection to use. Orthographic by default.\n    zoom_factor: float\n        The amount to zoom the scene after adjusting camera parameters. The default,\n        1.0, will leave the scene touching the edges of the view. As the zoom factor\n        approaches 0, the scene will linearly decrease in size. As the zoom factor\n        increases beyond 1.0, the bounds of the scene will expand linearly beyond the\n        view.\n    preserve_aspect_ratio: bool\n        Whether to apply aspect ratio correction to prevent distortion. When True,\n        squares will appear as squares regardless of view dimensions. When False,\n        content may be stretched to fill the view. Default False.\n\n        FIXME: Is this the correct name for this behavior?\n    \"\"\"\n    bb = view.scene.bounding_box\n    center = np.mean(bb, axis=0) if bb else (0, 0, 0)\n    w, h, d = np.ptp(bb, axis=0) if bb else (1, 1, 1)\n\n    # Apply aspect ratio correction only if requested\n    if preserve_aspect_ratio:\n        aspect_ratio = view.layout.width / view.layout.height\n        if aspect_ratio is not None:\n            if w / h &gt; aspect_ratio:\n                h = w / aspect_ratio\n            else:\n                w = h * aspect_ratio\n    if type == \"orthographic\":\n        view.camera.transform = Transform().translated(center)\n        view.camera.projection = orthographic(w, h, d).scaled([zoom_factor] * 3)\n    elif type == \"perspective\":\n        # Compute the distance a to the near plane of the frustum using a default fov\n        o = max(w, h) / 2\n        fov = 70\n        a = o / tan(fov * pi / 360) / zoom_factor\n\n        # So that the bounding cube's front plane is mapped to the canvas,\n        # the camera must be a units away from the front plane (at z=(center[2] + d/2))\n        z_bound = center[2] + (d / 2) + a\n        view.camera.transform = Transform().translated((center[0], center[1], z_bound))\n        # Note that the near and far planes are set to reasonable defaults.\n        # TODO: Consider making these parameters\n        view.camera.projection = perspective(fov, near=1, far=1_000_000)\n    else:\n        raise TypeError(f\"Unrecognized projection type: {type}\")\n</code></pre>"},{"location":"reference/scenex/utils/projections/#scenex.utils.projections.zoom_to_fit(view)","title":"<code>view</code>","text":"(<code>View</code>)           \u2013            <p>The view to adjust. Contains the camera, whose parameters will be adjusted, and the scene, whose elements will be considered in the adjustment.</p>"},{"location":"reference/scenex/utils/projections/#scenex.utils.projections.zoom_to_fit(type)","title":"<code>type</code>","text":"(<code>Literal['perspective', 'orthographic']</code>, default:                   <code>'orthographic'</code> )           \u2013            <p>The type of canvas projection to use. Orthographic by default.</p>"},{"location":"reference/scenex/utils/projections/#scenex.utils.projections.zoom_to_fit(zoom_factor)","title":"<code>zoom_factor</code>","text":"(<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The amount to zoom the scene after adjusting camera parameters. The default, 1.0, will leave the scene touching the edges of the view. As the zoom factor approaches 0, the scene will linearly decrease in size. As the zoom factor increases beyond 1.0, the bounds of the scene will expand linearly beyond the view.</p>"},{"location":"reference/scenex/utils/projections/#scenex.utils.projections.zoom_to_fit(preserve_aspect_ratio)","title":"<code>preserve_aspect_ratio</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to apply aspect ratio correction to prevent distortion. When True, squares will appear as squares regardless of view dimensions. When False, content may be stretched to fill the view. Default False.</p> <p>FIXME: Is this the correct name for this behavior?</p>"}]}